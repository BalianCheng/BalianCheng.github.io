<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Balian&#39;s Blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.codingbalian.online/"/>
  <updated>2017-03-14T11:05:30.218Z</updated>
  <id>http://www.codingbalian.online/</id>
  
  <author>
    <name>Balian Cheng</name>
    <email>393418737@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>jQuery-selector</title>
    <link href="http://www.codingbalian.online/2017/03/14/jQuery-selector/"/>
    <id>http://www.codingbalian.online/2017/03/14/jQuery-selector/</id>
    <published>2017-03-14T07:04:01.490Z</published>
    <updated>2017-03-14T11:05:30.218Z</updated>
    
    <content type="html"><![CDATA[<p>jQuery中选择器的使用<br><a id="more"></a></p>
<h2 id="1">选择器</h2>

<h3 id="1.1">元素判断</h3>

<p><code>$(&quot;span,#two&quot;).css(&quot;background&quot;,&quot;#bbffaa&quot;)</code>选择了页面中不存在的元素也不会报错，但是要检验一个元素是否存在时，应该使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">if($(&quot;span,#two&quot;).length&gt;0)&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="1.2">基本选择器</h3>

<p><code>$(&quot;span,#two&quot;)</code>选择span元素和id为wtwo的元素<br><code>$(&quot;.one&quot;)</code>选择class为one的元素<br><code>$(&quot;span&quot;)</code>选择所有span元素<br><code>$(&quot;#two&quot;)</code>选择id为two的元素<br><code>$(&quot;*&quot;)</code>选择所有元素</p>
<h3 id="1.3">层次选择器</h3><br><code>$(&quot;div span&quot;)</code>选择div中的所有span后代元素(后代元素，包括子元素)<br><code>$(&quot;div&gt;span&quot;)</code>选择div中的所有span子元素<br><code>$(&quot;div+span&quot;)</code>选择紧跟在div后的span同辈元素，等价于<code>$(&quot;div&quot;).next(&quot;span&quot;)</code><br><code>$(&quot;div~span&quot;)</code>选择紧跟在div后的所有span同辈元素，等价于<code>$(&quot;div&quot;).nextAll(&quot;span&quot;)</code><br><br><h3 id="1.4"> 基本过滤选择器</h3>

<p><code>$(&quot;div:fist&quot;)</code>选择所有div元素中的第一个div元素<br><code>$(&quot;div:last&quot;)</code>选择所有div元素中的最后一个div元素<br><code>$(&quot;div:not(.one)&quot;)</code>选择所有div元素中class不为one的所有div元素<br><code>$(&quot;div:even&quot;)</code>选择索引是偶数的div元素<br><code>$(&quot;div:odd&quot;)</code>选择索引是奇数的div元素<br><code>$(&quot;div:eq(1)&quot;)</code>选择索引为1的div元素（索引从0开始）<br><code>$(&quot;div:gt(1)&quot;)</code>选择索引大于1的div元素（索引从0开始）<br><code>$(&quot;div:lt(1)&quot;)</code>选择索引小于1的div元素（索引从0开始）<br><code>$(&quot;:header&quot;)</code>选择索引标题元素<br><code>$(&quot;:animated&quot;)</code>选择正在执行的动画元素<br><code>$(&quot;:focus&quot;)</code>选择获取焦点的元素</p>
<h3 id="1.5"> 内容过滤选择器</h3>

<p><code>$(&quot;div:contains(&#39;=&#39;)&quot;)</code>选择含有文本内容为”=”的div元素<br><code>$(&quot;div:empty&quot;)</code>选择没有子元素或者文本的空div元素<br><code>$(&quot;div:has(.mini)&quot;)</code>选择含有class为mini子元素的div元素<br><code>$(&quot;div:parent&quot;)</code>选择含有子元素或文本元素的div元素</p>
<h3 id="1.6"> 可见性过滤选择器</h3>

<p><code>$(&quot;div:visible&quot;)</code>选取所有可见的div元素<br><code>$(&quot;div:hidden&quot;)</code>选取所有不可见的div元素</p>
<h3 id="1.7"> 属性过滤选择器</h3>

<p><code>$(&quot;div[id]&quot;)</code>选取有id属性的div元素<br><code>$(&quot;div[title=test]&quot;)</code>选取title属性为test的div元素<br><code>$(&quot;div[title^=t]&quot;)</code>选取title属性值以t开头的div元素<br><code>$(&quot;div[title$=t]&quot;)</code>选取title属性值以t结尾的div元素<br><code>$(&quot;div[title*=t]&quot;)</code>选取title属性含有的div元素<br><code>$(&quot;div[title|=t]&quot;)</code>选取title属性值以t为前缀（前缀后必须包含“-”）的div元素<br><code>$(&quot;div[title~=t]&quot;)</code>选取title属性值以空格分隔的包含t的div元素<br><code>$(&quot;div[title$=t][id]&quot;)</code>满足相应条件的多条件选择器</p>
<h3 id="1.8"> 子元素过滤选择器</h3>

<p><code>$(&quot;div:nth-child(1/odd/even/(3n))&quot;)</code>索引从1算起，选取div所有div元素下的第一个/奇数/偶数/3n倍数的子元素<br><code>$(&quot;div:first-child&quot;)</code>所有div下的第一个子元素<br><code>$(&quot;div:last-child&quot;)</code>所有div下的最后一个子元素<br><code>$(&quot;div:only-child&quot;)</code>选取只包含一个子元素的div元素的子元素</p>
<h2 id="2"> 表单选择器</h2>

<h3 id="2.1"> 表单对象属性过滤选择器</h3>

<p><code>$(input:enabled)</code>选取所有input元素中可用的元素<br><code>$(input:disabled)</code>选取所有input元素中不可用的元素<br><code>$(input:checked)</code>选取所有input元素中被选中的单选框复选框元素<br><code>$(input:selected)</code>选取所有input元素中被选中的下拉列表元素</p>
<h3 id="2.2"> 表单选择器</h3>

<p><code>$(#form1:input)</code>选取class为form1元素下的所有<code>&lt;input&gt;,&lt;textarea&gt;,&lt;button&gt;,&lt;select&gt;</code>元素<br><code>$(#form1:text)</code>选取class为form1元素下的所有单行文本框<br><code>$(#form1:password)</code>选取class为form1元素下的所有密码框<br><code>$(#form1:radio)</code>选取class为form1元素下的所有单选框<br><code>$(#form1:submit)</code>选取class为form1元素下的所有提交按钮<br><code>$(#form1:checkbox)</code>选取class为form1元素下的所有多选框<br><code>$(#form1:image)</code>选取class为form1元素下的所有图像按钮<br><code>$(#form1:reset)</code>选取class为form1元素下的所有重置按钮<br><code>$(#form1:button)</code>选取class为form1元素下的所有按钮<br><code>$(#form1:file)</code>选取class为form1元素下的所有上传域<br><code>$(#form1:hidden)</code>选取class为form1元素下的所有不可见元素</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;jQuery中选择器的使用&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://www.codingbalian.online/categories/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>JS高级技巧</title>
    <link href="http://www.codingbalian.online/2017/03/09/JS-skill/"/>
    <id>http://www.codingbalian.online/2017/03/09/JS-skill/</id>
    <published>2017-03-09T11:57:34.000Z</published>
    <updated>2017-03-13T14:24:14.270Z</updated>
    
    <content type="html"><![CDATA[<p>　<br><a id="more"></a></p>
<h2 id="1">高级函数</h2>

<h3 id="1.1">安全类型检测</h3>

<p>typeof在Safari中检测正则表达式时会返回function，instanceof在检测数组时由于Array是window的对象，被检测的对象必须和Array构造函数位于同个全局作用域中。<br>因此使用原生的toString方法可以避免出错：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Object.prototype.toString.call(obj)==&quot;[boject Array]&quot;</div></pre></td></tr></table></figure></p>
<h3 id="1.2">安全作用域</h3>

<p>当构造函数使用this关键字，创建新对象时没有使用new时，this会直接映射到window上，因此需要创造安全的作用域：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">function person(name,age) &#123;</div><div class="line">    if (this instanceof person) &#123;//判断</div><div class="line">        this.name = name</div><div class="line">        this.age = age</div><div class="line">    &#125;</div><div class="line">    else &#123;</div><div class="line">        return new person(name,age)//确保安全</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">person.prototype=&#123;</div><div class="line">    constructor:person,</div><div class="line">    sayName:function () &#123;</div><div class="line">        alert(this.name)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">Object.defineProperty(person.prototype,&quot;constructor&quot;,&#123;</div><div class="line">    enumerable:false,</div><div class="line">    value:person</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<h3 id="1.2">惰性载入函数</h3>

<p>函数中如果有大量的if语句，且if语句不用每次都执行，可以使用惰性载入的方法。比如在函数调用时在处理函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">function createXHR() &#123;</div><div class="line">    if (typeof XMLHttpRequest != &quot;undefined&quot;) &#123;</div><div class="line">        createXHR = function () &#123;</div><div class="line">            return new XMLHttpRequest()</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    else if (typeof ActiveXObject != &quot;undefined&quot;) &#123;</div><div class="line">        createXHR = function () &#123;</div><div class="line">            if (typeof arguments.callee.activeXString != &quot;string&quot;) &#123;</div><div class="line">                var versions = [&quot;Msxml2.XMLHTTP.6.0&quot;, &quot;Msxml2.XMLHTTP.3.0&quot;, &quot;Msxml2.XMLHTTP&quot;],</div><div class="line">                    i, len</div><div class="line">                for (i = 0, len = versions.length; i &lt; len; i++) &#123;</div><div class="line">                    try &#123;</div><div class="line">                        new ActiveXObject(versions[i])</div><div class="line">                        arguments.callee.activeXString = versions[i]</div><div class="line">                        break</div><div class="line">                    &#125; catch (ex) &#123;</div><div class="line"></div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            return new ActiveXObject(arguments.callee.activeXString)</div><div class="line">        &#125;</div><div class="line">    &#125; else &#123;</div><div class="line">        createXHR = function () &#123;</div><div class="line">            throw new Error(&quot;No XMLHttpRequest object available!&quot;)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return createXHR()</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>每一个分支都会覆盖原函数，最后调用新函数，下一次调用就会调用新的分配函数。</p>
<h3 id="1.3">函数绑定</h3>

<p>当调用一个对象的方法时，如果没有绑定其环境，方法中使用this的指向会改变，因此可以使用闭包或者函数绑定来执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">var handler=&#123;</div><div class="line">	message:&quot;Event&quot;,</div><div class="line">	handlerClick:function(event)&#123;</div><div class="line">		alert(this.message)</div><div class="line">	&#125;</div><div class="line">EventUtil.addHandler(btn,&quot;click&quot;,function(event)&#123;</div><div class="line">	handler.handlerClick(event)</div><div class="line">	&#125;)</div><div class="line">/*bind函数绑定环境</div><div class="line">    function bind(fn, context) &#123;</div><div class="line">        return function () &#123;</div><div class="line">            return fn.apply(context, arguments)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    EventUtil.addHandler(btn, &quot;click&quot;, bind(handler.handleClick, handler))</div><div class="line">*/</div><div class="line"></div><div class="line">/*原生bind函数</div><div class="line">    EventUtil.addHandler(btn, &quot;click&quot;,handler.handleClick.bind(handler))</div><div class="line">*/</div></pre></td></tr></table></figure></p>
<h3 id="1.4">函数柯里化</h3>

<p>调用另一个函数并为它传入要柯里化的函数和必要参数:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">function bind(fn,context)&#123;</div><div class="line">	//获取柯里化的参数</div><div class="line">	var args = Array.prototype.slice.call(arguments,2);//&quot;zhangsan&quot;,12</div><div class="line">	return function()&#123;</div><div class="line">		//获取调用函数时传入的参数</div><div class="line">		var innerArgs = Array.prototype.slice.call(arguments);//event</div><div class="line">		var finalArgs = innerArgs.concat(args);//event,&quot;zhangsan&quot;,12</div><div class="line">		return fn.apply(context,finalArgs);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">handler = &#123;</div><div class="line">	message:&quot;hehe&quot;,</div><div class="line">	handleClick:function(event,name,age)&#123;</div><div class="line">		console.log(this.message);</div><div class="line">		console.log(event.type);</div><div class="line">		console.log(name+&quot;:&quot;+age);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">var btn = document.getElementById(&quot;btn&quot;);</div><div class="line">btn.onclick = bind(handler.handleClick,handler,&quot;zhangsan&quot;,12);</div></pre></td></tr></table></figure></p>
<p>bind()方法也实现了函数柯里化，只要在this的值后再传入另一个参数即可:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">handler = &#123;</div><div class="line">	message:&quot;hehe&quot;,</div><div class="line">	handleClick:function(name,age,event)&#123;//event对象作为最后一个参数传入</div><div class="line">		console.log(this.message);</div><div class="line">		console.log(event.type);</div><div class="line">		console.log(name+&quot;:&quot;+age);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">var btn = document.getElementById(&quot;btn&quot;);</div><div class="line">btn.onclick = handler.handleClick.bind(handler,&quot;zhangsan&quot;,12);</div></pre></td></tr></table></figure></p>
<h3 id="1.5">防篡改对象</h3>

<p>一旦将对象定义成防篡改，就无法撤销了。<br>默认情况下，所有对象都是可以扩展的，任何时候都可以向对象中添加属性和方法。<br>Object.preventExtensions()方法可以禁止给对象添加属性和方法。<br>Object.istExtensible()：检测对象是否可扩展</p>
<p>密封对象不可扩展，而且已有成员的[[Configurable]]特性为false。不能删除属性和方法，可以修改:<br>Object.seal(person);</p>
<p>最严格的防篡改级别是冻结对象(frozen object)。不可扩展，又是密封的，而且对象的属性的[[Writable]]特性会被设置为false。无法直接修改属性，但是如果定义[[Set]]函数，访问器属性任然可以修改。</p>
<p>Object.freeze(person);//冻结对象</p>
<h3 id="1.6">Yielding Processes</h3>

<p>在浏览器中的JS都被分配了一个确定数量的资源。需要的内存大小和处理器时间都被严格限制了，防止恶意的Web程序员把用户机器资源耗尽。<br>脚本长时间运行的问题通常由两个原因之一造成：过长的，过深嵌套的函数调用或者是进行大量处理的循环。<br>对于后者，可以使用定时器分割这个循环。这是一种叫做数组分块(array  chunking)的技术，小块小块地处理数组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function chunk(array,process,context)&#123;//处理的数据，执行函数，运行环境</div><div class="line">    setTimeout(function()&#123;</div><div class="line">        var item = array.shift();//待处理事项</div><div class="line">        process.call(context,item);</div><div class="line">        if(array.length&gt;0)&#123;//如果还有待办事项</div><div class="line">            setTimeout(arguments.callee,100);</div><div class="line">        &#125;</div><div class="line">    &#125;,100);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="1.7">函数节流</h3>


<p>某些代码不可以在没有间断的情况连续重复执行。第一次调用函数，创建一个定时器，在指定的时间间隔之后运行代码。当第二次调用该函数时，它会清除前一次的定时器并设置另一个。如果前一个定时器已经执行过了，这个操作就没有任何意义。如果前一个定时器未执行，其实就是将其替换为一个新的定时器。目的是只有在执行函数的请求停止了一段时间之后才执行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">var processor =&#123;</div><div class="line">	timeoutId:null,</div><div class="line">	//实际处理的程序</div><div class="line">	performProcessing:function()&#123;</div><div class="line">		//实际执行的代码</div><div class="line">	&#125;</div><div class="line">	//初始处理调用的方法</div><div class="line">	process:function()&#123;</div><div class="line">		//清除前一个定时器</div><div class="line">		clearTimeout(this.timeoutId);</div><div class="line">		//保留this当前执行环境</div><div class="line">		var processContext = this;</div><div class="line">		//设置新的处理程序定时器</div><div class="line">		this.timeoutId = setTimeout(function()&#123;</div><div class="line">			processContext.performProcessing();//调用实际处理程序</div><div class="line">		&#125;,100);</div><div class="line">	&#125;</div><div class="line">&#125; </div><div class="line">//开始执行</div><div class="line">processor.process();</div></pre></td></tr></table></figure></p>
<p>使用throttle()函数来简化，该函数可自动进行定时器的设置和清除。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">function throttle(method,context)&#123;</div><div class="line">	clearTimeout(method.tId);</div><div class="line">	method.tId = setTimeout(function()&#123;</div><div class="line">		method.call(context);//如果没有给定执行环境，就会在全局作用域内执行</div><div class="line">	&#125;,1000);</div><div class="line">&#125;</div><div class="line"></div><div class="line">function resizeDiv()&#123;</div><div class="line">	var div = document.getElementById(&quot;editDiv&quot;);</div><div class="line">	div.style.height = div.offsetWidth + &quot;px&quot;;</div><div class="line">&#125;</div><div class="line">window.onresize = function()&#123;</div><div class="line">	//resizeDiv();</div><div class="line">	throttle(resizeDiv);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="1.8">自定义事件</h3>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">function EventTarget() &#123;</div><div class="line">    this.handlers = &#123;&#125;;//存储事件处理程序</div><div class="line">&#125;</div><div class="line">EventTarget.prototype = &#123;</div><div class="line">    constructor: EventTarget,</div><div class="line">    //type事件类型，handler处理该事件的函数</div><div class="line">    addHandler: function (type, handler) &#123;//注册给定类型事件的事件处理程序</div><div class="line">        if (typeof this.handlers[type] == &apos;undefined&apos;) &#123;</div><div class="line">            this.handlers[type] = [];</div><div class="line">        &#125;</div><div class="line">        this.handlers[type].push(handler);</div><div class="line">    &#125;,</div><div class="line">    //event,至少包含type属性的对象</div><div class="line">    fire: function (event) &#123;//触发一个事件</div><div class="line">        if (!event.target) &#123;//给event对象初始化设置一个target属性。</div><div class="line">            event.target = this;</div><div class="line">        &#125;</div><div class="line">        if (this.handlers[event.type] instanceof Array) &#123;//查找该事件类型的一组处理程序</div><div class="line">            var handlers = this.handlers[event.type];</div><div class="line">            for (var i = 0, len = handlers.length; i &lt; len; i++) &#123;//遍历调用所有的事件处理程序</div><div class="line">                handlers[i](event);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    removeHandler: function (type, handler) &#123;</div><div class="line">        if (this.handlers[type] instanceof Array) &#123;</div><div class="line">            var handlers = this.handlers[type];</div><div class="line">            for (var i = 0, len = handlers.length; i &lt; len; i++) &#123;</div><div class="line">                if (handlers[i] === handler) &#123;</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            handlers.splice(i, 1);//从数组中删除该处理程序</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用自定义的事件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function handlerMessage(event)&#123;</div><div class="line">	console.log(&quot;消息处理:&quot;+event.message);</div><div class="line">&#125;</div><div class="line">//创建一个新的对象</div><div class="line">var target = new EventTarget();</div><div class="line">//添加事件处理程序,类型是message</div><div class="line">target.addHandler(&quot;message&quot;,handlerMessage);</div><div class="line">//触发message类型的事件,并自定义event对象的message属性</div><div class="line">target.fire(&#123;type:&quot;message&quot;,message:&quot;消息事件处理&quot;&#125;);</div><div class="line">//删除事件处理程序</div><div class="line">target.removeHandler(&quot;message&quot;,handlerMessage);</div><div class="line">//再次触发事件，已删除</div><div class="line">target.fire(&#123;type:&quot;message&quot;,message:&quot;再次触发事件，已删除&quot;&#125;);</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://www.codingbalian.online/categories/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>AJAX&amp;Comet</title>
    <link href="http://www.codingbalian.online/2017/03/09/AJAX-Comet/"/>
    <id>http://www.codingbalian.online/2017/03/09/AJAX-Comet/</id>
    <published>2017-03-09T06:26:32.000Z</published>
    <updated>2017-03-09T09:32:14.833Z</updated>
    
    <content type="html"><![CDATA[<p>　<br><a id="more"></a></p>
<h2 id="1">XMLHttpRequest</h2>

<p>XHR是Ajax的核心。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">function createXHR() &#123;</div><div class="line">    if (typeof XMLHttpRequest != &quot;undefined&quot;) &#123;</div><div class="line">        return new XMLHttpRequest()</div><div class="line">    &#125;</div><div class="line">    else if (typeof ActiveXObject != &quot;undefined&quot;) &#123;</div><div class="line">        if (typeof arguments.callee.activeXString != &quot;string&quot;) &#123;</div><div class="line">            var versions = [&quot;Msxml2.XMLHTTP.6.0&quot;, &quot;Msxml2.XMLHTTP.3.0&quot;, &quot;Msxml2.XMLHTTP&quot;],</div><div class="line">                i, len</div><div class="line">            for (i = 0, len = versions.length; i &lt; len; i++) &#123;</div><div class="line">                try &#123;</div><div class="line">                    new ActiveXObject(versions[i])</div><div class="line">                    arguments.callee.activeXString = versions[i]</div><div class="line">                    break</div><div class="line">                &#125; catch (ex) &#123;</div><div class="line"></div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return new ActiveXObject(arguments.callee.activeXString)</div><div class="line">    &#125; else &#123;</div><div class="line">        throw new Error(&quot;No XMLHttpRequest object available!&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个函数可以支持创建所有版本的XHR对象。<br><code>var xhr=createXHR()</code><br>在使用XHR对象时，要调用的第一个方法是open()。open接受三个参数：请求方式：post或get，请求的URL和表示是否异步发送的布尔值。<br>要发送特定请求还需要使用send方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">xhr.open(&quot;get&quot;,&quot;index.html&quot;,false)</div><div class="line">xhr.send(null)</div></pre></td></tr></table></figure></p>
<p>send接受一个参数，为发送请求的主体，若不需要请求主体发送数据，必须传入null。<br>在收到服务器响应后，js会据需执行。响应的数据会自动填充XHR对象的属性：<br>responseText：作为响应主体返回的文本<br>responseXML：响应内容的类型若是”text/xml”或”application/xml”这个属性就会保存包含XMLDOM文档<br>status：响应的HTTP状态<br>statusText：HTTP状态说明<br>收到响应后，先检查status确定响应返回成功(200),(304）表示请求资源没有被修改，可以使用浏览器缓存中的内容。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">if ((xhr.status&gt;=200&amp;&amp;xhr.status&lt;300)||	xhr.status==304)&#123;</div><div class="line">	...&#125;	//success</div><div class="line">else&#123;</div><div class="line">	...&#125;//unsuccess</div></pre></td></tr></table></figure></p>
<p>异步请求下还需要检测XHR的readyState属性。0表示未初始化，1调用了open方法，2调用了send方法，3接受部分响应，4接受全部响应数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var xhr=createXHR()</div><div class="line">xhr.onreadystatechange=function()&#123;</div><div class="line">	if(xhr.readyState==4)&#123;</div><div class="line">		if ((xhr.status&gt;=200&amp;&amp;xhr.status&lt;300)||	xhr.status==304)&#123;</div><div class="line">		...&#125;	//success</div><div class="line">	else&#123;</div><div class="line">		...&#125;//unsuccess</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">xhr.open(&quot;get&quot;,&quot;index.html&quot;,false)</div><div class="line">xhr.send(null)</div></pre></td></tr></table></figure></p>
<p>在接受到响应之前可以用abort方法取消异步请求。</p>
<h3 id="1.1"> 头部信息</h3>

<p>每个请求和响应都会带有头部信息。可以使用setRequestHeader设置请求的头部信息。接受两个参数，头部字段的名称与头部字段的值。必须在open和send之间调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">xhr.open(...)</div><div class="line">xhr.setRequestHeader(&quot;header&quot;,&quot;value&quot;)</div><div class="line">xhr.send(null)</div></pre></td></tr></table></figure></p>
<p>调用getResponseHeader并传入头部名称可取的相应的头部字段信息。<br>getAllResponseHeaders可以取得所有的头部信息。</p>
<h3 id="1.2">GET请求</h3>

<p>get请求发送的格式：URL?name=value&amp;name2=value2<br>所有查询字参数必须调用encodeURIComponent方法编码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function addURLParam(url, name, value) &#123;</div><div class="line">    url += (url.indexOf(&quot;?&quot;) == -1 ? &quot;?&quot; : &quot;&amp;&quot;)</div><div class="line">    url += encodeURIComponent(name) + &quot;=&quot; + encodeURIComponent(value)</div><div class="line">    return url</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 i="1.3">Post请求</h3>

<p>引入函数表单序列化：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">function serialize(form) &#123;</div><div class="line">    var parts = [],</div><div class="line">        field = null,</div><div class="line">        i, len, j, optLen, option, optValue;</div><div class="line">    for (i = 0, len = form.elements.length; i &lt; len; i++) &#123;</div><div class="line">        field = form.elements[i]</div><div class="line">        switch (field.type) &#123;</div><div class="line">            case &quot;select-one&quot;:</div><div class="line">            case  &quot;select-multiple&quot;:</div><div class="line">                if (field.name.length) &#123;</div><div class="line">                    for (j = 0, optLen = field.options.length; j &lt; optLen; j++) &#123;</div><div class="line">                        option = field.options[j]</div><div class="line">                        if (option.selected) &#123;</div><div class="line">                            optValue = &quot;&quot;</div><div class="line">                            if (option.hasAttribute) &#123;</div><div class="line">                                optValue = (option.hasAttribute(&quot;value&quot;) ? option.value : option.text)</div><div class="line">                            &#125; else &#123;</div><div class="line">                                optValue = (option.attributes[&quot;value&quot;].specified ? option.value : option.text)</div><div class="line">                            &#125;</div><div class="line">                            parts.push(encodeURIComponent(field.name) + &quot;=&quot; + encodeURIComponent(optValue))</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                break</div><div class="line">            case undefined:</div><div class="line">            case &quot;file&quot;:</div><div class="line">            case &quot;submit&quot;:</div><div class="line">            case &quot;reset&quot;:</div><div class="line">            case &quot;button&quot;:</div><div class="line">                break</div><div class="line">            case &quot;radio&quot;:</div><div class="line">            case &quot;checkbox&quot;:</div><div class="line">                if (!field.checked) &#123;</div><div class="line">                    break</div><div class="line">                &#125;</div><div class="line">            default:</div><div class="line">                if (field.name.length) &#123;</div><div class="line">                    parts.push(encodeURIComponent(field.name) + &quot;=&quot; + encodeURIComponent(field.value))</div><div class="line">                &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return parts.join(&quot;&amp;&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>post请求可以使用XHR来模仿表单提交。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">xhr.open(&quot;post&quot;,&quot;index.html&quot;,true)</div><div class="line">xhr.setRequestHeader(&quot;Content-Type&quot;,&quot;application/x-www-form-urlencoded&quot;)</div><div class="line">/*get form*/</div><div class="line">xhr.send(serialize(form))</div></pre></td></tr></table></figure></p>
<h2 id="2">XHR2级</h2>

<h3 id="2.1">FormData</h3>

<p>FormData用于表单序列化与创建与表单格式相同的数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var data=new FormData()</div><div class="line">data.append(&quot;name&quot;,&quot;cmz&quot;)</div></pre></td></tr></table></figure></p>
<p>也可以直接使用表单中的值进行填充，可以直接传给send方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var form=document.form[0]</div><div class="line">xhr.send(new FormData(form))</div></pre></td></tr></table></figure></p>
<h3 id="2.2">超时设定</h3>

<p>XHR的timeout属性表示在请求等待多少毫秒后会终止，发生timeout事件，调用ontimeout进行处理：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">xhr.timeout=1000</div><div class="line">xhr.ontimeout=function()&#123;</div><div class="line">	...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="2.3">overrideMimeType</h3>

<p>overrideMimeType用于重写MIME类型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">xhr.open(...)</div><div class="line">xhr.overrideMimeType(&quot;text/xml&quot;)</div><div class="line">xhr.send(null)</div></pre></td></tr></table></figure></p>
<p>强迫xhr将响应当做xml来处理而非纯文本，overrideMimeType必须在send之前。</p>
<h2 id="3">进度事件</h2>

<p>loadstart:接受到响应数据的第一个字节触发<br>progress:在接受响应的期间不断触发<br>error:请求错误时触发<br>abort:调用abort方法终止而触发<br>load:在接收到完整的响应后触发<br>loadend:通信完成，error，abort，load发生时触发</p>
<p>onload可用代替readystatechange事件。<br>onprogress事件收到一个target为xhr的event对象，包含三个额外属性：lengthComputable表示进度信息是否可用的布尔值，position表示已接受的字节数，totalSize表示根据Content-Length响应头部确定的预期数值。</p>
<h2 id="4">Comet</h2>

<p>Comet实现的两种方式:长查询和流。侦听readyStateChange可用利用XHR实现HTTP流：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">var received=0</div><div class="line">xhr.onreadyStateChange=function()&#123;</div><div class="line">var result</div><div class="line">if(xhr.readyStateChange==3)&#123;</div><div class="line">result=xhr.responceText.substring(received)</div><div class="line">received+=result.length</div><div class="line">progress(result)</div><div class="line">&#125;else if(xhr.readyStateChange==4)&#123;</div><div class="line">finished(xhr.resopnseText)</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">xhr.send(null)</div><div class="line">return xhr</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://www.codingbalian.online/categories/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>JS错误处理</title>
    <link href="http://www.codingbalian.online/2017/03/07/JavaScript-Error/"/>
    <id>http://www.codingbalian.online/2017/03/07/JavaScript-Error/</id>
    <published>2017-03-07T12:52:10.000Z</published>
    <updated>2017-03-09T06:24:29.064Z</updated>
    
    <content type="html"><![CDATA[<p>　<br><a id="more"></a></p>
<h2 id="1">错误处理</h2>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">   try &#123;</div><div class="line">	...//可能出错的代码</div><div class="line">   &#125;</div><div class="line">   catch (error)&#123;</div><div class="line">	...//错误处理</div><div class="line">   &#125;</div><div class="line">finally&#123;</div><div class="line">	...//一定会执行的代码</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>错误会包含一个message的属性。</p>
<h3 id="1.1">错误类型</h3>

<p>Error，EvalError，RangeError，ReferenceError，SyntaxError，TypeError，URIError<br>Error是基本类型，其他都继承于Error。<br>可以根据不同类型的错误进行不同的处理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">if (error instanceof TypeError) &#123;</div><div class="line">&#125;</div><div class="line">else if (error instanceof SyntaxError) &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>使用try-catch后浏览器任务错误以及被处理了，因此不会在console中报告错误。</p>
<p>使用throw可以随时抛出自定义的错误。<br><code>throw 12345</code></p>
<h3 id="1.2">错误事件</h3>

<p>任何没有通过try-catch处理的错误都会触发window的error事件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">window.error=function(...)&#123;</div><div class="line">	...</div><div class="line">	return false</div></pre></td></tr></table></figure></p>
<p>可以阻止浏览器默认的错误报告行为。</p>
<h3 id="1.3">console</h3>

<p>对于JavaScript控制台，可以调用console对象向控制台写入消息。<br>error():错误消息<br>info():信息消息<br>log():一般消息<br>warn() :警告消息</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://www.codingbalian.online/categories/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>H5脚本</title>
    <link href="http://www.codingbalian.online/2017/03/07/JavaScript-API/"/>
    <id>http://www.codingbalian.online/2017/03/07/JavaScript-API/</id>
    <published>2017-03-07T07:58:39.000Z</published>
    <updated>2017-03-07T10:32:34.250Z</updated>
    
    <content type="html"><![CDATA[<p>　<br><a id="more"></a></p>
<h2 id="1">跨文档消息传递</h2>

<p><code>doc.postMessage(&quot;message&quot;,&quot;origin&quot;)</code>向目标文档发送消息。接收到消息后，window会触发message事件，异步形势触发，传递给onmessage处理程序包含三个信息：data（接收到的消息），origin（发送消息所在的文档），source（window的代理）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if (event.origin==&quot;...&quot;)</div><div class="line">	processMessage(event.data)</div><div class="line">	event.source.postMessage(...)</div></pre></td></tr></table></figure></p>
<h2 id="2">原生拖放</h2>

<h3 id="2.1">拖放事件</h3>

<p>拖动元素时依次触发<br>dragstart<br>drag<br>dragend<br>当元素被拖动到有效的放置目标时触发<br>dragenter<br>dragover<br>dragleave或者drop</p>
<h3 id="2.2">自定义拖放元素</h3>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">EventUtil.addHandler(elem,&quot;dragover&quot;,function (event) &#123;</div><div class="line">    EventUtil.preventDefault(event)</div><div class="line">&#125;)</div><div class="line">EventUtil.addHandler(elem,&quot;dragenter&quot;,function (event) &#123;</div><div class="line">    EventUtil.preventDefault(event)</div><div class="line">&#125;)</div><div class="line">EventUtil.addHandler(elem,&quot;drop&quot;,function (event) &#123;</div><div class="line">    EventUtil.preventDefault(event)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>将禁止放置的目标转换成可以放置的目标</p>
<h3 id="2.3">dataTransfer</h3>

<p>被拖动元素向目标元素传递数据时可以访问dataTransfer对象。dataTransfer有两个方法：setData和getData<br>setData(“type”,”data”)type为text或URl，data为传递内容<br>getData()的参数为type</p>
<p>dataTransfer对象还能确定被拖动的元素和作为放置目标的元素可以接收的操作。<br>dropEffect属性：<br>none：不能放置<br>move：移动到目标位置<br>copy：复制到目标位置<br>link：拖动元素为URL时拖到这里打开<br>在ondragenter事件中设置它。<br>dropEffect必须配合effectAllowed属性，表示允许拖动元素的哪种dropEffect：<br>uninitialized：没有设置<br>none：不能有行为<br>copy：复制<br>link：打开连接<br>move：移动<br>copyLink：copy+link<br>copyMove：copy+move<br>linkMove：link+move<br>all：任意</p>
<p>HTML5还为每个元素设定了一个”draggable”属性，可以设置是否允许被拖动。<br>其他方法：<br>addElement(element)：为拖动操作添加一个只影响数据的元素<br>clearData(format)清除以特定格式保存的数据<br>setDragImage(element,x,y)指定一个对象显示在拖动时的光标下方。<br>types:当前保存的数据类型</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://www.codingbalian.online/categories/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaScript-Canvas</title>
    <link href="http://www.codingbalian.online/2017/03/07/JavaScript-Canvas/"/>
    <id>http://www.codingbalian.online/2017/03/07/JavaScript-Canvas/</id>
    <published>2017-03-07T05:51:37.000Z</published>
    <updated>2017-03-07T07:57:11.851Z</updated>
    
    <content type="html"><![CDATA[<p>　<br><a id="more"></a></p>
<h2 id="1">2D上下文</h2>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var canvas = document.getElementById(&quot;draw&quot;)</div><div class="line">var context = canvas.getContext(&quot;2d&quot;)</div><div class="line">context.strokeStyle = &quot;red&quot;//设置描边颜色</div><div class="line">context.fillStyle = &quot;blue&quot;//设置填充颜色</div></pre></td></tr></table></figure>
<p>使用2D绘图。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">context.strokeRect(10,10,30,30)</div><div class="line">context.fillRect(10,10,30,30)</div></pre></td></tr></table></figure></p>
<p>矩形是2D绘图中唯一一个可以直接画出的图像。接受的参数为x,y,宽，高。<br>lineWidth设置描边线宽，设置lineCap线条为平，圆，方头，lineJoin设置线条交叉方式。<br>clearRect(40,40,10,10)清除一个小矩形。</p>
<p>其他的图形就需要使用绘制路径来绘画。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">context.beginPath()</div><div class="line">context.moveTo(0,0)//绘图游标移动指定位置，不划线</div><div class="line">context.beginPath()</div><div class="line">context.arc(250,250,100,0,2*Math.PI,false)</div><div class="line">context.stroke()//描边</div><div class="line">context.fill()//填充</div></pre></td></tr></table></figure>
<h3 id="1.1">绘制文本</h3>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">context.font=&quot;bold 14px Arial&quot;</div><div class="line">context.textAlign=&quot;center&quot;</div><div class="line">context.textBaseline=&quot;middle&quot;</div><div class="line">context.fillText(&quot;圆形&quot;,250,250)//普通文字</div><div class="line">context.strokeText(&quot;圆形&quot;,250,250,100)//描边的文字</div></pre></td></tr></table></figure>
<p>save()保存上下文，restore()恢复上下文</p>
<h3 id="1.2">绘制图形</h3>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var img=document.images[0]</div><div class="line">context.drawImage(img,10,10,300,300)</div></pre></td></tr></table></figure>
<p>drawImage(img,10,10)绘制图像到10,10<br>drawImage(img,10,10,300,300)绘制图像并改变图像大小<br>drawImage(img,10,10,300,300,500,600,200,200)最后四个参数是目标图像的起点坐标与宽高</p>
<h3 id="1.3">阴影与渐变</h3>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">context.shadowColor=&quot;silver&quot;//阴影颜色</div><div class="line">context.shadowOffsetX=5//阴影X方向的偏移</div><div class="line">context.shadowOffsetY=6//Y方向偏移</div><div class="line">context.shadowBlur=4//模糊像素</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function createLinearGradient(context,x,y,width,height)&#123;</div><div class="line">	return context.createLinearGradient(x,y,x+width,y+height)</div><div class="line">      var gradient=createLinearGradient(context,100,100,300,300)</div><div class="line">      gradient.addColorStop(0,&quot;sliver&quot;)//开始颜色</div><div class="line">      gradient.addColorStop(1,&quot;black&quot;)//结束颜色</div><div class="line">      context.fillStyle=gradient</div></pre></td></tr></table></figure>
<p>createPattern(image,”repeat”)可以设置图像的重复，用于填充<br>getImageData(x,y,width,height)可以获取图像的部分内容，返回的对象有三个属性：width，height，data。data是数组，保存着rgb，alpha。<br>putImageData可以将图像数据放到画布中<br>globalAlpha设置全局透明度<br>globalCompositionOperation设置图像结合。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://www.codingbalian.online/categories/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaScript表单脚本</title>
    <link href="http://www.codingbalian.online/2017/03/06/JavaScript-form/"/>
    <id>http://www.codingbalian.online/2017/03/06/JavaScript-form/</id>
    <published>2017-03-06T08:18:50.000Z</published>
    <updated>2017-03-09T07:51:22.375Z</updated>
    
    <content type="html"><![CDATA[<p>　<br><a id="more"></a></p>
<h2 id="1">表单属性与方法</h2>

<p>HTMLELEMENTFORM的属性与方法：<br>acceptCharset：服务器能处理的字符集<br>action：接受请求的URL<br>elements：表单中所有的控件<br>length：表单中控件的数量<br>method：表单提交的方法，get或者post<br>name：表单名称<br>reset()：重置表单为默认值<br>submit():提交表单<br>target：用于发送请求和接受响应的窗口</p>
<p>document.forms可以取得页面所有的表单</p>
<p>使用submit提交表单时会触发一个submit事件，可以借此对表单进行验证，并决定是否提交。使用preventDefault()可以取消表单的提交。</p>
<p>使用forms.submit()时不会发生submit事件。</p>
<p>重置表单除了form.reset()时会触发reset事件以外与表单提交相同。</p>
<h3 id="1.1">表单字段</h3>

<p>共有的表单字段属性(除了<code>&lt;fieldset&gt;</code>)：<br>disabled：表示当前字段是否被禁用<br>form：指向当前字段所属的表单的指针<br>name：当前字段的名称<br>readOnly：是否只读<br>tabIndex：当前字段的切换序号<br>type：字段类型<br>value：当前字段提交给服务器的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">EventUtil.addHandler(form, &quot;submit&quot;, function (event)//防止重复提交 &#123;</div><div class="line">    event = EventUtil.getEvent(event)</div><div class="line">    var target = EventUtil.getTarget(event)</div><div class="line">    var btn = target.elements[&quot;submit-btn&quot;]</div><div class="line">    btn.disabled = true</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>共有的表单字段方法：<br>focus():浏览器将焦点设置到表单字段(隐藏的字段不可用)<br>blur():字段上的焦点被移走时发生</p>
<p>共有表单字段事件：<br>blur：字段失去焦点时触发<br>change：对于<code>&lt;input&gt;</code>和<code>&lt;textarea&gt;</code>元素，失去焦点和value改变时触发。对于<code>&lt;select&gt;</code>元素选项改变时触发。<br>focus：字段获得焦点时触发</p>
<h3 id="1.2">选择文本</h3>

<p>选择了文本框中的内容时就会触发select事件。在调用select()方法时也会发生select事件。<br>取得选择的文本：<br>textbox.value.substring(textbox.selectionStrat,textbox.selectionEnd)<br>选择部分文本：setSelectionRange（strat，end）</p>
<h3 id="1.3">剪贴板操作</h3>

<p>beforecopy,copy,cut,beforecut,paste,beforepaste事件。</p>
<p>before系列事件可以向剪贴板数据进行操作。<br>访问剪贴板对象event.clipboardData,getData(),setData(),clearDate()。</p>
<h3 id="1.4">表单序列化</h3>

<p>表单序列化为Ajax服务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">function serialize(form) &#123;</div><div class="line">    var parts = [],</div><div class="line">        field = null,</div><div class="line">        i, len, j, optLen, option, optValue;</div><div class="line">    for (i = 0, len = form.elements.length; i &lt; len; i++) &#123;</div><div class="line">        field = form.elements[i]</div><div class="line">        switch (field.type) &#123;</div><div class="line">            case &quot;select-one&quot;:</div><div class="line">            case  &quot;select-multiple&quot;:</div><div class="line">                if (field.name.length) &#123;</div><div class="line">                    for (j = 0, optLen = field.options.length; j &lt; optLen; j++) &#123;</div><div class="line">                        option = field.options[j]</div><div class="line">                        if (option.selected) &#123;</div><div class="line">                            optValue = &quot;&quot;</div><div class="line">                            if (option.hasAttribute) &#123;</div><div class="line">                                optValue = (option.hasAttribute(&quot;value&quot;) ? option.value : option.text)</div><div class="line">                            &#125; else &#123;</div><div class="line">                                optValue = (option.attributes[&quot;value&quot;].specified ? option.value : option.text)</div><div class="line">                            &#125;</div><div class="line">                            parts.push(encodeURIComponent(field.name) + &quot;=&quot; + encodeURIComponent(optValue))</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                break</div><div class="line">            case undefined:</div><div class="line">            case &quot;file&quot;:</div><div class="line">            case &quot;submit&quot;:</div><div class="line">            case &quot;reset&quot;:</div><div class="line">            case &quot;button&quot;:</div><div class="line">                break</div><div class="line">            case &quot;radio&quot;:</div><div class="line">            case &quot;checkbox&quot;:</div><div class="line">                if (!field.checked) &#123;</div><div class="line">                    break</div><div class="line">                &#125;</div><div class="line">            default:</div><div class="line">                if (field.name.length) &#123;</div><div class="line">                    parts.push(encodeURIComponent(field.name) + &quot;=&quot; + encodeURIComponent(field.value))</div><div class="line">                &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return parts.join(&quot;&amp;&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="2">富文本编辑器</h3>

<p>嵌入一个包含<code>&lt;iframe&gt;</code>的元素，并将其designMode设置为on。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">EventUtil.addHandler(window,&quot;load&quot;,function () &#123;</div><div class="line">    frames[&quot;myFrame&quot;].document.designMode=&quot;on&quot;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>或者将元素属性设置为<code>contenteditable=true</code></p>
<p><div id="wysiwyg" style="height: 100px;width: 100px;border:1px solid black"></div></p>
<p><button id="btn1">打开富文本编辑</button></p>
<p><button id="btn2">关闭富文本编辑</button>    </p>
<p><script><br>btn1.onclick = function(){wysiwyg.contentEditable = true;}<br>btn2.onclick = function(){wysiwyg.contentEditable = false;}<br></script><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;div id=&quot;div&quot; style=&quot;height: 100px;width: 100px;border:1px solid black&quot;&gt;&lt;/div&gt;</div><div class="line">&lt;button id=&quot;btn1&quot;&gt;打开富文本编辑&lt;/button&gt;</div><div class="line">&lt;button id=&quot;btn2&quot;&gt;关闭富文本编辑&lt;/button&gt;    </div><div class="line">&lt;script&gt;</div><div class="line">btn1.onclick = function()&#123;div.contentEditable = true;&#125;</div><div class="line">btn2.onclick = function()&#123;div.contentEditable = false;&#125;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure></p>
<p>使用element.document.execCommand()进行富文本的操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">居中        　　document.execCommand(&apos;justifyCenter&apos;);</div><div class="line">左对齐     　　 document.execCommand(&apos;justifyLeft&apos;);</div><div class="line">右对齐         document.execCommand(&apos;justifyRight&apos;);</div><div class="line">添加缩进    　　document.execCommand(&apos;indent&apos;);</div><div class="line">去掉缩进    　　document.execCommand(&apos;outdent&apos;);</div><div class="line">字体类型    　　document.execCommand(&apos;fontname&apos;,false,sFontName)</div><div class="line">字体大小    　　document.execCommand(&apos;fontsize&apos;,false,sFontSize)</div><div class="line">字体颜色    　　document.execCommand(&apos;forecolor&apos;,false,sFontColor)</div><div class="line">背景色         document.execCommand(&apos;backColor&apos;,false,sBackColor)</div><div class="line">加粗        　 document.execCommand(&apos;bold&apos;);</div><div class="line">斜体        　 document.execCommand(&apos;italic&apos;);</div><div class="line">下划线         document.execCommand(&apos;underline&apos;);</div><div class="line">复制        　　document.execCommand(&apos;copy&apos;);</div><div class="line">剪切        　　document.execCommand(&apos;cut&apos;);</div><div class="line">粘贴        　　document.execCommand(&apos;paste&apos;);(经测试无效)</div><div class="line">全选        　　document.execCommand(&apos;selectAll&apos;);    </div><div class="line">删除        　　document.execCommand(&apos;delete&apos;);</div><div class="line">后删除         document.execCommand(&apos;forwarddelete&apos;);</div><div class="line">清空格式    　　document.execCommand(&apos;removeFormat&apos;);</div><div class="line">前进一步    　　document.execCommand(&apos;redo&apos;);</div><div class="line">后退一步    　　document.execCommand(&apos;undo&apos;);</div><div class="line">打印       　　 document.execCommand(&apos;print&apos;);(对firefox无效)</div><div class="line">插入标签    　　 document.execCommand(&apos;formatblock&apos;,false,elementName);</div><div class="line">插入&lt;hr&gt;    　　document.execCommand(&apos;inserthorizontalrule&apos;);</div><div class="line">插入&lt;ol&gt;    　　document.execCommand(&apos;insertorderedlist&apos;);</div><div class="line">插入&lt;ul&gt;    　　document.execCommand(&apos;insertunorderedlist&apos;);</div><div class="line">插入&lt;p&gt;        document.execCommand(&apos;insertparagraph&apos;);</div><div class="line">插入图像   　　 document.execCommand(&apos;insertimage&apos;,false,URL);</div><div class="line">增加链接   　　 document.execCommand(&apos;createlink&apos;,false,URL);</div><div class="line">删除链接   　　 document.execCommand(&apos;unlink&apos;);</div><div class="line">anchorNode：选区起点所在的节点</div><div class="line">anchorOffset：在到达选区起点位置之前跳过的anchorNode中的字符数量</div><div class="line">focusNode：选区终点所在的节点</div><div class="line">focusOffset：focusNode中包含在选区之内的字符数量</div><div class="line">isCollapsed：布尔值，表示选区的起点和终点是否重合</div><div class="line">rangeCount：选区中包含的DOM范围的数量</div><div class="line">addRange(range)：将指定的DOM范围添加到选区中</div><div class="line">collapse(node,offset)：将选区折叠到指定节点中的相应的文本偏移位置</div><div class="line">collapseToEnd()：将选区折叠到终点位置</div><div class="line">collapseToStart()：将选区折叠到起点位置</div><div class="line">containsNode(node)：确定指定的节点是否包含在选区中</div><div class="line">deleteFromDocument()：从文档中删除选区中的文本，与document.execCommand(&quot;delete&quot;,false,null)命令的结果相同</div><div class="line">extend(node,offset)：通过将focusNode和focusOffset移动到指定的值来扩展选区</div><div class="line">getRangeAt(index)：返回索引对应的选区中的DOM范围</div><div class="line">removeAllRanges()：从选区中移除所有DOM范围。实际上，这样会移除选区，因为选区中至少要有一个范围</div><div class="line">reomveRange(range)：从选区中移除指定的DOM范围</div><div class="line">selectAllChildren(node)：清除选区并选择指定节点的所有子节点</div><div class="line">toString()：返回选区所包含的文本内容</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://www.codingbalian.online/categories/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaScript-event</title>
    <link href="http://www.codingbalian.online/2017/03/02/JavaScript-event/"/>
    <id>http://www.codingbalian.online/2017/03/02/JavaScript-event/</id>
    <published>2017-03-02T13:03:34.000Z</published>
    <updated>2017-03-05T13:30:44.214Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript中的事件处理。<br><a id="more"></a></p>
<h2 id="1">事件处理</h2>

<h3 id="1.1">HTM事件处理</h3>

<p><code>&lt;input type=&quot;button&quot; value=&quot;clickme&quot; onclick=&quot;alert(&amp;quot;type&amp;quot;)&quot;/&gt;</code><br>在处理时间中使用HTML字符都必须经过转义。<br>同时包含一个event对象，表示事件本身，可以访问事件对象。<br>this表示目标元素，但是不仅可以访问本元素，也可以访问document。</p>
<h3 id="1.2">DOM0事件处理</h3>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var mybutton=document.getElementById(&quot;mybutton&quot;)</div><div class="line">mybutton.onclick=function () &#123;</div><div class="line">    alert(this.id)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="1.3">DOM2事件处理</h3>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var mybutton=document.getElementById(&quot;mybutton&quot;)</div><div class="line">mybutton.addEventListener(&quot;click&quot;,function () &#123;</div><div class="line">    alert(this.id)</div><div class="line">&#125;,false)</div><div class="line">mybutton.addEventListener(&quot;click&quot;,function () &#123;</div><div class="line">    alert(this.value)</div><div class="line">&#125;,false)</div></pre></td></tr></table></figure>
<p>DOM2可以为同一个添加多个事件处理。用<code>removeEventListener()</code>移除监听，添加的参数与addEventListener中的参数必须相同，但是匿名函数无法被移除。<br>函数的第三个参数为布尔值，false表示在冒泡阶段捕获，true在捕捉阶段捕获。冒泡可以最大程度的兼容各种浏览器，捕捉用在事件事件到达目标前截获它。</p>
<h3 id="1.4">IE事件处理</h3>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mybutton.attachEvent(&quot;onclick&quot;,function () &#123;</div><div class="line">    alert(this==window)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>attachEvent()添加事件处理，第一个参数与DOM2中的不同，与DOM0方法的不同在与作用域为全局，因此this=window，同时也可添加多个事件处理。<br>使用<code>detachEvent()</code>移除处理程序。</p>
<h3 id="1.5">跨浏览器的事件处理</h3>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line">var EventUtil = &#123;</div><div class="line">    addHandler: function (element, type, handler) &#123;</div><div class="line">        if (element.addEventListener) &#123;</div><div class="line">            element.addEventListener(type, handler, false)</div><div class="line">        &#125; else if (element.attachEvent) &#123;</div><div class="line">            element.attachEvent(&quot;on&quot; + type, handler)</div><div class="line">        &#125; else &#123;</div><div class="line">            element[&quot;on&quot; + type] = handler</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    removeHandler: function (element, type, handler) &#123;</div><div class="line">        if (element.removeEventListener) &#123;</div><div class="line">            element.removeEventListener(type, handler, false)</div><div class="line">        &#125; else if (element.detachEvent) &#123;</div><div class="line">            element.detachEvent(&quot;on&quot; + type, handler)</div><div class="line">        &#125; else &#123;</div><div class="line">            element[&quot;on&quot; + type] = null</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    getEvent: function (event) &#123;//获取事件</div><div class="line">        return event ? event : window.event;</div><div class="line">    &#125;,</div><div class="line">    getTarget: function (event) &#123;//获取事件目标</div><div class="line">        return event.target || event.srcElement</div><div class="line">    &#125;,</div><div class="line">    preventDefault: function (event) &#123;//取消事件默认行为</div><div class="line">        if (event.preventDefault) &#123;</div><div class="line">            event.preventDefault()</div><div class="line">        &#125; else &#123;</div><div class="line">            event.returnValue = false</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    stopPropagation: function (event) &#123;//取消事件的进一步捕捉或冒泡</div><div class="line">        if (event.stopPropagation) &#123;</div><div class="line">            event.stopPropagation()</div><div class="line">        &#125; else &#123;</div><div class="line">            event.cancelBubble = true</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    getRelatedTarget: function (event) &#123;//获取相关元素</div><div class="line">        if (event.relatedTarget) &#123;</div><div class="line">            return event.relatedTarget</div><div class="line">        &#125; else if (event.toElement) &#123;</div><div class="line">            return event.toElement</div><div class="line">        &#125; else if (event.fromElement) &#123;</div><div class="line">            return event.fromElement</div><div class="line">        &#125; else &#123;</div><div class="line">            return null</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    getButton: function (event) &#123;</div><div class="line">        if (document.implementation.hasFeature(&quot;MouseEvents&quot;, &quot;2.0&quot;)) &#123;</div><div class="line">            return event.button</div><div class="line">        &#125; else &#123;</div><div class="line">            switch (event.button) &#123;</div><div class="line">                case 0:</div><div class="line">                case 1:</div><div class="line">                case 3:</div><div class="line">                case 5:</div><div class="line">                case 7:</div><div class="line">                    return 0;</div><div class="line">                case 2:</div><div class="line">                case 6:</div><div class="line">                    return 2;</div><div class="line">                case 4:</div><div class="line">                    return 1;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    getWheelDelta: function (event) &#123;</div><div class="line">        if (event.wheelDelta) &#123;</div><div class="line">            return (client.engine.opera &amp;&amp; client.engine.opera &lt; 9.5 ? -event.wheelDelta : event.wheelDelta)</div><div class="line">        &#125; else return</div><div class="line">        -event.detail * 40</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="2">事件类型</h2>

<h3 id="2.1">UI事件</h3>

<p>onload:页面加载完后在Window上触发，图像加载完后在<code>&lt;img&gt;</code>上触发或者嵌入内容加载完后在<code>&lt;object&gt;</code>上触发。<br>unload:卸载后触发，同上。<br>abort:用户停止下载后嵌入元素还没加载完成在<code>&lt;object&gt;</code>上触发<br>resize:窗口大小改变后触发。<br>scroll：滚动在含此滚动条元素中触发。</p>
&lt;h3 id=’2.2&gt;焦点事件

<p>blur:失去焦点时触发，不冒泡<br>focus：获得焦点触发，不冒泡<br>focusin:获得焦点触发，冒泡<br>focusout：失去焦点触发，冒泡</p>
<h3 id="2.3">鼠标事件</h3>


<p>click:单击或者按下回车<br>dbclick：双击<br>mousedown:按下任意鼠标按键<br>mouseenter：鼠标首次从元素外部移入元素范围内，不冒泡<br>mouseleave：鼠标从元素范围内离开，不冒泡，不会在元素的子元素上触发<br>mousemove：鼠标在元素范围内移动时触发<br>mouseout：鼠标位于一个元素上方移入另一个元素是触发<br>mouseover：鼠标从其他元素首次移到目标元素上时触发<br>mouseup:鼠标按键被释放时触发</p>
<p>修改键可以改变鼠标的操作，因此定义了四个布尔值属性用来判断这些键是否被按下：shiftKey,altKey，ctrlKey，metaKey。</p>
<p>发生mouseover与mouseout事件时，设计多个元素，比如发生mouseover时获得光标的元素是主目标，而失去光标的就是相关元素。<br>relatedTarget属性只包含关于这两个事件的元素，IE中，mouseover发生时fromElement保存相关元素，mouseout发生时toElement保存相关元素。</p>
<p>对于mousedown和mouseup，event还保存了一个button属性，0表示鼠标主键，1表示鼠标中键，2表示鼠标次键。</p>
<p>event.detail记录了一个元素上发生过多少次单击，若光标移到其他元素后，detail重置为0。</p>
<p>mousewheel事件：event包含一个wheelDelta属性，是120的倍数，向上滚动为正，向下为负。</p>
<h3 id="2.4">键盘文本事件</h3>

<p>keydown:键盘任意键按下，按住不放重复触发<br>keyup：键盘释放<br>keypress：按下键盘的字符键，按住不放重复触发</p>
<p>keydown和keyup时event对象的keyCode会包含一个键码，当是字符按键时keyCode包含的是对应的ASCII码。</p>
<p>charCode包含keypress时按下的键的ASCII码。</p>
<p>getModifierState()方法接收shift、control、AltGraph和Meta键，若被按下返回true。</p>
<p>textInput事件：用户在可编辑区域输入字符时，代替keypress事件。在按下实际能够改变输入内容的按键时才会触发，例如退格键被按下并不会被触发，而在keypress中能够触发。<br>它的event对象还保存这inputMethod属性，表示内容被输入的方式：<br>0：不确定<br>1：键盘<br>2：粘贴<br>3：拖放<br>4：IME<br>5：表单中选择某一项而输入<br>6：手写<br>7：语音<br>8：组合输入<br>9：脚本输入</p>
<h3 id="2.5">变动事件</h3>

<p>DOM中结构变化而触发。</p>
<p>DOMSubtreeModified：DOM结构中发生任何变化时都会触发，该事件在其他任何事件触发后都会触发<br>DOMNodeInserted：一个节点作为子节点插入另一个节点时触发<br>DOMNodeRemoved：节点从其父节点移除后触发<br>DOMNodeInsertedIntoDocument：节点插入文档，或通过通过子间树插入后触发，在DOMNodeInserted后发生<br>DOMNodeRemovedFromDocument：节点从文档移除或通过子间树移除，在DOMNodeRemoved后触发<br>DOMAttrmodified：特性被修改后触发<br>DOMCharacterDataModified：当文本节点的值发生变化时触发</p>
<h3 id="2.6">HTML5事件</h3>

<p>contextmenu事件可以自定义右键出现的上下文菜单，使用preventDefault()取消默认的右键菜单，且该事件是冒泡的，所有可以在document上指定一个处理程序来处理它。</p>
<p>beforeunload事件：在卸载之前触发。</p>
<p>haschange事件：当页面的URL发生变化时便会调用此事件。包含oldURL和newURL两个属性。location.hash也可返回现在的URL。</p>
<h2 id="3">设备事件</h2>

<p>IOS设备中的支持：<br>orientationchange事件：确定浏览模式何时为横向何时为纵向。<br>window.orientation包含3个值：0为肖像模式，90为向左旋转，-90为向右旋转。只要设备改变了查看模式，就会触发orientationchange事件。</p>
<h3 id="3.1">触摸</h3>

<p>touchstart:手指触摸，即使手指已经放上去也触发<br>touchmove:手指连续滑动，用preventDefault可以阻止<br>touchend:手指从屏幕上移开<br>touchcancel:系统停止跟踪触摸时触发<br>以上的事件都冒泡</p>
<p>用于跟踪触摸的属性：<br>touches:跟踪触摸操作的Touch对象数组<br>targetTouchs：特定于目标事件的Touch对象数组<br>changeTouches：上次触摸以来发生改变的Touch对象数组<br>每个Touch对象包含属性：<br>clientX：触摸目标在视窗中的X坐标<br>clientY：视窗中Y的坐标<br>identifier：识别触摸的唯一ID<br>pageX：触摸目标在页面中的X坐标<br>pageY：在页面中Y坐标<br>screenX：在屏幕中的X坐标<br>screenY：在屏幕中的Y坐标<br>target：触摸的DOM节点目标</p>
<h2 id="4">内存和性能</h2>

<p></p><h3 id-'4.1'="">事件委托<p></p>
<p>事件处理程序过多时可以利用冒泡，只指定一个事件处理程序对某一类型的所有事件进行管理。</p>
<p>当页面被卸载时，没有处理干净事件处理程序，则会滞留在内存中，可以使用onunload来鞋移除事件处理</p>
</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JavaScript中的事件处理。&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://www.codingbalian.online/categories/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaScrpit-DOM2</title>
    <link href="http://www.codingbalian.online/2017/03/02/JavaScrpit-DOM2/"/>
    <id>http://www.codingbalian.online/2017/03/02/JavaScrpit-DOM2/</id>
    <published>2017-03-02T06:18:52.000Z</published>
    <updated>2017-03-02T12:57:37.440Z</updated>
    
    <content type="html"><![CDATA[<p>DOM2与DOM3中新增的内容。<br><a id="more"></a></p>
<h2 id="1">样式</h2>

<p><code>element.style.cssText</code>获取style特性的代码<br><code>element.style.length</code>获取style特性中CSS属性的数量<br><code>element.style.parentRule</code>返回CSSRule对象<br><code>element.style.getPropertyValue</code>返回给定属性的字符值<br><code>element.style.removeProperty</code>移除给定属性<br><code>element.style.setProperty</code>加上给定属性，给定值，优先标准<br><code>element.style.item</code>返回给定位置的CSS属性名<br><code>element.style.getPropertyCSSValue</code>返回给定属性的CSSValue对象<br><code>element.style.getPropertyPriority</code>若给定属性使用了!important设置返回important，否则返回null</p>
<p><code>document.defaultView.getComputedStyle</code>取得元素计算后样式，第一个参数是元素，第二个是伪元素字符串，若无则填null</p>
<h3 id="1.1">操作样式表</h3>

<p><code>alert(document.implementation.hasFeature(&quot;StyleSheets&quot;,&quot;2.0&quot;))</code>判断浏览器是否支持DOM2的样式表操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&lt;style type=&quot;text/css&quot;&gt;</div><div class="line">    #mydiv &#123;</div><div class="line">        width: auto;</div><div class="line">        height: 20px;</div><div class="line">        font-style: italic</div><div class="line">    &#125;</div><div class="line">&lt;/style&gt;</div><div class="line"></div><div class="line">var sheet=document.styleSheets[0]//取得样式表列表</div><div class="line">var rules=sheet.cssRules||sheet.rules//取得规则列表</div><div class="line">var rule=rules[0]//第一个规则</div><div class="line">alert(rule.style.cssText)//设置的css规则包含的文本</div><div class="line">alert(rule.cssText)//设置的完整的css规则文本（包括选择器）</div><div class="line">alert(rule.selectorText)//选择器</div><div class="line">sheet.insertRule(&quot;#mydiv&#123;background-color:red;&#125;&quot;,0)//添加规则</div></pre></td></tr></table></figure>
<h3 id="1.2">遍历</h3>

<p><code>document.createNodeIterator()</code>创造一个迭代器。第一个参数表示搜索的起点，第二个表示显示哪些节点，第三个参数是一个NodeFilter对象，表示拒绝或接受特定节点，第四个布尔值表示是否扩展实体引用HTML中为false。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var filter=function (node) &#123;</div><div class="line">    return node.tagName.toLowerCase()==&quot;p&quot;?</div><div class="line">           NodeFilter.FILTER_ACCEPT:</div><div class="line">           NodeFilter.FILTER_SKIP;</div><div class="line">&#125;</div><div class="line">var iterator=document.createNodeIterator(body,NodeFilter.SHOW_ELEMENT,filter,false)</div><div class="line">var node=iterator.nextNode()</div><div class="line">while (node!==null)&#123;</div><div class="line">    alert(node.tagName)</div><div class="line">    node=iterator.nextNode()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>定义了一个显示<code>&lt;p&gt;</code>元素的迭代器，若不指定过滤元素则第三个参数为null。</p>
<p><code>createTreeWalker()</code>是NodeIterator的更高级版本，除了<code>nextNode()</code>和<code>previousNode()</code>之外还包括以下方法：<br><code>parentNode()</code>;<code>firstChild()</code>;<code>lastChild()</code>;<code>nextSibing()</code>;<code>previousSibing()</code>方法，创建方法与<code>createNodeIterator()</code>相同。<br><code>currentNode</code>便是现在正在访问的节点。</p>
<h2 id="2">范围</h2>

<p>createRange()方法可以用来创建DOM范围。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var range1=document.createRange()</div><div class="line">	 range2=document.createRange()</div><div class="line"> p1=docuemnt.getElementsByTagName(&quot;p&quot;)[0]</div><div class="line">range1.selectNode(p1)//p1节点标签从开始到结束</div><div class="line">range2.selectNodeContents(p1)//p1节点包含的内容或子节点开始到结束</div><div class="line">range2.cloneContents()//复制range2中的所有内容。</div><div class="line">range2.deleteContents()//删除p1节点包含的子元素。</div><div class="line">var frangment=range1.extraContents()//删除range1包含的内容并返回</div></pre></td></tr></table></figure></p>
<p>insertNode(node)在range范围内的setStart位置后插入node<br>surroundContents(node)将从range包含的内容包含在插入的node中，之后将插入内容的node放在内容原来的位置上。<br>collapse(),true表示折叠到起点，false折叠到终点。<br>cloneRange()复制范围<br>清理范围：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">range.detach()</div><div class="line">range=null</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;DOM2与DOM3中新增的内容。&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://www.codingbalian.online/categories/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaScript的文档对象模型</title>
    <link href="http://www.codingbalian.online/2017/02/28/JavaScript-DOM/"/>
    <id>http://www.codingbalian.online/2017/02/28/JavaScript-DOM/</id>
    <published>2017-02-28T11:53:40.000Z</published>
    <updated>2017-03-05T06:35:52.147Z</updated>
    
    <content type="html"><![CDATA[<p>DOM1方法<br><a id="more"></a></p>
<h2 id="1">节点</h2>

<p>每个HTML文档的文档节点是根节点，<code>&lt;html&gt;</code>是文档元素，也是文档最外层的元素。</p>
<h3 id="1.1">Node类型</h3>


<table>
<thead>
<tr>
<th>NodeType</th>
<th>Named Constant</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>ELEMENT_NODE</td>
</tr>
<tr>
<td>2</td>
<td>ATTRIBUTE_NODE</td>
</tr>
<tr>
<td>3</td>
<td>TEXT_NODE</td>
</tr>
<tr>
<td>4</td>
<td>CDATA_SECTION_NODE</td>
</tr>
<tr>
<td>5</td>
<td>ENTITY_REFERENCE_NODE</td>
</tr>
<tr>
<td>6</td>
<td>ENTITY_NODE</td>
</tr>
<tr>
<td>7</td>
<td>PROCESSING_INSTRUCTION_NODE</td>
</tr>
<tr>
<td>8</td>
<td>COMMENT_NODE</td>
</tr>
<tr>
<td>9</td>
<td>DOCUMENT_NODE</td>
</tr>
<tr>
<td>10</td>
<td>DOCUMENT_TYPE_NODE</td>
</tr>
<tr>
<td>11</td>
<td>DOCUMENT_FRAGMENT_NODE</td>
</tr>
<tr>
<td>12</td>
<td>NOTATION_NODE</td>
</tr>
</tbody>
</table>
<p>每个节点都有childNodes属性，保存着NodeList对象，但并不是Array的实例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function convertToArray(nodes) &#123;//将NodeList转化为数组</div><div class="line">    var array = null</div><div class="line">    try &#123;</div><div class="line">        array = Array.prototype.slice.call(nodes, 0)</div><div class="line">    &#125; catch (ex) &#123;</div><div class="line">        array = new Array()</div><div class="line">        for (var i = 0, len = nodes.length; i &lt; len; i++) &#123;</div><div class="line">            array[i].push(nodes[i])</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>DOM树中的操作可以看成是指针操作，使用<code>appendChild()</code>方法将已存在的DOM中的节点添加到指定节点的最后则会改变节点所在的位置，即原本的位置已经不存在这个节点了。</p>
<p><code>cloneNode()</code>接受的参数为布尔值，true时复制其整个节点及子节点，false只复制节点本身。</p>
<h2 id="2">Document类型</h2>

<p>nodeType=0，nodeName=#document<br>Document类型表示整个页面。<br><code>document.Element</code>取得对<code>&lt;html&gt;</code>的引用，<code>document.body</code>取得对<code>&lt;body&gt;</code>的引用，<code>document.doctype</code>取得对<code>&lt;!DOCTYPE&gt;</code>的引用。<br><code>document.URL</code>:完整的url<br><code>document.domain</code>取得域名，可设置。<br><code>document.referrer</code>取得来源页面的URL<br><code>document.links</code>获取带href的<code>&lt;a&gt;</code><br><code>document.anchors</code>获取带name的<code>&lt;a&gt;</code><br><code>document.img</code>取得所有<code>&lt;img&gt;</code><br><code>document.form</code>取得所有<code>&lt;form&gt;</code></p>
<p><code>document.implementation</code>用于浏览器对DOM的检测。<br>DOM1只有<code>hasFeature()</code>方法。<br>在使用<code>write()</code>和<code>writeln()</code>方法加载script时需要注意将内容的结束符设为<code>&lt;\/script&gt;</code>否则将会被认为与外部的<code>&lt;scrpit&gt;</code>标签匹配。</p>
<h2 id="3">Element类型</h2>

<p>html元素属性：<br>html.id    html.title    html.lang    html.dir    html.className</p>
<p>元素属性方法：<code>getAttribute()</code>,<code>setAttribute()</code>,<code>removeAttribute()</code></p>
<p>attributes属性方法：<br><code>element.attributse.getNamedItem(name)</code>返回name属性的节点<br><code>element.attributse.removeNamedItem(name)</code><br><code>element.attributse.setNamedItem(node)</code></p>
<h2 id="4">Text类型</h2>

<p><code>appendData(&quot;text&quot;)</code>将text加到Text节点的末尾。<br><code>deleteData(offset,count)</code>删除从offset开始的count个字符。<br><code>replaceData(offset,count,text)</code>用text替换从offset开始的count个字符。<br><code>insertData(offset,text)</code><br><code>splitText(offset,count,Text)</code>将指定位置的当前文档分成两部分<br><code>substring(offset,count)</code>取字符<br><code>crateTextNode()</code>创建text节点。</p>
<h2 id="5">选择符API</h2>

<p><code>querySelector()</code>可以接收CSS选择符，返回第一个匹配的元素<br><code>querySelector(&#39;img.button&#39;)</code>选择类为botton的<code>&lt;img&gt;</code></p>
<p><code>querySelectorAll()</code>同上，但是返回所有符合的元素<br><code>querySelectorAll(&quot;p strong&quot;)</code>返回<code>&lt;p&gt;</code>中所有的<code>&lt;strong&gt;</code>元素</p>
<p><code>matchesSelector()</code>返回元素与匹配符是否匹配的布尔值。</p>
<h2 id="6">HTML5的扩展</h2>

<p>对元素的class属性操作：<br><code>element.classList.add()</code>增加class属性<br><code>element.classList.contains()</code>判断是否存在指定的class值<br><code>element.classList.remove()</code>删除class的指定值<br><code>element.classList.toggle()</code>若存在指定的class值则删除，若不存在则增加。</p>
<p><code>document.readyState</code>loading表示文档正在加载，若为complete则加载完成。</p>
<p><code>document.compatMode</code>CSS1Compat表示标准渲染模式，BackCompat表示混杂模式。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;DOM1方法&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://www.codingbalian.online/categories/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>BOM</title>
    <link href="http://www.codingbalian.online/2017/02/28/JavaScript-BOM/"/>
    <id>http://www.codingbalian.online/2017/02/28/JavaScript-BOM/</id>
    <published>2017-02-28T06:54:05.000Z</published>
    <updated>2017-02-28T09:25:10.598Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript中的浏览器对象模型<br><a id="more"></a></p>
<h2 id="1">window对象</h2>

<p>window对象是BOM的核心，代表浏览器的实例，在全局作用域的对象与方法都会变成window的属性和方法。<br>全局变量不能通过delete来删除。而在window上定义的对象可以。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var a =29</div><div class="line">window.b=28</div><div class="line">delete window.a</div><div class="line">delete window.b</div><div class="line">alert(window.a)//29</div><div class="line">alert(window.b)//undefined</div></pre></td></tr></table></figure></p>
<p>访问未声明变量会抛出错误但访问window的未声明变量则是一次查询，不会出错。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var a=b//Uncaught ReferenceError: b is not defined</div><div class="line">var a=window.b//查询，不会出错</div></pre></td></tr></table></figure></p>
<h3 id="1.1">frame</h3>

<p>如果页面中包含框架，则每个框架都有自己的window对象，保存在frames集合中。每个window对象都有name属性包含框架的名称。<br>top始终指向最外层框架即浏览器窗口，可以使用<code>top.frames[index|&quot;framename&quot;]</code>引用指定框架。<br>parent对象指的是当前框架的上层框架，在没有框架的情况下等于top。<br>self等同与window。<br><code>window.moveTo</code>将浏览器窗口移动到指定位置，<code>window.moveBy</code>是对浏览器窗口的相对移动操作。<br><code>window.resizeTo</code>直接调整大小，<code>window.resizeBy</code>接受与原窗口的宽高差后再相对调整。</p>
<p>获取页面视口的大小：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"> function GetClientSize() &#123;</div><div class="line">    var pageWidth = window.innerWidth</div><div class="line">    var pageHeight = window.innerHeight</div><div class="line">    if (typeof pageHeight != &quot;number&quot;) &#123;</div><div class="line">        if (document.compatMode == &quot;CSS1Compat&quot;) &#123;</div><div class="line">            pageWidth = document.documentElement.clientWidth</div><div class="line">            pageHeight = document.documentElement.clientHeight</div><div class="line">        &#125; else &#123;</div><div class="line">            pageWidth = document.body.clientWidth</div><div class="line">            pageHeight = document.body.clientHeight</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    alert(&quot;Height:&quot; + pageHeight + &quot; Width:&quot; + pageWidth)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>弹窗屏蔽检测：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var blocked = false</div><div class="line">try &#123;</div><div class="line">    var newWindow = window.open(&quot;http://www.baidu.com&quot;, &quot;_blank&quot;)</div><div class="line">    if (newWindow == null)</div><div class="line">        blocked = true</div><div class="line">&#125; catch (ex) &#123;</div><div class="line">    blocked = true</div><div class="line">&#125;</div><div class="line">if (blocked) &#123;</div><div class="line">    alert(&quot;The popup was blocked!&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="2">location对象</h2>

<p>location对象提供了当前加载的文档的相关信息。</p>
<table>
<thead>
<tr>
<th>属性名</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>hash</td>
<td>返回URL中#及后面的字符，若无则为空字符</td>
</tr>
<tr>
<td>host</td>
<td>返回服务器名称与端口号</td>
</tr>
<tr>
<td>hostname</td>
<td>返回服务器名称</td>
</tr>
<tr>
<td>href</td>
<td>完整的URL</td>
</tr>
<tr>
<td>pathname</td>
<td>URL的目录和文件名</td>
</tr>
<tr>
<td>port</td>
<td>端口号</td>
</tr>
<tr>
<td>portocal</td>
<td>使用协议</td>
</tr>
<tr>
<td>search</td>
<td>?及之后的字符</td>
</tr>
</tbody>
</table>
<p><code>localtion.assign(&quot;...&quot;)</code>改变浏览器位置<br><code>localtion.replace(&quot;...&quot;)</code>导航到新页面且不在历史记录中生成记录，即无法倒退<br><code>localtion.reload()</code>重新加载本页面，使用true参数直接从服务器重新加载</p>
<h2 id="3">navigator对象</h2>

<p>navigator对象用于识别客户端浏览器。</p>
<p>扩展插件检测（不适用于IE）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function hasPlugin(name) &#123;</div><div class="line">    name = name.toLowerCase()</div><div class="line">    for (var i = 0; i &lt; navigator.plugins.length; i++) &#123;</div><div class="line">        if (navigator.plugins[i].name.toLowerCase().indexOf(name) &gt; -1) &#123;</div><div class="line">            return true</div><div class="line">        &#125; else &#123;</div><div class="line">            return false</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="4">screen对象</h2>

<p>screen对象用于表示客户端能力。<br>使浏览器占据屏幕空间：<br><code>window.resizeTo(screen.availWidth,screen.availHeight)</code></p>
<h2 id="5">history对象</h2>

<p>history对象保存着浏览器的浏览记录。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">history.go(-1)//后退一页</div><div class="line">history.go(1)//前进一页</div><div class="line">history.go(2)//前进两页</div><div class="line">history.g0(baidu.com)//跳转到最近的baidu.com页面</div><div class="line">history.back()//后退</div><div class="line">history.forward()//前进</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JavaScript中的浏览器对象模型&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://www.codingbalian.online/categories/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaScript函数</title>
    <link href="http://www.codingbalian.online/2017/02/28/JavaScript-Function/"/>
    <id>http://www.codingbalian.online/2017/02/28/JavaScript-Function/</id>
    <published>2017-02-28T05:54:04.000Z</published>
    <updated>2017-02-28T06:49:01.381Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript函数的闭包与变量。<br><a id="more"></a></p>
<h2 id="1">递归</h2>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function factorial(num) &#123;//阶乘函数的递归</div><div class="line">       if (num &lt;= 1) &#123;</div><div class="line">           return 1</div><div class="line">       &#125;</div><div class="line">       else &#123;</div><div class="line">           return num * factorial(num - 1)</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">var func = factorial</div><div class="line">factorial =null	</div><div class="line">alert(func(4))//error</div></pre></td></tr></table></figure>
<p>在调用func时需要执行factorial函数，func指向factorial函数但由于factorial函数以及为空，因此无法执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function factorial(num) &#123;//阶乘函数的递归</div><div class="line">       if (num &lt;= 1) &#123;</div><div class="line">           return 1</div><div class="line">       &#125;</div><div class="line">       else &#123;</div><div class="line">           return num * arguments.callee(num - 1)</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">var func = factorial</div><div class="line">factorial =null	</div><div class="line">alert(func(4))//24</div></pre></td></tr></table></figure>
<p>arguments.callee指向正在执行的函数，因此不会出错，但是在严格模式下不能访问。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var factorial = (function f (num) &#123;//阶乘函数的递归</div><div class="line">       if (num &lt;= 1) &#123;</div><div class="line">           return 1</div><div class="line">       &#125;</div><div class="line">       else &#123;</div><div class="line">           return num * f(num - 1)</div><div class="line">       &#125;</div><div class="line">   &#125;)</div></pre></td></tr></table></figure></p>
<p>严格模式下即使factorial为空但是f依旧存在。</p>
<h2 id="2">闭包</h2>

<p>闭包是指有权限访问另一个函数作用域的变量的函数。<br>函数执行完毕后局部活动对象会被销毁只保留全局的变量对象，但是闭包不同。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function funa(...)&#123;</div><div class="line">	...</div><div class="line">	return function()&#123;//闭包，匿名函数</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在调用funa时，匿名函数会包含funa的活动对象和全局变量，而funa在执行完之后其环境的作用域链被销毁但是活动对象仍然存在，因匿名函数仍在调用它，直到匿名函数被销毁。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var a=funa()//创建函数</div><div class="line">...//执行</div><div class="line">a=null//解除对匿名函数的引用释放内存</div></pre></td></tr></table></figure></p>
<p>同时闭包只能取得包含函数中的任何变量的最后一个值。</p>
<h3 id="2.1">闭包的this对象</h3>

<p>this在全局环境中指向window，在函数被作为对象的方法调用时指向那个对象，匿名函数具有全局性，因此指向window。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var name = &apos;world&apos;</div><div class="line">var createFunction = &#123;</div><div class="line">    name: &quot;total&quot;,</div><div class="line">    getName: function () &#123;//返回函数</div><div class="line">        return function () &#123;</div><div class="line">            return this.name</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">alert(createFunction.getName()())//调用被返回的函数，world</div></pre></td></tr></table></figure></p>
<p>this指向window。<br>使this指向对象本身。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var name = &apos;world&apos;</div><div class="line">var createFunction = &#123;</div><div class="line">    name: &quot;total&quot;,</div><div class="line">    getName: function () &#123;</div><div class="line">        return function () &#123;</div><div class="line">var that = this </div><div class="line">            return that.name</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">alert(createFunction.getName()())//total</div></pre></td></tr></table></figure></p>
<h3 id="2.2">内存泄漏</h3>

<p>闭包的作用域链包含HTML元素，则该元素无法被销毁。，但改写函数可以释放所占用的内存。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function fun()&#123;</div><div class="line">	...</div><div class="line">	var ele=document.getElementById(&quot;...&quot;)</div><div class="line">	var id =ele.id</div><div class="line">	ele.onclick=function()&#123;</div><div class="line">		alert(id)</div><div class="line">	&#125;	</div><div class="line">	ele=null</div><div class="line">&#125;//即闭包不直接引用HTML元素，可以保证内存的正常回收</div></pre></td></tr></table></figure></p>
<h3 id="2.3">块级作用域与私有变量</h3>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">function f()&#123;&#125;()//出错，函数声明不能直接调用</div><div class="line">(function f()&#123;&#125;)()//转换成表达式即可调用</div></pre></td></tr></table></figure>
<p>f拥有私有的作用域又可以访问环境的对象，而且不会扰乱全局作用域。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function f(name)&#123;</div><div class="line">	this.getName=function()&#123;//特权方法</div><div class="line">		return name</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>name作为私有变量无法直接访问，但是可以通过getName方法访问。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JavaScript函数的闭包与变量。&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://www.codingbalian.online/categories/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaScript对象</title>
    <link href="http://www.codingbalian.online/2017/02/27/JavaScript-object/"/>
    <id>http://www.codingbalian.online/2017/02/27/JavaScript-object/</id>
    <published>2017-02-27T11:59:25.000Z</published>
    <updated>2017-02-27T16:13:02.021Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript中的原型对象与继承<br><a id="more"></a></p>
<h2 id="1">创建对象</h2>


<h3 id="1.1">工厂模式</h3>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function create(value,..) &#123;</div><div class="line">    var o =new Object()</div><div class="line">    o.attr=value</div><div class="line">        ...</div><div class="line">    return o    </div><div class="line">&#125;</div><div class="line">var newObj=create(value,..)</div></pre></td></tr></table></figure>
<p>缺陷：无法明确对象的类型。</p>
<h3 id="1.2">构造函数模式</h3>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">   function Create(value,..) &#123;</div><div class="line">       this.attr=value</div><div class="line">           ...</div><div class="line">   &#125;</div><div class="line">   var newObj=new Create(value,..)</div><div class="line">//可以明确newObj是Create对象的实例</div><div class="line">alert(newObj instanceof Create) //true</div></pre></td></tr></table></figure>
<p>缺点：在创建函数中加入方法函数，则在实例化时方法函数也将被实例化，虽然函数的机制是相同的但是会导致不同的作用域链和标识符解析。</p>
<h3 id="1.3">原型模式</h3>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">   function Create() &#123;</div><div class="line">   &#125;</div><div class="line">   Create.prototype.attr1=value1</div><div class="line">   Create.prototype.attr2=value2</div><div class="line">       ...</div><div class="line">   var newObj=new Create()    </div><div class="line">//实例newObj通过指针指向原型对象而非构造函数</div><div class="line">newObj.attr1=newValue1//添加属于实例的attr1属性而屏蔽原型的属性值</div><div class="line">delete newObj.attr1//删除实例的attr1，此时实例的attr1指向原型，值为原型的attr1的值</div></pre></td></tr></table></figure>
<p>原型包含constructor，所以<code>newObj.constructor==Create</code>为真<br>由于在创建原型属性与方法时都需要写<code>prototype</code>显得比较繁琐，因此可以使用更简单的写法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">   function Create() &#123;</div><div class="line">   &#125;</div><div class="line">   Create.prototype = &#123;</div><div class="line">       attr1: value1</div><div class="line">           ....</div><div class="line">   &#125;</div><div class="line">   var newObj=new Create()</div><div class="line">alert(newObj.constructor==Create)//弹出false</div></pre></td></tr></table></figure></p>
<p>尽管instanceof还可以返回正确的构造类型但是此时的原型不包含constructor,所以无法确定其构造对象。<br>解决方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">   function Create() &#123;</div><div class="line">   &#125;</div><div class="line">   Create.prototype = &#123;</div><div class="line">	constructor: Create//Enumerable属性默认为true</div><div class="line">       attr1: value1</div><div class="line">           ....</div><div class="line">   &#125;</div><div class="line">Object.defineProperty(Create.prototype, &quot;constructor&quot;, &#123;</div><div class="line">       enumerable: false</div><div class="line">       value: Create</div><div class="line">   &#125;)</div><div class="line">   var newObj=new Create()</div></pre></td></tr></table></figure></p>
<p>对原型做的任何修改都可以直接在实例上反映出来，即使实例创建在修改之前，但是如果重写原型，则构造函数指向新的原型，而已实例化的实例则指向原实例，则无法反映新的修改。</p>
<p>原型对象的缺陷：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function Arr&#123;</div><div class="line">&#125;</div><div class="line">Arr.prototype=&#123;</div><div class="line">...</div><div class="line">arrs:[&quot;a&quot;,&quot;b&quot;]</div><div class="line">...</div><div class="line">&#125;</div><div class="line">var example1 =new Arr()</div><div class="line">var example2 =new Arr()</div><div class="line">example1.arrs.push(&quot;c&quot;)</div><div class="line">alert(example2.arrs)//&quot;a,b,c&quot;</div></pre></td></tr></table></figure></p>
<p>可以看出两个实例共享了一个数组的地址，如果不是本意，则会出现巨大的错误，因此很少独立使用原型对象。</p>
<h3 id="1.4">组合使用构造函数与原型模式</h3>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">function Create(value1,...)&#123;</div><div class="line">this.attr1=value1</div><div class="line">...</div><div class="line">//定义私有属性与方法</div><div class="line">&#125;</div><div class="line">Create.prototype=&#123;</div><div class="line">constructor:Creare</div><div class="line">...//添加共享属性、方法</div><div class="line">&#125;</div><div class="line">Object.defineProperty(Create.prototype, &quot;constructor&quot;, &#123;</div><div class="line">       enumerable: false</div><div class="line">       value: Create</div><div class="line">   &#125;)</div><div class="line">var newObj=new Create()</div></pre></td></tr></table></figure>
<h3 id="1.5">寄生构造函数模式</h3>

<p>寄生模式的思想是创建一个函数，功能仅是封装对象的代码，然后返回新创建的对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function fun(value,..)&#123;</div><div class="line">	var o =new Object()</div><div class="line">	o.arr=value</div><div class="line">	...</div><div class="line">	return o</div><div class="line">	&#125;</div><div class="line">var newObj=new fun(value,...)</div></pre></td></tr></table></figure></p>
<p>同时也可在特殊情况下为对象创造构造函数，如为Array创造一个额外的构造函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function SecialArray()&#123;	</div><div class="line">	var values=new Array()</div><div class="line">	values.push.apply(values,arguments)</div><div class="line">	values.toRipedString=function()&#123;</div><div class="line">		return this.join(&quot;|&quot;)</div><div class="line">	&#125;</div><div class="line">	return values</div><div class="line">&#125;</div><div class="line">var colors = new SecialArray(&quot;red&quot;,&quot;blue&quot;)</div><div class="line">alert(colors.toRipedString())/&quot;red|blue&quot;</div></pre></td></tr></table></figure></p>
<h3 id="1.6">稳妥构造函数模式</h3>

<p>适用于安全环境下，没有公共属性，不引用this对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function fun(value,..)&#123;</div><div class="line">	var o =new Object()</div><div class="line">	//定义私有属性与函数</div><div class="line">	o.privatelyfun=function()&#123;</div><div class="line">		alert(value)//访问参数，除此以外无法访问</div><div class="line">	&#125;</div><div class="line">	return o</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="2">继承</h2>

<p>实例包含一个指向原型对象的内部指针，原型对象包含一个指向构造函数的指针，每个构造函数都有一个原型对象；如果当原型对象是另一个类型的实例，另一个类型的指针又指向其他原型对象的内部以此类推，就实现了继承。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">   function SuperType() &#123;</div><div class="line">       this.prototype=true</div><div class="line">       SuperType.prototype.getSuperValue=function () &#123;</div><div class="line">           return this.prototype</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   function SubType() &#123;</div><div class="line">       this.subprototype=false</div><div class="line">   &#125;</div><div class="line">   SubType.prototype=new SuperType()</div><div class="line">   SubType.prototype.getSubValue=function () &#123;</div><div class="line">       return this.subprototype</div><div class="line">   &#125;</div><div class="line">var instance=new SubType()</div><div class="line">   alert(instance.getSuperValue())</div></pre></td></tr></table></figure></p>
<p>当子类型需要重写超类型的方法或者要添加新方法时，必须要放在原类型实例化之后在重写/添加。且不能用对象字面量进行重写。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">   function SuperType() &#123;</div><div class="line">       this.prototype=true</div><div class="line">       SuperType.prototype.getSuperValue=function () &#123;</div><div class="line">           return this.prototype</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   function SubType() &#123;</div><div class="line">       this.subprototype=false</div><div class="line">   &#125;</div><div class="line">   SubType.prototype=new SuperType()</div><div class="line">   SubType.prototype.getSubValue=function () &#123;</div><div class="line">       return this.subprototype</div><div class="line">   &#125;//添加新方法</div><div class="line">SubType.prototype.getSuperValue=function () &#123;</div><div class="line">       return false</div><div class="line">   &#125;//重写getSuperValue方法</div><div class="line">/*使用对象字面量会重写prototype</div><div class="line">*切断继承关系</div><div class="line">*SubType.prototype=&#123;</div><div class="line">*	getSuperValue：function&#123;...&#125;</div><div class="line">* 	...</div><div class="line">*/	&#125;</div><div class="line">var instance=new SubType()</div></pre></td></tr></table></figure></p>
<p>缺点：共享数组，子类不能向超类传值。因此需要借用构造函数。</p>
<h3 id="2.1">借用构造函数</h3>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function SuperType(name)&#123;</div><div class="line">	this.name=name</div><div class="line">&#125;</div><div class="line">function SubType(age)&#123;</div><div class="line">	SuperType.call(this,nameValue)//在子类型内构造并且实现传值</div><div class="line">	this.age=age</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>缺点：超类的方法对子类不可见，结构所有类型都只能使用构造函数模式。因此很少单独使用。</p>
<h3 id="2.2">组合继承</h3>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function SuperType(name)&#123;</div><div class="line">	this.name=name</div><div class="line">&#125;</div><div class="line">SuperType.prototype.sayName=function()&#123;</div><div class="line">	alert(this.name)</div><div class="line">&#125;</div><div class="line">function SubType(name,age)&#123;</div><div class="line">	SuperType.call(this,name)//继承属性，第二次调用SuperType</div><div class="line">	this.age=age</div><div class="line">&#125;</div><div class="line">SubType.prototype=new SuperType()//继承方法,第一次调用SuperType</div><div class="line">SubType.prototype.constructor=SubType</div><div class="line">....</div></pre></td></tr></table></figure>
<h3 id="2.3">原型继承</h3>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function object(o)&#123;</div><div class="line">function F()&#123;&#125;</div><div class="line">F.prototype=o</div><div class="line">return new F()</div><div class="line">&#125;//对于传进的对象o进行了一次浅复制</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var person=&#123;</div><div class="line">	name:&quot;Linda&quot;</div><div class="line">	friends:[&quot;Van&quot;,&quot;Ben&quot;]</div><div class="line">&#125;</div><div class="line">var new1=Object.create(person)</div><div class="line">var new2=Object.create(person)//使用Object.create()方法使得friends数组不被共享</div></pre></td></tr></table></figure>
<h3 id="2.3">寄生继承</h3>

<p>创建一个仅用于封装过程的函数，在内部增强对象，最后再返回对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function createAnother(original)&#123;</div><div class="line">	var clone=object(original)//创建新对象</div><div class="line">	clone.newFunction=function()&#123;...&#125;//增强对象</div><div class="line">	return clone</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>寄生组合<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function inherit(subType,superType)&#123;</div><div class="line">	var prototype=object(superType.prototype)//创建对象</div><div class="line">	prototype.constructor=subType</div><div class="line">	subType.prototype=prototype</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JavaScript中的原型对象与继承&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://www.codingbalian.online/categories/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaScript:学习笔记2</title>
    <link href="http://www.codingbalian.online/2017/02/26/JavaScript-Note2/"/>
    <id>http://www.codingbalian.online/2017/02/26/JavaScript-Note2/</id>
    <published>2017-02-26T13:00:05.000Z</published>
    <updated>2017-03-05T13:44:42.300Z</updated>
    
    <content type="html"><![CDATA[<p>　<br><a id="more"></a></p>
<h2 id="1">Script参数</h2>

<p><code>async</code> 可选，立刻下载脚本文件 在XHTML中需要设置为<code>async=&quot;async&quot;</code><br><code>defer</code> 可选，脚本延迟到整个文档全部解析显示后加载<br><code>src</code> 可选，执行外部脚本，含有src的<code>&lt;script&gt;</code>标签内不能在含有脚本代码，因为代码会被忽略。<br><code>type</code> 默认为’text/javascripy’</p>
<p>在XHTML中使用JavaScript</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">   &lt;script type=&quot;text/javascript&quot; &gt;</div><div class="line">	//&lt;![CDATA[</div><div class="line">		脚本函数</div><div class="line">	//]]&gt;</div><div class="line">&lt;script&gt;</div><div class="line">&lt;!--将CDATA注释是为了保证不兼容CDATA的浏览器能够平稳退化--&gt;</div></pre></td></tr></table></figure>
<p>严格模式在顶部添加<code>&quot;use strict&quot;</code>不确定的行为会被处理，而不安全的操作会被抛出。</p>
<h2 id="2">函数规范</h2>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">function fun(a,b,...)&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>传给函数的参数不能命名为<code>eval</code>或者<code>arguments</code><br><code>arguments</code>与数组类似但并不是数组，可以代替参数使用。</p>
<p>函数没有方法重载，名字只会属于后面被定义的函数。</p>
<h2 id="3">变量与作用域</h2>

<p>变量复制后两个变量互不影响，但是对象复制后两个对象都指向堆内存中的同一个对象，对其中一个对象操作都会影响到另一个对象。</p>
<p>对函数传递参数时，按值传递不影响参数，按类型传递（如object）则影响外部的值。</p>
<p>在函数内使用<code>var</code>定义变量，则变量的生命周期只存在于函数内部，若不使用<code>var</code>定义，则在函数外部也可以访问到。</p>
<h2 id="4">数组</h2>

<p>使用<code>arr.length</code>可以方便的改变数组的长度。<br>使用<code>value instanceof Array</code>或者<code>Arrary.isArrary(value)</code>可以判断对象是否为数组对象。<br><code>alert()</code>函数接受的是字符串对象，会在后台调用<code>toString()</code>方法。</p>
<p>栈方法：后进先出<br><code>push()</code>将参数添加到字符串的末尾。<br><code>pop()</code>获得数组最后一个项并且将其从数组中删除。<br>队列方法：先进先出<br><code>shift()</code>方法获得数组的第一个项并且将其从数组中删除。<br><code>unshift()</code>方法向数组添加项并返回数组的新长度。<br>重排序方法：<br><code>reverse()</code>直接将数组倒序。<br><code>sort()</code>比较排列，但是由于调用了<code>toString()</code>方法，是将数组的值当做字符串来进行比较则会出现5排在15后的现象，因此可以用这个方法接受一个比较函数作为参数再进行数值的比较：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">      function compare(value1, value2) &#123;//升序</div><div class="line">          if (value1 &lt; value2) &#123;</div><div class="line">              return -1</div><div class="line">          &#125;</div><div class="line">          else if (value2 &lt; value1) &#123;</div><div class="line">              return 1</div><div class="line">          &#125;</div><div class="line">          else &#123;</div><div class="line">              return 0</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line">Arr.sort(compare)</div><div class="line">//降序只需要将-1与1互换即可。</div></pre></td></tr></table></figure></p>
<p><code>concat()</code>方法在数组后添加另一串数组<br><code>slice()</code>在只包含一个参数的条件下返回指定位置到最后一项的数组，若包含两个数字，则截取始末数字位置间的内容，包括开始项而不含结束项。若输入负数则表示长度加上负数的值来取位置<br><code>splice(0,2)</code>表示从第一项开始删除两个数组项<br><code>splice(2,0,value1,...)</code>表示从第3项开始插入值，不删除任何项<br><code>splice(2,1,value,...)</code>表示从第三项删除一个项，然后在原来的位置上开始插入新的值。</p>
<h2 id="5">正则表达式与函数</h2>

<p>创建正则表达式对象：<br><code>var expression = /pattern/ flags</code><br><code>var obj=new RegExp(&quot;pattern&quot;,&quot;flags&quot;)</code><br>flags可选，可包含多个：i表示不区分大小写，g表示匹配全局，m表示多行，在一行文本末尾时还会继续寻找下一行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var text=&apos;value&apos;</div><div class="line">var obj=new RegExp(&quot;&quot;,&quot;&quot;)</div><div class="line">//text.match(obj)等同于obj.exec(text)</div></pre></td></tr></table></figure></p>
<p>函数：访问函数本身：functionname，不包含括号。<br>函数内部属性：arguments：包含所有参数，this指向执行的环境对象。<br><code>arguments.callee</code>指向正在调用的函数，在函数内部使用可以消除耦合。<br><code>arguments.caller</code>指向调用函数本身的另一函数，若在全局环境中调用则返回null。</p>
<h2 id="6">对象</h2>

<p>对象的数据属性：<br>Configurable:默认为true，表示能否提供delete删除属性，修改属性的特性，能否将属性修改位访问器属性。<br>Enumerable：默认为true，表示能否通过for-in循环返回属性。<br>Writable：默认为true，表示能否修改属性。<br>Value：写入属性时将属性的值包含在此。<br>修改属性默认的特性：<br><code>Object.defineProperty(objectname,&quot;attributename&quot;,{Configurable|Enumerable|Writable|Value})</code></p>
<p>访问器属性：<br>Configurable:默认为true，表示能否提供delete删除属性，修改属性的特性，能否将属性修改位访问器属性。<br>Enumerable：默认为true，表示能否通过for-in循环返回属性。<br>Get：读取属性时调用的函数。<br>Set：设置属性时调用的函数。</p>
<p>读取属性的特性：<br><code>Object.getOwnPropertyDescriptor(objectname,&#39;attributename&#39;)</code><br>返回包含对象数据/访问器属性的对象。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://www.codingbalian.online/categories/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>jQuery学习笔记</title>
    <link href="http://www.codingbalian.online/2017/02/26/jQuery-note/"/>
    <id>http://www.codingbalian.online/2017/02/26/jQuery-note/</id>
    <published>2017-02-26T09:08:26.000Z</published>
    <updated>2017-03-05T13:42:18.348Z</updated>
    
    <content type="html"><![CDATA[<p>jQuery的代码风格与冲突解决<br><a id="more"></a></p>
<h2 id="1">代码规范</h2>

<p>同一个对象的操作不超过3条,写在同一行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(this).show().unbind(&quot;click&quot;)</div></pre></td></tr></table></figure></p>
<p>同一个对象的大量操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$(this).removeClass(&quot;&quot;)</div><div class="line">	   .addClass(&quot;&quot;)</div><div class="line">	   .stop()</div><div class="line">	   .unblind(&quot;&quot;)</div><div class="line">	   .click(function()&#123;</div><div class="line">	&#125;)</div></pre></td></tr></table></figure></p>
<p>多个对象的少量操作,适当缩进<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$(this).addClass(&quot;&quot;)</div><div class="line">	.children(&quot;&quot;).show().end()</div><div class="line">.silbings().removeClass(&quot;&quot;)</div><div class="line">	.children(&quot;&quot;).hide()</div></pre></td></tr></table></figure></p>
<h2 id="2">jQuery与DOM对象的转换</h2>

<p>jQuery对象：<code>var $obj=</code><br>DOM对象：<code>var obj=</code></p>
<p>jQuery对象转化为DOM对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var $obj=$(&quot;#cr&quot;)</div><div class="line">var cr=$obj[0]</div><div class="line">//使用get(index)方法</div><div class="line">var $obj=$(&quot;#cr&quot;)</div><div class="line">var cr=$obj.get(0)</div></pre></td></tr></table></figure></p>
<p>DOM对象转化为jQuery对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var cr=document.getElementById(&quot;cr&quot;)</div><div class="line">var $obj=$(cr)</div></pre></td></tr></table></figure></p>
<h2 id="3">解决jQuery与其他库的冲突</h2>

<ul>
<li>jQuery在其他库之后导入</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">//使用jQuery()作为jQuery对象的制造工厂</div><div class="line">jQuery.noConflict()//将变量$控制权交给其他库</div><div class="line">jQuery(function ()&#123;</div><div class="line">//使用jQuery</div><div class="line">&#125;)</div><div class="line">//也可以使用自定义备用名</div><div class="line">var $j=jQuery.noConflict()//将变量$控制权交给其他库</div><div class="line">$j(function ()&#123;//使用快捷方式$j</div><div class="line">//使用jQuery</div><div class="line">&#125;)</div><div class="line">//不使用自定义名称而继续使用$</div><div class="line">jQuery.noConflict()</div><div class="line">jQuery(function ($)&#123;</div><div class="line">//使用jQuery</div><div class="line">&#125;)</div><div class="line">//或者使用匿名函数</div><div class="line">jQuery.noConflict()</div><div class="line">(function ($)&#123;</div><div class="line">//使用jQuery</div><div class="line">&#125;)(jQuery)</div></pre></td></tr></table></figure>
<ul>
<li>jQuery在其他库之前导入</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">jQuery(function ()&#123;</div><div class="line">//使用jQuery</div><div class="line">&#125;)</div><div class="line">//$()作为其他库的快捷方式，使用jQuery作为制造工厂</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;jQuery的代码风格与冲突解决&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://www.codingbalian.online/categories/JavaScript/"/>
    
    
      <category term="jQuery" scheme="http://www.codingbalian.online/tags/jQuery/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript:学习笔记1</title>
    <link href="http://www.codingbalian.online/2017/02/21/JavaScript-Note/"/>
    <id>http://www.codingbalian.online/2017/02/21/JavaScript-Note/</id>
    <published>2017-02-21T05:53:25.000Z</published>
    <updated>2017-02-26T13:01:24.768Z</updated>
    
    <content type="html"><![CDATA[<p>DOM对象与实用函数。<br><a id="more"></a></p>
<h2 id="1">JS变量作用域</h2>

<p>全局变量与局部变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var total = 10</div><div class="line">function square(num) &#123;</div><div class="line">    total = num * num</div><div class="line">    return total</div><div class="line">&#125;</div><div class="line">square(4)</div><div class="line">alert(total)</div></pre></td></tr></table></figure>
<p>返回的total值为16<br>在调用<code>square()</code>函数时改变了total的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var total = 10</div><div class="line">function square(num) &#123;</div><div class="line">    var total = num * num</div><div class="line">    return total</div><div class="line">&#125;</div><div class="line">square(4)</div><div class="line">alert(total)</div></pre></td></tr></table></figure>
<p>返回total值为10<br>在函数中使用var定义变量后函数中的total则变成局部变量，不在使用之前定义的全局变量total。</p>
<h2 id="2">JS DOM使用</h2>

<p><code>getElementById(idname)</code>获取id值为idname的元素，返回一个对象</p>
<p><code>getElementsByName(namevalue)</code> 获取所有name属性为namevalue的元素，返回一个数组</p>
<p><code>getElementsByTagName(tagnamevalue)</code> 获取所有标签为tagnamevalue的元素，返回一个数组</p>
<p><code>getElementsByClassName(class1 (class2 ...))</code>获取所有class值包括class1(class2 …)的元素，其中class值以空格隔开，不分顺序，返回值是一个数组</p>
<p>以上方法都适用于document对象，也可组合使用。</p>
<p><code>obj.getAttribute(attribute)</code>只使用于object对象即节点元素，获取对象的属性值</p>
<p><code>obj.setAttribute(attribute,value)</code>也只适用于节点元素，为元素添加值为value的attribute属性</p>
<p><code>document.getElementsByTagName(&quot;form&quot;)=document.forms</code></p>
<p><code>element.getAttribute(&#39;src&#39;)=element.src</code></p>
<p><code>element.getAttribute(&#39;href&#39;)=element.href</code></p>
<p><code>document.getElementsByTagName(&#39;body&#39;)=document.body</code></p>
<p><code>element.className=element.setAttribute(&#39;class&#39;,value)</code></p>
<h3 id="2.1">分离Javascript</h3>

<p><code>element.event=action</code></p>
<p>监听：<code>element.addEventListener(event, function, useCapture)</code><br>useCapture默认为false在冒泡阶段执行，true为在捕获阶段执行</p>
<p>移除监听：<code>element.removeEventListener(event, function, useCapture)</code><br>useCapture默认为false在冒泡阶段执行，true为在捕获阶段执行</p>
<table>
<thead>
<tr>
<th>DOM 0</th>
<th>DOM 2</th>
</tr>
</thead>
<tbody>
<tr>
<td>onblur()</td>
<td>blur</td>
</tr>
<tr>
<td>onfocus()</td>
<td>focus</td>
</tr>
<tr>
<td>onchange()</td>
<td>change</td>
</tr>
<tr>
<td>onmouseover()</td>
<td>mouseover</td>
</tr>
<tr>
<td>onmouseout()</td>
<td>mouseout</td>
</tr>
<tr>
<td>onmousemove()</td>
<td>mousemove</td>
</tr>
<tr>
<td>onmousedown()</td>
<td>mousedown</td>
</tr>
<tr>
<td>onmouseup()</td>
<td>mouseup</td>
</tr>
<tr>
<td>onclick()</td>
<td>click</td>
</tr>
<tr>
<td>ondblclick()</td>
<td>dblclick</td>
</tr>
<tr>
<td>onkeydown()</td>
<td>keydown</td>
</tr>
<tr>
<td>onkeyup()</td>
<td>keyup</td>
</tr>
<tr>
<td>onkeypress()</td>
<td>keypress</td>
</tr>
<tr>
<td>onsubmit()</td>
<td>submit</td>
</tr>
<tr>
<td>onload()</td>
<td>load</td>
</tr>
<tr>
<td>onunload()</td>
<td>unload</td>
</tr>
</tbody>
</table>
<ul>
<li>DOM2可以使用js监听事件</li>
</ul>
<h3 id="2.2">共享onload事件</h3>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">      function addLoadEvent(func) &#123;</div><div class="line">          var oldOnLoad = window.onload</div><div class="line">          if (typeof window.onload != &apos;function&apos;) &#123;</div><div class="line">              window.onload = func</div><div class="line">          &#125;</div><div class="line">          else &#123;</div><div class="line">              window.onload = function () &#123;</div><div class="line">                  oldOnLoad();</div><div class="line">                  func()</div><div class="line">              &#125;</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line">addLoadEvent(function1)</div><div class="line">addLoadEvent(function2)</div></pre></td></tr></table></figure>
<h3 id="2.3">insertAfter方法</h3>

<p>DOM中定义了insertBefore方法，却没有给出相应的insertAfter方法，但是可以自己实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function insertAfter(newElement, targetElement) &#123;</div><div class="line">    var parent = targetElement.parentNode</div><div class="line">    if (parent.lastChild == targetElement) &#123;</div><div class="line">        parent.appendChild(newElement)</div><div class="line">    &#125;</div><div class="line">    else &#123;</div><div class="line">        parent.insertBefore(newElement, targetElement.nextSibling)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="2.4">获取下一个元素节点</h3>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">   function getNextElement(node) &#123;</div><div class="line">       if (node.nodeType == 1) &#123;</div><div class="line">           return node</div><div class="line">       &#125;</div><div class="line">       if (node.nextSibling) &#123;</div><div class="line">           getNextElement(node.nextSibling)</div><div class="line">       &#125;</div><div class="line">       return null</div><div class="line">   &#125;</div><div class="line">getNextElement(node.nextSibling)</div></pre></td></tr></table></figure>
<h2 id="3">Ajax的兼容</h2>

<p>Ajax使用XMLHttpRequest对象，但是由于IE与其他浏览器的实现方式不同，需要创建一个兼容对象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">      function requestObject() &#123;</div><div class="line">          if (typeof XMLHttpRequest == &apos;undefined&apos;)</div><div class="line">              XMLHttpRequest = function () &#123;</div><div class="line">                  try &#123;</div><div class="line">                      return new ActiveXObject(&quot;Msxml2.XMLHTTP.6.0&quot;)</div><div class="line">                  &#125;</div><div class="line">                  catch (e) &#123;</div><div class="line">                  &#125;</div><div class="line">                  try &#123;</div><div class="line">                      return new ActiveXObject(&quot;Msxml2.XMLHTTP.3.0&quot;)</div><div class="line">                  &#125;</div><div class="line">                  catch (e) &#123;</div><div class="line">                  &#125;</div><div class="line">                  try &#123;</div><div class="line">                      return new ActiveXObject(&quot;Msxml2.XMLHTTP&quot;)</div><div class="line">                  &#125;</div><div class="line">                  catch (e) &#123;</div><div class="line">                  &#125;</div><div class="line">                  return false</div><div class="line">              &#125;</div><div class="line">          return new XMLHttpRequest()</div><div class="line">      &#125;</div><div class="line">var request = new  requestObject()</div></pre></td></tr></table></figure></p>
<p>XMLHTTPREQUEST对象发送的请求只能访问同一个域的数据。<br>Ajax在发送请求之后脚本会继续执行。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;DOM对象与实用函数。&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://www.codingbalian.online/categories/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>操作系统：文件管理</title>
    <link href="http://www.codingbalian.online/2017/01/06/OS-File%20Management/"/>
    <id>http://www.codingbalian.online/2017/01/06/OS-File Management/</id>
    <published>2017-01-06T08:18:29.000Z</published>
    <updated>2017-01-06T15:20:26.142Z</updated>
    
    <content type="html"><![CDATA[<p>操作系统中文件管理功能的概述。<br><a id="more"></a></p>
<h2 id="1">文件和文件系统</h2>

<p>文件是数据的一种组织形式，由数据项和记录构成。<br>数据项包括基本数据项和组合数据项。用于描述对象的某个属性。<br>记录是一组相关数据项的集合。<br>文件在文件系统中是一个最大的数据单位。</p>
<h3 id="1.1">文件分类</h3>

<p>文件的分类可以更好地管理和使用，提高了文件的存取速度，对文件的共享和保护也有利。<br>一般系统级与用户级要进行不同的管理。<br>按性质和用途分：</p>
<ul>
<li>系统文件：由系统软件构成的文件，只允许用户通过系统调用或系统提供的专用命今来执行它们，不允许对其进行读写和修改。</li>
<li>库文件：文件允许用户对其进行读取和执行，但不允许对其进行修改。</li>
<li>用户文件：是用户通过操作系统保存的用户文件，由文件的所有者或所有者授权的用户才能使用。</li>
</ul>
<p>按操作保护分类：</p>
<ul>
<li>可执行文件：允许调用而不允许读写</li>
<li>只读文件：可读不可写</li>
<li>可读可写文件</li>
</ul>
<p>按使用情况分类：</p>
<ul>
<li>临时文件：用于系统在工作过程中产生的中间文件，一般有暂存目录，工作完毕会自动删除。</li>
<li>永久文件: 受系统管理的各种系统和用户文件。</li>
<li>档案文件: 系统或一些实用工具软件包在工作过程中记录在案的文挡资料文件，以便查阅历史档案。</li>
</ul>
<p>按用户观点分类：</p>
<ul>
<li>普通文件：字符流组成的无结构文件</li>
<li>目录文件：文件的目录信息构成的特殊文件</li>
<li>特殊文件（设备驱动程序）</li>
</ul>
<p>按存取的物理结构分类：</p>
<ul>
<li>顺序文件：文件中的纪录，顺序地存储到连续的物理盘块中</li>
<li>链接文件：文件中的纪录可存储在并不相邻接的各个物理块中，通过物理块中的链接指针组成一个链表管理，形成一个完整的文件</li>
<li>索引文件：文件中的纪录可存储在并不相邻接的各个物理块中，纪录和物理块之间通过索引表项按关键字存取文件，通过物理块中的索引表管理，形成一个完整的文件</li>
</ul>
<p>按文件的逻辑存储结构分类：</p>
<ul>
<li>有结构文件：由若干个记录所构成的文件</li>
<li>无结构文件：这是直接由字符序列所构成的文件</li>
</ul>
<p>按文件中的数据形式分类：</p>
<ul>
<li>源文件：由源程序和数据构成的文件</li>
<li>目标文件：由源程序经过编译，但尚未经过链接程序链接的目标代码所形成的文件</li>
</ul>
<h3 id="1.2">文件系统</h3>

<p>文件系统：操作系统中统一管理信息资源的一种软件，管理文件的存储、检索、更新，提供安全可靠的共享和保护手段，并且方便用户使用。<br>文件系统包含文件管理程序（文件与目录的集合）和所管理的全部文件。</p>
<h2 id="2">文件逻辑结构</h2>

<p>有结构文件：</p>
<ol>
<li>定长记录</li>
<li>变长记录</li>
</ol>
<p>无结构文件：流式文件是相关信息的有序集合如源程序、可执行文件、库函数，可以提供很好的灵活性。</p>
<h3 id="2.1">顺序文件</h3>

<p>逻辑记录的排序:</p>
<ul>
<li>串结构:各记录之间的顺序与关键字无关,通常按存入的时间排序。</li>
<li>顺序结构：所有记录按关键字排列。</li>
</ul>
<p>对顺序文件的读写操作：</p>
<ul>
<li>定长记录：所有记录长度相等</li>
<li>变长记录：记录长度不固定</li>
</ul>
<p>优点：每次要读或写一大批记录时，对顺序文件的存取效率是所有逻辑文件中最高的；能存储在磁带上，并能有效地工作。</p>
<p>缺点：查找或修改单个记录，系统要逐个地查找诸记录；增加或删除一个记录较困难。</p>
<h3 id="2.2">索引文件</h3>

<p>对于定长记录文件，如果要查找第i个记录，获得首地址：<br>$$A_i=i*L$$</p>
<p>对于可变长度记录的文件，要查找其第i个记录时，须首先计算出该记录的首地址。为此，须顺序地查找每个记录，从中获得相应记录的长度Li，然后才能按下式计算出第i个记录的首址:<br>$$ \sum_{i=0}^{i-1} L_i+i = A_i $$<br>因此，对于可变长度记录的文件难以实现直接存储。<br>文件中每个记录，在索引表中有一相应表项<br>因为索引表本身是一个定长记录的顺序文件，从而可以方便的实现直接存取。</p>
<h3 id="2.3">索引顺序文件</h3>

<p>顺序文件与索引文件相结合,将顺序文件中记录分为若干个组，为各组的第一个记录建立一个索引表。</p>
<h3 id="2.4">存储介质</h3>

<p>在文件系统中，文件的存储设备常常划分为若干大小相等的物理块。同时也将文件信息划分成相同大小的逻辑块，所有块统一编号。以块为单位进行信息的存储、传输，分配。<br>常见的存储介质:磁盘，磁带，光盘</p>
<h2 id="3">文件的物理结构</h2>

<p>文件的物理结构也即文件的外存分配方式。</p>
<h3 id="3.1">连续分配</h3>

<p>一个文件的信息存放在若干连续的物理块中。<br>优点：</p>
<ul>
<li>简单</li>
<li>支持顺序存取和随机存取</li>
<li>顺序存取速度快</li>
<li>所需的磁盘寻道次数和寻道时间最少</li>
</ul>
<p>缺点：</p>
<ul>
<li>要求有连续的存储空间 </li>
<li>必须事先知道文件的长度 </li>
</ul>
<p>连续文件：由一组相邻的物理块组成，是对记录式文件取连续区分配而构成的文件。</p>
<h3 id="3.2">链接分配</h3>

<p>一个文件的信息存放在若干不连续的物理块中，各块之间通过指针连接，前一个物理块指向下一个物理块。<br>优点：</p>
<ul>
<li>提高了磁盘空间利用率</li>
<li>不存在外部碎片问题</li>
<li>有利于文件插入和删除</li>
<li>有利于文件动态扩充</li>
</ul>
<p>缺点：</p>
<ul>
<li>存取速度慢，不适于随机存取</li>
<li>可靠性问题，如指针出错</li>
<li>更多的寻道次数和寻道时间</li>
<li>链接指针占用一定的空间</li>
<li>不能支持高效的直接存取。要对一个较大的文件进行直接存取，须首先在FAT中顺序地查找许多盘块号</li>
<li>FAT需占用较大的内存空间</li>
</ul>
<p>隐式链接：文件名，始址，末址<br>显式链接：文件名，块号，块中显示指针</p>
<h3 id="3.3">索引分配</h3>

<p>一个文件的信息存放在若干不连续物理块中，系统为每个文件建立一个专用数据结构–索引表，并将这些块的块号存放在一个索引表中。<br>一个索引表就是磁盘块地址数组,其中第i个条目指向文件的第i块。</p>
<p>优点：能顺序存取,也能随机存取，满足了文件动态增长、插入删除的要求，也能充分利用外存空间<br>缺点：较多的寻道次数和寻道时间，索引表本身带来了系统开销，如：内外存空间，存取时间。每个文件的索引表要分配盘块，可以存放成百上千的盘块号，但对于大量的小文件，索引块利用率极低。</p>
<h3 id="3.4">混合分配方式</h3>

<p>UNIX文件系统采用的是多级索引结构(混合分配模式)。每个文件的索引表为13个索引项，每项2个字节。最前面10项（ iaddr(0)~iaddr(9) ）直接登记存放文件信息的物理块号（直接寻址）。如果文件大于10块，则利用第11项指向一个物理块，该块中最多可放256个文件物理块的块号（一次间接寻址）。对于更大的文件还可利用第12和第13项作为二次和三次间接寻址。</p>
<h2 id="4">目录管理</h2>

<p>目录管理的目的：</p>
<ol>
<li>实现“按名存取” </li>
<li>提高对目录的检索速度 </li>
<li>文件共享 </li>
<li>允许文件重名 </li>
</ol>
<p>文件控制块FCB：操作系统为管理文件而设置的数据结构，存放了为管理文件所需的所有有关信息。包含文件名及文件的各种属性。文件和文件控制块一一对应，而把文件控制块的有序集合称为文件目录。即一个文件控制块就是一个文件目录项。</p>
<p>文件控制块的内容：</p>
<ol>
<li>基本信息类：文件名；文件物理位置；文件逻辑结构；文件的物理结构 </li>
<li>存取控制信息类 </li>
<li>使用信息类 </li>
</ol>
<h3 id="4.1">索引结点</h3>

<p>索引结点：查找文件，通常只需要文件名，因此将文件的其它描述信息放在索引节点中 ，这样查找目录更快。</p>
<p>磁盘索引结点：每个文件有唯一的索引节点</p>
<ol>
<li>文件主标识符</li>
<li>文件类型 </li>
<li>文件存取权限 </li>
<li>文件物理地址 </li>
<li>文件长度 </li>
<li>文件连接计数 </li>
<li>文件存取时间 </li>
</ol>
<p>内存索引结点：</p>
<ol>
<li>索引结点编号：用于标识内存索引结点</li>
<li>状态：指示i结点是否上锁或被修改</li>
<li>访问计数：每当有一进程要访问此i结点时， 将该访问计数加1， 访问完再减1</li>
<li>文件所属文件系统的逻辑设备号</li>
<li>链接指针：设置有分别指向空闲链表和散列队列的指针</li>
</ol>
<h3 id="4.2">目录</h3>

<p>文件目录：文件控制块FCB的有序集合<br>目录项：构成文件目录的项目FCB<br>目录文件：为了实现对文件目录的管理，通常将文件目录以文件的形式保存在外存</p>
<p>单级目录结构：为所有文件建立一个目录文件。<br>优点：简单，按名存取。<br>缺点：查找速度慢;不允许重名;不便于实现文件共享</p>
<p>二级目录结构：一级称为主文件目录，给出用户名，用户子目录所在的物理位置；二级称为用户文件目录，给出该用户所有文件的FCB<br>优点：提高了检索目录的速度；在不同的用户目录中，可以使用相同的文件名；不同用户还可使用不同的文件名来访问系统中的同一个共享文件。<br>缺点：不太适合大量用户和大量文件的大系统，增加了系统开销。</p>
<p>多级目录结构：目录与文件在一起，目录也做成文件。<br>优点：层次结构清晰，便于管理和保护；有利于文件分类；解决重名问题；提高文件检索速度；能进行存取权限的控制。<br>缺点：查找一个文件按路径名逐层检查，由于每个文件都放在外存，多次访盘影响速度。</p>
<h2 id="5">文件存储空间的管理</h2>

<p>外存空间管理:记录空闲存储空间，设置相应的数据结构;对存储空间进行分配与回收。<br>方法：</p>
<ol>
<li>空闲块表（空白文件目录）：将所有空闲块记录在一个表中，即空闲块表</li>
<li>空闲块链表：把所有空闲块链成一个链</li>
<li>位图法：用一串二进制位反映磁盘空间中分配使用情况, 每个物理块对应一位, 分配物理块为1，否则为0</li>
</ol>
<p>空闲表法属于连续分配方式。<br>一个连续的未分配区域称为“空白文件”，系统为所有这些“空白文件”单独建立一个目录。每个空白文件，在目录中建立一个表目。<br>表目内容：第一空白物理块的地址（块号）、空白块的数目。<br>当请求分配存储空间时，系统依次扫描空白文件目录的表目，直到找到一个合适的空白文件为止,当用户撤消一个文件时，系统回收该文件所占用的空间。扫描目录，寻找一个空表目，并将释放空间的第一物理号及它所占的物理块数填到这个表目中。</p>
<p>仅当有少量的空白区时才有较好的效果;如果存取空间中有着大量的小的空白区，则其目录变得很大，因而效率大为降低;这种分配技术适用于建立连续文件。</p>
<p>空闲盘区的分配与内存管理的动态分区方式类似：首次适应算法；循环首次适应算法；最佳适应算法；最坏适应算法。</p>
<p>空闲块链：把其中所有的“空白块” 链在一起。<br>创建文件需要一个或几个物理块时，就从链头依次取下一块或几块。<br>回收文件时回收块链到空白链上。</p>
<p>位示图法：反映整个存取空间的分配请况：用一串二进制位反映磁盘空间中分配使用情况, 每个物理块对应一位, “1”表示对应的物理块已分配，”0”表示其对应的块未分配。申请物理块时，可以在位示图中查找为0的位，返回对应物理块号，归还时；将对应位转置0。描述能力强，适合各种物理结构。</p>
<h2 id="6">文件共享和保护</h2>

<p>文件共享节省时间和存储空间，减少了用户工作量；进程间通过文件交换信息。</p>
<h3 id="6.1">共享</h3>

<p>共享形式：</p>
<ul>
<li>被多个用户使用，由存取权限控制</li>
<li>被多个程序使用，但各用自己的读写指针</li>
<li>被多个程序使用，但共享读写指针</li>
<li>多个用户用相同或不同的名字来访问同一文件。</li>
</ul>
<p>实现：</p>
<ol>
<li>建立值班目录：由系统目录实现对文件的共享；用户通过全路径名共享地访问这些文件</li>
<li>采用链访技术：对要共享的文件进行连接:通过Link命令，在用户自己的目录项中对要共享的文件建立起相应的表目，即建立两个文件的等价关系</li>
<li>基于索引结点的共享方式:将文件的物理地址和文件属性等信息放在索引结点中，在文件目录中，设文件名及指向索引结点的指针，另外在索引结点中增加链接计数count,表示共享的用户数删除时必须count=0</li>
<li>利用符号链实现文件共享:共享某文件时创建新文件，加到用户目录中，该文件仅包含被链接文件F的路径名,只有文件才拥有指向其索引结点的指针，其它共享的用户只有该文件的路径名</li>
</ol>
<h3 id="6.2">保护</h3>

<p>文件的保护机制:对拥有权限的用户，应该让其进行相应操作，否则禁止,防止其他用户冒充对文件进行操作。</p>
<p>存取控制矩阵：整个系统一个表，二维矩阵，行：系统中的全部用户；列：系统中的全部文件，系统允许用户i访问文件j，则B[i,j]＝1否则B[i,j]＝0。</p>
<p>存取控制表：一个文件一个表。按用户对文件的访问权力对用户进行分类，所有用户组的存取权限的集合就是该文件的存取控制表。</p>
<ol>
<li>文件主</li>
<li>指定的用户：由文件主指定的允许使用此文件的用户。</li>
<li>同组用户：与文件主属于某一特定项目的成员，同组用户与此文件有关</li>
<li>其他用户</li>
</ol>
<ul>
<li>将所有对某一文件有存取要求的用户按某种关系或工程项目的类别分成若干组，</li>
<li>另外的用户归入其他用户类，</li>
<li>规定每一组用户的存取权限。</li>
</ul>
<p>口令：用户为自己的每个文件规定一个口令，并附在用户文件目录中。凡请求该文件的用户必须先提供口令，只有当提供的口令与目录中的口令一致才允许用户存取该文件。<br>当文件主允许其他用户使用他的文件时，必须将口令告诉其他用户。<br>优点是：简便，节省空间。<br>缺点：</p>
<ul>
<li>可靠性差。口令易被窃取。</li>
<li>存取控制不易改变。</li>
<li>保护级别少：只有允许和不允许两种，对于允许，没有指明只读、只写等权限。 </li>
</ul>
<p>密码：<br>编码：当用户建立一个文件时，利用一个代码键来启动一个随机数发生器，产生一系列随机数，由文件系统将这些相继的随机数依次加到文件的字节上去。<br>译码：使用相同的代码键启动随机数发生器，从存入的文件中依次减去所得到随机数，文件就还原了。<br>只有当用户存取文件时，才需将代码键送入系统。文件主只将代码键告诉允许访问该文件的用户。<br>优点：保密性强，节省存储空间。<br>缺点：必须花费大量的编码和译码时间，从而增加了系统的开销。</p>
<h3 id="6.3">磁盘容错技术</h3>

<p>容错技术是通过在系统中设置冗余部件来提高系统可靠性的一种技术。<br>磁盘容错技术则是通过增加冗余的磁盘驱动器、磁盘控制器等，来提高磁盘系统的可靠性，从而构成实际上的稳定存储器系统。 </p>
<p>第一级容错技术SFT－I：<br>修复重定向：在磁盘中划出一部分作为热修复重定向区，存放坏磁道的待写数据<br>写后读校验：内存—（写）盘时，从盘读出与内存校验看是否一致，不一致，重写入热修复重定向区，标记坏盘块</p>
<p>第二级容错技术SFT-II：<br>磁盘镜像：增设一个完全相同的磁盘驱动器。<br>优点：磁盘驱动器发生故障时切换，仍能正常工作。<br>缺点：磁盘的利用率为50％。<br>磁盘双工(Disk Duplexing)：将两台磁盘驱动器分别接两个磁盘控制器。每个磁盘有自己独立的通道，可同时将数据写入，加块数据读取速度。</p>
<p>廉价磁盘冗余阵列：利用一磁盘阵列控制器，统一管理和控制一组磁盘驱动器，并行交叉存取，传输时间大大减少，RAID分级，可靠性高，磁盘I/O速度高，性能/价格比高。<br>最简单的RAID组织方式：镜像<br>最复杂的RAID组织方式：块交错校验</p>
<h2 id="7">数据一致性控制</h2>

<p>事务是用于访问和修改各种数据项的一个程序单位，也可以被看作是一系列相关读和写操作。</p>
<p>事务记录包含运行时数据修改的全部信息：</p>
<ul>
<li>事务名：用于标识该事务的惟一名字</li>
<li>数据项名：它是被修改数据项的惟一名字</li>
<li>旧值：修改前数据项的值</li>
<li>新值：修改后数据项将具有的值</li>
</ul>
<p>恢复算法：undo〈Ti〉：该过程把所有被事务Ti修改过的数据，恢复为修改前的值；redo〈Ti〉：该过程能把所有被事务Ti修改过的数据，设置为新值。</p>
<p>并发控制：<br>利用互斥锁实现“顺序性”<br>利用互斥锁和共享锁实现顺序性</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;操作系统中文件管理功能的概述。&lt;br&gt;
    
    </summary>
    
      <category term="操作系统" scheme="http://www.codingbalian.online/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="文件管理" scheme="http://www.codingbalian.online/tags/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>操作系统:设备管理</title>
    <link href="http://www.codingbalian.online/2017/01/05/OS-Device%20Management/"/>
    <id>http://www.codingbalian.online/2017/01/05/OS-Device Management/</id>
    <published>2017-01-05T09:15:14.000Z</published>
    <updated>2017-01-06T08:17:17.426Z</updated>
    
    <content type="html"><![CDATA[<p>介绍I/O设备的管理<br><a id="more"></a></p>
<h2 id="1">I/O概述</h2>

<ol>
<li>I/O性能经常成为系统性能的瓶颈</li>
<li>操作系统庞大复杂的原因之一是：资源多、杂，并发，均来自I/O</li>
<li>理解I/O的工作过程与结构是理解操作系统的工作过程与结构的关键</li>
<li>与其他功能联系密切，特别是文件系统</li>
</ol>
<p>对于不同规模的计算机系统，其I/O系统的结构也有所差异。通常分为两类：</p>
<ul>
<li>微型机I/O系统<ul>
<li>多采用总线I/O系统结构。</li>
<li>CPU通过设备控制器与I/O设备通信。</li>
<li>不同的设备配置相应的控制器。</li>
</ul>
</li>
<li>主机I/O系统<ul>
<li>增加一级I/O通道，用以代替CPU与各设备控制器通信。</li>
<li>四级结构。</li>
</ul>
</li>
</ul>
<h3 id="1.1">设备分类</h3>

<ul>
<li>按使用特性分<ul>
<li>存储型设备</li>
<li>输入型设备（外设→主机）</li>
<li>输出型设备（主机→外设）</li>
<li>输入输出型设备（交互型设备）</li>
</ul>
</li>
<li>按信息交换单位分<ul>
<li>块设备：用于存储信息。基本特征是其传输速率较高，可寻址，可随机地读/写</li>
<li>字符设备：以字符为单位存储、传输信息；传输速率较低；不可寻址</li>
</ul>
</li>
<li>按外部设备的从属关系分<ul>
<li>系统设备：操作系统生成时，登记在系统中的标准设备</li>
<li>用户设备：系统生成时，未登记在系统中的非标准设备。对于这类设备的处理程序由用户提供，并将其纳入系统，由系统代替用户实施管理。</li>
</ul>
</li>
<li>虚设备<ul>
<li>在一类设备上模拟另一类设备，常用共享设备模拟独占设备，用高速设备模拟低速设备，被模拟的设备称为虚设备</li>
<li>将慢速的独占设备改造成多个用户可共享的设备，提高设备的利用率</li>
</ul>
</li>
</ul>
<blockquote>
<p>SPOOLing技术<br>为解决独立设备数量少，速度慢，不能满足众多进程的要求，而且在进程独占设备期间，设备利用率比较低而提出的一种设备管理技术</p>
</blockquote>
<ul>
<li>从程序使用角度分<ul>
<li>逻辑设备</li>
<li>物理设备</li>
</ul>
</li>
<li>按数据传输率分<ul>
<li>第一类是低速设备，这是指其传输速率仅为每秒钟几个字节至数百个字节的一类设备。典型设备有键盘、鼠标、语音的输入和输出等设备。</li>
<li>第二类是中速设备，这是指其传输速率在每秒钟数千个字节至数万个字节的一类设备。典型设备有行式打印机、激光打印机等。</li>
<li>第三类是高速设备， 这是指其传输速率在数百千个字节至数十兆字节的一类设备。 典型设备有磁带机、 磁盘机、 光盘机等。 </li>
</ul>
</li>
</ul>
<h3 id="1.2">I/O请求处理</h3>

<p>I/O请求过程：用户进程→独立于设备的软件→设备驱动程序→中断处理程序→硬件</p>
<ol>
<li>用户进程层执行输入输出系统调用，对I／O数据进行格式化，为假脱机输入／输出作准备</li>
<li>独立于设备的软件实现设备的命名、设备的保护、成块处理、缓冲技术和设备分配</li>
<li>设备驱动程序设置设备寄存器、检查设备的执行状态</li>
<li>中断处理程序负责I／O完成时，唤醒设备驱动程序进程，进行中断处理</li>
<li>硬件层实现物理I／O的操作</li>
</ol>
<h3 id="1.3">中断处理程序</h3>

<ol>
<li>每个进程在启动一个I／O操作后阻塞 </li>
<li>直到I／O操作完成并产生一个中断</li>
<li>由操作系统接管CPU后唤醒该进程为止</li>
</ol>
<h3 id="1.4">设备驱动程序</h3>

<ul>
<li>与设备密切相关的代码放在设备驱动程序中，每个设备驱动程序处理一种设备类型</li>
<li>每一个控制器都设有一个或多个设备寄存器，用来存放向设备发送的命令和参数。设备驱动程序负责释放这些命令，并监督它们正确执行</li>
<li>设备驱动程序的任务是接收来自与设备无关的上层软件的抽象请求，并执行这个请求</li>
</ul>
<h3 id="1.5">设备独立的软件</h3>

<p>虽然I／O软件中一部分是设备专用的，但大部分软件是与设备无关的。设备驱动程序与设备独立软件之间的确切界限是依赖于具体系统的。<br>独立于设备的软件的基本任务是实现所有设备都需要的功能，并且向用户级软件提供一个统一的接口。</p>
<h3 id="1.6">用户空间的I／O软件</h3>

<p>有一小部分I/O软件是由与用户程序连接在一起的库过程，甚至完全由运行于核外的程序构成。系统调用，包括I／O系统调用，通常由库过程实现。<br>这些过程所做的工作只是将系统调用时所用的参数放在合适的位置。</p>
<h2 id="2">I/O硬件特点</h2>

<h3 id="2.1">I/O设备组成</h3>

<ul>
<li>物理设备:设备本身</li>
<li>设备控制器:完成设备与主机间的连接和通讯</li>
</ul>
<h3 id="2.2">I/O过程</h3>

<ol>
<li>准备</li>
<li>启动</li>
<li>测试和等待</li>
<li>结果检查和错误处理</li>
<li>通过对设备接口寄存器组的读写完成</li>
</ol>
<ul>
<li>操作系统将命令写入控制器寄存器中，以实现输入／输出</li>
<li>当控制器接受一条命令后，可独立于CPU完成指定操作，CPU可以转去执行其它运算</li>
<li>命令完成时，控制器产生一个中断，CPU响应中断，控制转给操作系统。CPU通过读控制器寄存器中的信息，获得操作结果和设备状态</li>
<li>控制器与设备之间的接口常常是一个低级接口</li>
<li>控制器的任务是把串行的位流转换为字节块，并进行必要的错误修正。首先，控制器按位进行组装，然后存入控制器内部的缓冲区中形成以字节为单位的块。在对块验证检查和并证明无错误时，再将它复制到主存中</li>
</ul>
<h2 id="3">I/O控制技术</h2>

<ul>
<li>程序控制</li>
<li>中断驱动</li>
<li>直接存储器存取（DMA）</li>
<li>通道</li>
</ul>
<p>目的：减少CPU对I/O控制的干预，提高CPU与I/O设备的并行度</p>
<h3 id="3.1">程序控制I/O技术</h3>

<p>又称忙－等待方式。<br>由处理器提供I/O相关指令来实现:</p>
<ul>
<li>I/O处理单元处理请求并设置I/O状态寄存器相关位</li>
<li>处理器定期轮询I/O单元的状态，直到处理完毕</li>
</ul>
<p>主要缺陷：</p>
<ul>
<li>处理器必须不断关注I/O处理单元的状态，因而耗费大量时间轮询信息，严重地降低了系统性能</li>
<li>在程序I/O方式中，由于CPU的高速性和I/O设备的低速性， 致使CPU的绝大部分时间都处于等待I/O设备完成数据I/O的循环测试中， 造成对CPU的极大浪费</li>
</ul>
<h3 id="3.2">中断驱动I/O技术</h3>

<p>将处理器从轮询任务中解放出来，使I/O操作和指令执行并行起来。<br>当某进程要启动某个I/O设备时，便由CPU向相应的设备控制器发出一条命令，然后立即返回继续执行原来的任务。设备控制器按照该命令控制I/O设备。此时，CPU和I/O设备并行工作。</p>
<h3 id="3.3">DMA技术</h3>

<p>当处理器和I/O间传送数据时，每完成一个字节，控制器便向CPU请求一次中断效率太低。为此，数据可以成块传送,通过系统总线中一独立控制单元——DMA控制器，完成直接存储器访问（DMA：Direct Memory Access）。</p>
<p>DMA方式的特点：</p>
<ol>
<li>数据传输的基本单位是数据块，即在CPU与I/O设备之间，每次传送至少一个数据块；</li>
<li>所传送的数据是从设备直接送入内存的，或者相反； </li>
<li>仅在传送一个或多个数据块的开始和结束时，才需CPU干预，整块数据的传送是在控制器的控制下完成的。</li>
</ol>
<p>可见，DMA方式较之中断驱动方式，又是成百倍地减少了CPU对I/O的干预，进一步提高了CPU与I/O设备的并行操作程度。 </p>
<p>DMA控制器：</p>
<ul>
<li>命令/状态寄存器CR：用于接收从CPU发来的I/O命令或有关控制信息， 或设备的状态。</li>
<li>内存地址寄存器MAR：在输入时，它存放把数据从设备传送到内存的起始目标地址；在输出时，它存放由内存到设备的内存源地址。</li>
<li>数据寄存器DR：用于暂存从设备到内存，或从内存到设备的数据。</li>
<li>数据计数器DC：存放本次CPU要读或写的一个字(节)</li>
</ul>
<h3 id="3.4">通道</h3>

<p>I/O通道方式是DMA方式的发展，它可进一步减少CPU的干预，即把对一个数据块的读(或写)为单位的干预，减少为对一组数据块的读(或写)及有关的控制和管理为单位的干预。 同时，又可实现CPU、通道和I/O设备三者的并行操作，从而更有效地提高整个系统的资源利用率。</p>
<h2 id="4">设备有关技术</h2>

<h3 id="4.1">Spooling（虚拟设备）技术</h3>

<p>为了缓和CPU的高速性与I/O设备低速性间的矛盾而引入了脱机输入、脱机输出技术。该技术是利用专门的外围控制机， 将低速I/O设备上的数据传送到高速磁盘上。<br>在多道系统中，完全可以利用其中的一道程序，来模拟脱机输入时的外围控制机功能，把低速I/O设备上的数据传送到高速磁盘上；再用另一道程序来模拟脱机输出时外围控制机的功能，把数据从磁盘传送到低速输出设备上。这样，便可在主机的直接控制下，实现脱机输入、输出功能。此时的外围操作与CPU对数据的处理同时进行，我们把这种在联机情况下实现的同时外围操作称为SPOOLing(Simultaneaus Periphernal Operating On-Line)，或称为假脱机操作。</p>
<p>特点：</p>
<ul>
<li>提高了I/O的速度。 </li>
<li>将独占设备改造为共享设备。 </li>
<li>实现了虚拟设备功能。 </li>
</ul>
<h3 id="4.2">中断技术</h3>

<p>中断的概念：<br>CPU对系统发生的某个事件作出的一种反应<br>CPU暂停正在执行的程序，保留现场后自动转去执行相应事件的处理程序，处理完成后返回断点，继续执行被打断的程序<br>特点：</p>
<ol>
<li>中断随机的</li>
<li>中断是可恢复的</li>
<li>中断是自动处理的</li>
</ol>
<p>引入中断的目的:<br>解决主机与外设的并行工作问题<br>提高可靠性<br>实现多机联系<br>实现实时控制</p>
<p>强迫性中断:正在运行的程序所不期望的，由于某种硬件故障或外部请求引起的</p>
<ul>
<li>输入/输出(I/O)中断：主要来自外部设备通道</li>
<li>程序性中断：运行程序中本身的中断(如溢出,缺页中断,缺段中断,地址越界)</li>
<li>时钟中断</li>
<li>控制台中断</li>
<li>硬件故障</li>
</ul>
<p>自愿性中断：用户在程序中有意识安排的中断，是由于用户在编制程序时因为要求操作系统提供服务，有意使用“访管”指令或系统调用，使中断发生</p>
<ul>
<li>执行I/O</li>
<li>创建进程</li>
<li>分配内存</li>
<li>信号量操作</li>
<li>发送/接收消息</li>
</ul>
<p>微机中的中断：</p>
<ol>
<li>可屏蔽中断（I/O中断）</li>
<li>不可屏蔽中断（机器内部故障、掉电中断）</li>
<li>程序错误中断（溢出、除法错等中断）</li>
<li>软件中断（Trap指令或中断指令INT）</li>
</ol>
<p>中断寄存器：</p>
<ul>
<li>有的计算机中，为了区分和不丢失中断信号，对应每个中断源分别用一固定触发器寄存中断信号规定值为1时，表示有中断信号，为0时表示无</li>
<li>这些触发器的全体称为中断寄存器</li>
<li>每个触发器称为一个中断位</li>
<li>所有中断寄存器是由若干个中断位组成</li>
</ul>
<p>中断优先级：</p>
<ul>
<li>以机器故障中断的优先级最高 </li>
<li>程序中断和访问管理程序中断次之</li>
<li>外部中断更次之 </li>
<li>输入输出的优先级最低</li>
</ul>
<p>中断屏蔽：<br>在CPU上运行的程序，有时由于种种原因，不希望其在执行过程中被别的事件所中断，称为中断屏蔽。<br>在PSW中设置中断屏蔽码以屏蔽某些指定的中断类型，各设备接口中也有中断禁止位，以禁止该设备的中断。</p>
<p>实时处理的中断：<br>把具有重要意义传感器发出的中断作为高优先级，中断优先级的设计是灵活可变的，允许用户根据应用需要，选择不同中断优先策略。</p>
<p>中断处理：</p>
<ol>
<li>设备给处理器发一个中断信号</li>
<li>处理器处理完当前指令后响应中断，延迟非常短</li>
<li>处理器处理完当前指令后检测到中断，判断出中断来源并向发送中断的设备发送了确认中断信号，确认信号使得该设备将中断信号恢复到一般状态</li>
<li>处理器开始为软件处理中断做准备：保存中断点的程序执行上下文环境，这通常包括程 序状态字PSW，程序计数器PC中的下一条指令位置，一些寄存器的值，它们通常保存在系统控制栈中,处理器状态被切换到管态</li>
<li>处理器根据中断源查询中断向量表，获得与该中断相联系的处理程序入口地址，并将PC置成该地址，处理器开始一个新的指令周期，控制转移到中断处理程序</li>
<li>中断处理程序开始工作，包括检查I/O相关的状态信息，操纵I/O设备或者在设备和主存之间传送数据</li>
<li>中断处理结束时，处理器检测到中断返回指令，被中断程序的上下文环境从系统堆栈中被恢复，处理器状态恢复成原来的状态</li>
<li>PSW和PC被恢复成中断前的值，处理器开始一个新的指令周期，中断处理结束</li>
</ol>
<p>多个中断（中断处理过程中又发生中断，引起多中断处理问题）的处理：<br>第一种：处理一个中断时禁止中断，对任何新中断置之不理，在这期间发生的中断将保持挂起状态；当再次允许中断时，新中断信号被处理器检测到<br>软件实现方法：</p>
<ul>
<li>在任何中断处理前使用禁止中断指令</li>
<li>在处理结束后开放中断指令</li>
<li>所有中断严格按照发生顺序处理</li>
<li>不考虑中断紧急程度，无法达到较严格时间要求</li>
</ul>
<p>第二种：</p>
<ul>
<li>中断按照优先度分级</li>
<li>允许优先级高中断打断优先级低的中断处理过程，这样中断优先级技术将引起中断处理的嵌套</li>
<li>只要合适地定义中断的优先级别，方法一的弊端大都可以克服</li>
</ul>
<h3 id="4.3">典型的中断处理</h3>

<ol>
<li><p>I/O中断:由I/O设备的控制器或者通道发出</p>
<ul>
<li>I/O操作正常结束:如果要继续I/O操作，需要在准备好以后重新启动I/O，若请求I/O程序正处于等待I/O状态，则应将其唤醒</li>
<li>I/O异常:需要重新执行失败的I/O操作,重试次数有上限，次数过大，系统将判定硬件故障</li>
</ul>
</li>
<li><p>时钟中断:中断处理程序通常做与系统运转、管理和维护相关的工作</p>
<ul>
<li>维护软件时钟：系统有若干个软件时钟，控制定时任务以及进程的处理器时间配额，时钟中断需要维护、定时更新这些软件时钟</li>
<li>处理器时间调度：维护当前进程时间片软件时钟，并在当前进程时间片到时以后运行调度程序选择下一个被调度的进程</li>
<li>控制系统定时任务：通过软件时钟和调度程序定时激活一些系统任务，如监测死锁、系统记帐、系统审计等</li>
<li>实时处理</li>
</ul>
</li>
<li><p>硬件故障中断</p>
<ul>
<li>保存现场，使用一定警告手段，提供些辅助诊断信息</li>
<li>在高可靠系统中，中断处理程序还要评估系统可用性，尽可能恢复系统</li>
</ul>
</li>
<li><p>程序性中断:程序指令出错、指令越权或者指令寻址越界而引发两类处理方法</p>
<ul>
<li>只能由操作系统的相关扩展功能模块完成,多为程序试图作不能做的操作引起的系统保护</li>
<li>可由程序自己完成</li>
<li>系统调试中断（断点中断、单步跟踪）也可被用户程序处理，用以支持各种程序调试</li>
</ul>
</li>
<li><p>系统服务请求（自愿性中断）:系统服务请求由处理器专用指令（访管指令）激发</p>
<ul>
<li>执行专用指令的结果是系统被切换到管态，并且转移到一段专门OS程序处开始执行</li>
<li>指令格式通常是指令名加请求服务识别号（中断号）</li>
<li>OS利用处理器提供的这种接口建立系统服务体系</li>
<li>处理器一般不负责定义系统调用所传递的参数格式</li>
</ul>
</li>
</ol>
<h3 id="4.4">通道技术</h3>

<p>通道又称输入输出处理机，通道是一个比CPU功能较弱、速度较慢、价格较为便宜的处理机，但“通道”一词在微型机中常指与DMA或与I/O处理机相连设备的单纯的数据传送通路，它并不具有处理机的功能。</p>
<p>引入通道的目的：提高CPU与设备，设备与设备之间的并行工作能力<br>通道类型：</p>
<ul>
<li>字节多路通道:通常按字节交叉的方式工作，适用于低速I/O设备。</li>
<li>数据选择通道:按成组方式进行数据传输，适用于高速I/O设备。</li>
<li>数组多路通道:综合前二个优点（数据传送率和通道利用率都较高）。</li>
</ul>
<p>通道工作原理:包含通道指令（空操作，读操作，写操作，控制，转移操作），并可执行用这些指令编写的通道程序<br>通道运算控制部件:</p>
<ul>
<li>通道地址字CAW：记录通道程序在内存中的地址</li>
<li>通道命令字CCW：保存正在执行的通道指令</li>
<li>通道状态字CSW：存放通道执行后的返回结果</li>
<li>通道数据字CDW：存放传输数据通道和CPU共用内存，通过周期窃取方式取得</li>
</ul>
<p>通道命令：用于I/O操作的命令主要有：</p>
<ol>
<li>I/O指令：启动通道程序</li>
<li>通道命令：对I/O操作进行控制：读、反读、写、测试设备状态的数据传输命令、用于设备控制的命令（磁带反绕、换页）、实现通道程序内部控制的转移命令</li>
</ol>
<p>工作原理：</p>
<ul>
<li>CPU：执行用户程序，当遇到I/O请求时，可根据该请求生成通道程序放入内存（也可事先编好放入内存），并将该通道程序的首地址放入CAW中；之后执行“启动I/O”指令，启动通道工作。</li>
<li>通道：接收到“启动I/O”指令后，从CAW中取出通道程序的首地址，并根据首地址取出第一条指令放入CCW中，同时向CPU发回答信号，使CPU可继续执行其他程序，而通道则开始执行通道程序，完成传输工作。</li>
</ul>
<p>通道与CPU的关系：</p>
<ul>
<li>主从关系</li>
<li>可并行工作</li>
<li>有通信方式</li>
<li>作用不同</li>
</ul>
<h3 id="4.5">DMA技术</h3>

<p>DMA 方式与中断的主要区别：<br>中断方式是在数据缓冲寄存区满后，发中断请求，CPU进行中断处理<br>DMA方式则是在所要求传送的数据块全部传送结束时要求CPU进行中断处理，大大减少了CPU进行中断处理的次数<br>中断方式的数据传送是由CPU控制完成的<br>而DMA方式则是在DMA控制器的控制下不经过CPU控制完成的</p>
<p>DMA工作示例</p>
<ol>
<li>CPU提供被读取块磁盘地址；目标存储地址；待读取字节数</li>
<li>整块数据读进缓冲区，核准校验</li>
<li>控制器按照指定存储器地址，把第一个字节送入主存，按指定字节数进行数据传送</li>
<li>每当传送一个字节后，字节计数器值减1，直到字节计数器等于0</li>
<li>控制器引发中断，通知操作系统，操作完成</li>
</ol>
<p>DMA工作原理：</p>
<ul>
<li>存放输入数据的内存起始地址、要传送的字节数送入DMA控制器的内存地址寄存器和传送字节计数器，中断允许位和启动位置成1，启动设备</li>
<li>发出传输要求的进程进入等待状态</li>
<li>执行指令被暂时挂起，进程调度其他进程占据CPU</li>
<li>输入设备不断窃取CPU工作周期，数据不断写入内存</li>
<li>传送完毕，发出中断信号</li>
<li>CPU接到中断信号转入中断处理程序处理</li>
<li>中断处理结束，CPU返回原进程或切换到新的进程</li>
</ul>
<h3 id="4.6">缓冲技术</h3>

<p>缓冲区是有一定容量、暂存信息的存贮装置。凡是数据到达和离去速度不匹配的地方均可使用缓冲区。在操作系统中采用缓冲是为了实现数据的I/O操作，以缓解CPU与外部设备之间速度不匹配的矛盾，提高资源利用率。</p>
<p>引入缓冲区的优点：</p>
<ul>
<li>提高硬件的并行操作能力</li>
<li>减少了I/O设备对处理器的中断请求次数</li>
<li>简化了中断机制</li>
<li>节省了系统开销</li>
</ul>
<p>缺点：</p>
<ul>
<li>在系统区要设置相当大的缓冲池才能满足所有的Ｉ／Ｏ请求</li>
<li>从系统缓冲区传送数据到调用进程缓冲区要花费额外的时间，增加了系统的总开销</li>
</ul>
<p>缓冲区设置：</p>
<ul>
<li>硬缓冲：设备中设置</li>
<li>软缓冲：内存中使用一定的空间作为缓冲区</li>
</ul>
<p>缓冲技术：</p>
<ol>
<li>单缓冲：只设置一个缓冲区，效率低</li>
<li>双缓冲：设置两个缓冲区，交替使用，但不适用于速度差距大的交流</li>
<li>循环缓冲：多个缓冲按顺序构成环形，先进先出队列的形式，设头尾、指针指向同一个缓冲区。头、尾指针读写时不能相互超越</li>
<li>缓冲池：为多个设备共享，设备需要时才接上，用完归还<ul>
<li>空(闲)缓冲区：链成队列空缓冲队列emq</li>
<li>装满输入数据的缓冲区：链成队列输入队列inq</li>
<li>装满输出数据的缓冲区：链成队列输出队列outq</li>
<li>收容输入数据的工作缓冲区</li>
<li>提取输入数据的工作缓冲区</li>
<li>收容输出数据的工作缓冲区</li>
<li>提取输出数据的工作缓冲区</li>
</ul>
</li>
</ol>
<h3 id="4.7">总线与USB技术</h3>

<p>在计算机系统内各种子系统间构建公用的信号或数据传输通道，这种可共享连接的传输通道称为总线。<br>I/O总线分为数据总线、地址总线、控制总线。<br>USB（Universal Serial Bus）通用串行总线，是一种连接I/O串行设备的技术标准。</p>
<p>USB的结构：</p>
<ul>
<li>控制器：控制器主要负责执行由控制器驱动程序发出的命令</li>
<li>控制器驱动程序：控制器驱动程序在控制器与USB设备之间建立通信信道</li>
<li>USB芯片驱动程序：USB芯片驱动程序提供了对USB的支持</li>
</ul>
<p>USB的传输方式：</p>
<ul>
<li>等时传输方式：以固定的传输速率，连续不断传输数据，发生错误时，USB不处理，而是继续传送新的数据。</li>
<li>中断传输方式：该方式传送的数据量很小，但这些数据需要及时处理</li>
<li>控制传输方式：处理主机的USB设备的数据传输，包括设备控制指令、设备状态查询及确认命令，先进先出原则</li>
<li>批传输方式：用来传输要求正确无误的数据</li>
</ul>
<h2 id="5">设备分配与设备处理</h2>

<h3 id="5.1">设备分配与回收</h3>

<p>当某进程向系统提出I/O请求时，设备分配程序按一定策略分配设备、控制器和通道，形成一条数据传输通路，以供主机和设备间信息交换。</p>
<p>设备管理程序对I/O设备进行分配和控制是借助于一些表格；表格中记录了对I/O设备控制所需之信息。它们是设备管理程序实现管理功能的数据结构。</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>设备控制表（DCT）</td>
<td>每个设备一个</td>
</tr>
<tr>
<td>控制器表（COCT）</td>
<td>每个控制器一个</td>
</tr>
<tr>
<td>通道表（CMCT）</td>
<td>每个通道一个</td>
</tr>
<tr>
<td>系统设备表（SDT）</td>
<td>整个系统一个</td>
</tr>
</tbody>
</table>
<h3 id="5.2">设备分配策略</h3>

<p>独占设备的分配:要考虑充分发挥效率，避免由于不合理的分配策略造成死锁。</p>
<ul>
<li>静态分配：在进程运行前, 完成设备分配；运行结束时，收回设备,设备利用率低</li>
<li>动态分配：在进程运行过程中，当用户提出设备要求时，进行分配，一旦停止使用立即收回,效率高，但分配策略不好时, 产生死锁</li>
</ul>
<p>共享设备分配：考虑多个访问请求到达时服务的顺序，使平均服务时间越短越好。</p>
<p>I/O设备的分配算法：先请求先服务；优先权最高者优先</p>
<p>与设备无关性：逻辑设备与物理设备区分使用联系逻辑设备名称和物理设备名称的映射表(LUT)</p>
<p>设备分配程序:根据用户请求的I/O设备的逻辑名，查找逻辑设备和物理设备的映射表；以物理设备为索引，查找SDT，找到该设备所连接的DCT；继续查找与该设备连接的COCT和CHCT，就找到了一条通路。即：分配设备 －&gt;分配控制器-&gt;分配通道</p>
<h3 id="5.3">设备处理</h3>

<p>设备处理程序通常又称为设备驱动程序，它是I/O进程与设备控制器之间的通信程序。</p>
<p>设备处理方式：</p>
<ul>
<li>为每一类设备设置一个进程，专门用于执行这类设备的I/O操作</li>
<li>在整个系统中设置一个I/O进程，专门用于执行系统中所有各类设备的I/O操作</li>
<li>不设置专门的设备处理进程，而只为各类设备设置相应的设备处理程序(模块)，供用户进程或系统进程调用</li>
</ul>
<p>设备驱动程序的功能：</p>
<ol>
<li>接收由I/O进程发来的命令和参数，并将命令中的抽象要求转换为具体要求</li>
<li>检查用户I/O请求的合法性，了解I/O设备的状态，传递有关参数，设置设备的工作方式</li>
<li>发出I/O命令，如果设备空闲，便立即启动I/O设备去完成指定的I/O操作；如果设备处于忙碌状态，则将请求者的请求块挂在设备队列上等待</li>
<li>及时响应由控制器或通道发来的中断请求，并根据其中断类型调用相应的中断处理程序进行处理</li>
<li>对于设置有通道的计算机系统，驱动程序还应能够根据用户的I/O请求，自动地构成通道程序</li>
</ol>
<p>设备驱动程序的特点:</p>
<ol>
<li>驱动程序主要是指在请求I/O的进程与设备控制器之间的一个通信和转换程序</li>
<li>驱动程序与设备控制器和I/O设备的硬件特性紧密相关，因而对不同类型的设备应配置不同的驱动程序。 </li>
<li>驱动程序与I/O设备所采用的I/O控制方式紧密相关。 </li>
<li>由于驱动程序与硬件紧密相关，因而其中的一部分必须用汇编语言书写。 </li>
</ol>
<p>设备驱动程序的处理过程:</p>
<ol>
<li>将抽象要求转换为具体要求 </li>
<li>检查I/O请求的合法性</li>
<li>读出和检查设备的状态 </li>
<li>传送必要的参数 </li>
<li>工作方式的设置 </li>
<li>启动I/O设备 </li>
</ol>
<h2 id="6">磁盘存储器管理</h2>

<p>磁盘存储器管理的目的：</p>
<ul>
<li>为文件分配存储空间</li>
<li>合理地组织文件地存储方式，以提高访问速度</li>
<li>提高磁盘存储空间地利用率</li>
<li>提高磁盘I/O速度，改善文件性能</li>
<li>确保文件系统的可靠性（备份）</li>
</ul>
<p>磁盘高速缓存的形式 ：</p>
<ol>
<li>在内存中开辟一个单独的存储空间来作为磁盘高速缓存，其大小是固定的，不会受应用程序多少的影响</li>
<li>把所有未利用的内存空间变为一个缓冲池，供请求分页系统和磁盘I/O时(作为磁盘高速缓存)共享。此时高速缓存的大小，显然不再是固定的。当磁盘I/O的频繁程度较高时，该缓冲池可能包含更多的内存空间；而在应用程序运行得较多时，该缓冲池可能只剩下较少的内存空间</li>
</ol>
<p>数据交付方式：</p>
<ul>
<li>数据交付：这是直接将高速缓存中的数据，传送到请求者进程的内存工作区中</li>
<li>指针交付：只将指向高速缓存中某区域的指针交付给请求者进程</li>
</ul>
<p>提高磁盘I/O速度的方法：</p>
<ol>
<li>提前读(Read-Ahead) </li>
<li>延迟写 </li>
<li>优化物理块的分布 </li>
<li>虚拟盘 </li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍I/O设备的管理&lt;br&gt;
    
    </summary>
    
      <category term="操作系统" scheme="http://www.codingbalian.online/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="设备管理" scheme="http://www.codingbalian.online/tags/%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>操作系统：处理机调度与死锁</title>
    <link href="http://www.codingbalian.online/2017/01/04/OS-Deadlock/"/>
    <id>http://www.codingbalian.online/2017/01/04/OS-Deadlock/</id>
    <published>2017-01-04T08:43:56.000Z</published>
    <updated>2017-01-09T14:27:18.583Z</updated>
    
    <content type="html"><![CDATA[<p>关于死锁的简单内容。<br><a id="more"></a></p>
<h2 id="1">处理机调度</h2>

<h3 id="1.1">高级、中级和低级调度</h3>

<ul>
<li>高级调度：也称为作业调度或长程调度，决定将外存上处于后备队列中的哪些作业调入内存，并为它们创建进程，排入就绪队列，准备执行。作业调度的时间尺度通常是分钟级。</li>
<li>低级调度：也称进程调度、短程调度，它决定就绪队列中的哪个进程获得处理机。进程调度的时间尺度通常是毫秒级的。      </li>
<li>中级调度：也称中程调度。引入中级调度的主要目的，是为了提高内存利用率和系统吞吐量。 </li>
</ul>
<p>中级调度的实现：把暂时不能运行的进程调至外存等待，此时的进程状态称为就绪驻外存状态或挂起状态。当又具备运行条件、且内存又稍有空闲时，由中级调度来决定把外存上的就绪进程重新调入内存，并修改其状态为就绪状态，挂在就绪队列上等待调度。涉及进程在内外存间的交换。</p>
<h3 id="1.2">进程调度的作用</h3>

<p>使用调度算法从就绪队列中选中一个进程，把CPU的使用权交给被选中的进程</p>
<h3 id="1.3">确定算法原则</h3>

<ul>
<li>公平性</li>
<li>资源利用率高</li>
</ul>
<h3 id="1.4">进程调度方式</h3>

<ul>
<li>非剥夺方式：分派程序把处理机分配给进程后便让它一直运行下去，直到进程完成或发生某事件而阻塞时，才把处理机分配给另一个进程。</li>
<li>剥夺方式：当一个进程正在运行时，系统可以基于某种原则，剥夺已分配给它的处理机，将之分配给其它进程。剥夺原则有：优先权原则、短进程优先原则、时间片原则。</li>
</ul>
<h3 id="1.5">进程调度性能衡量的指标</h3>

<ul>
<li>周转时间</li>
<li>响应时间</li>
<li>CPU-I/O执行期</li>
</ul>
<h3 id="1.6">调度准则</h3>

<ul>
<li>面向用户的准则：<ul>
<li>周转时间短，即作业从提交到完成（作业的周转时间T与系统为它提供服务的时间TS之比，即W=T/TS，称为带权周转时间）</li>
<li>响应时间快</li>
<li>截止时间的保证</li>
<li>优先权准则</li>
</ul>
</li>
<li>面向系统的准则：<ul>
<li>系统吞吐量高</li>
<li>处理机利用率好</li>
<li>各类资源的平衡利用</li>
</ul>
</li>
</ul>
<h2 id="2">进程调度算法</h2>

<h3 id="2.1">先进先出(FIFO)算法</h3>

<p>把处理机分配给最先进入就绪队列的进程，一个进程一旦分得处理机，便执行下去，直到该进程完成或阻塞时，才释放处理机。<br>优点:实现简单,有利于长作业,CPU繁忙型作业<br>缺点:没考虑进程的优先级,不利于I/O繁忙型作业</p>
<h3 id="2.2">短作业(进程)优先调度算法</h3>

<ul>
<li>短作业优先(SJF)的调度算法:从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行</li>
<li>短进程优先(SPF)调度算法:从就绪队列中选出一估计运行时间最短的进程，使它立即执行</li>
</ul>
<p>缺点：对长作业不利；不能保证紧迫性作业(进程)会被及时处理；根据用户估计可能存在错误</p>
<h3 id="2.3">最高优先权优先调度算法</h3>

<p>把处理机分配给就绪队列中具有最高优先权的进程。<br>决定优先权的方法：</p>
<ol>
<li>静态优先数法：静态优先权是在创建进程时确定的，在整个运行期间不再改变。依据有：进程类型；进程对资源的要求；用户要求的优先权。</li>
<li>动态优先数法：在进程创建时创立一个优先数，但在其生命周期内优先权可以随进程的推进或随其等待时间的增加而改变的，以便获得更好的调度性能。</li>
</ol>
<h3 id="2.4">高响应比优先调度算法</h3>

<p>$$优先权={等待时间+要求服务时间 \over 要求服务时间}={响应时间  \over 要求服务时间}$$</p>
<p>特点：</p>
<ol>
<li>作业等待时间相同，要求服务的时间愈短，其优先权愈高，有利于短作业</li>
<li>要求服务的时间相同时，等待时间愈长，其优先权愈高，因而它实现的是先来先服务</li>
<li>对于长作业，作业的优先级随等待时间的增加而提高，当其等待时间足够长时，其优先级便可升到很高， 从而也可获得处理机。  </li>
</ol>
<h3 id="2.5">转轮法</h3> 

<p>把CPU划分成若干时间片,并且按顺序赋给就绪队列中的每一个进程，进程轮流占有CPU，当时间片用完时，即使进程未执行完毕，系统也剥夺该进程的CPU，将该进程排在就绪队列末尾。同时系统选择另一个进程运行。</p>
<p>简单轮转法：系统将所有就绪进程按FIFO规则排队，按一定的时间间隔把处理机分配给队列中的进程。<br>多级队列方法：将系统中所有进程分成若干类，每类为一级。<br>时间片选择：固定时间片；可变时间片<br>与时间片大小有关的因素：系统响应时间(正比);就绪进程个数(反比);CPU能力 </p>
<h3 id="2.6">多队列反馈调度算法</h3> 

<ul>
<li>系统中设置多个就绪队列，并为各个队列赋予不同的优先级。第一个队列的优先级最高，第二个队列次之，其余各队列的优先权逐个降低</li>
<li>每个就绪队列分配给不同时间片，优先级高的为第一级队列，时间片最小，随着队列级别的降低，时间片加大</li>
<li>各个队列按照先进先出调度算法</li>
<li>一个新进程就绪后进入第一级队列</li>
<li>进程由于等待而放弃CPU后，进入等待队列，一旦等待的事件发生，则回到原来的就绪队列</li>
<li>当有一个优先级更高的进程就绪时，可以抢占CPU，被抢占进程回到原来一级就绪队列末尾</li>
<li>当第一级队列空时，就去调度第二级队列，如此类推</li>
<li>当时间片到后，进程放弃CPU，回到下一级队列，如此下去，一个长作业从第一队列依次降到第n队列</li>
</ul>
<h2 id="3">实时调度</h2>

<h3 id="3.1">基本条件</h3>

<ul>
<li>提供必要的信息(就绪时间、截止时间、处理时间、资源、优先级)</li>
<li>系统处理能力强</li>
<li>采用抢占式调度机制</li>
<li>具有快速切换机制</li>
</ul>
<h3 id="3.2">算法的分类</h3>

<ol>
<li>非抢占式调度算法:非抢占式轮转调度算法;非抢占式优先调度算法</li>
<li>抢占式调度算法:基于时钟中断的抢占优先调度算法;立即抢占优先权调度算法</li>
</ol>
<p>常用算法：<br>最早截止时间优先即EDF算法：只考虑了进程的截止时间，未考虑其运行时间<br>最低松弛度优先(LLF)算法：该算法是根据任务紧急(或松弛)的程度，来确定任务的优先级。该算法主要用于可抢占调度方式中。<br>松弛度=必须完成时间-其本身的运行时间-当前时间 </p>
<h3 id="3.2">多处理机系统中的调度</h3>

<ol>
<li>多处理器系统的类型<br>紧密耦合(Tightly Coupted)MPS:<br>通过高速总线或高速交叉开关，来实现多个处理器之间的互连的。它们共享主存储器系统和I/O设备，并要求将主存储器划分为若干个能独立访问的存储器模块，以便多个处理机能同时对主存进行访问。系统中的所有资源和进程，都由操作系统实施统一的控制和管理<br>松散耦合(Loosely Coupled)MPS:<br>通过通道或通信线路，来实现多台计算机之间的互连。每台计算机都有自己的存储器和I/O设备，并配置了OS来管理本地资源和在本地运行的进程,每一台计算机都能独立地工作， 必要时可通过通信线路与其它计算机交换信息，以及协调它们之间的工作</li>
<li>对称多处理器系统:<br>系统中所包含的各处理器单元，在功能和结构上都是相同的<br>非对称多处理器系统:<br>在系统中有多种类型的处理单元， 它们的功能和结构各不相同，其中只有一个主处理器</li>
<li>进程分配方式:<br>对称多处理器系统中的进程分配方式：<br>静态分配(Static Assigenment)方式<br>动态分配(Dynamic Assgement)方式<br>非对称MPS中的进程分配方式</li>
<li>进程(线程)调度方式<br>自调度(Self-Scheduling)方式<br>成组调度(Gang Scheduling)方式</li>
</ol>
<h2 id="4">死锁</h2>

<h3 id="4.1">死锁的概念</h3>

<p>一组进程中，每个进程都无限等待被该组进程中另一进程所占有的资源，因而永远无法得到的资源，这种现象称为进程死锁，这一组进程就称为死锁进程。</p>
<h3 id="4.2">死锁的原因</h3>

<ol>
<li>竞争系统资源<br>竞争非剥夺性资源<br>竞争临时性资源<br>只可使用一次的资源<br>“申请–分配–使用–释放”模式</li>
<li>进程的推进顺序不当 </li>
</ol>
<p>在同时具备下列四个条件时，就会产生死锁:</p>
<ul>
<li>互斥条件（资源独占）<br>在一段时间内，一个资源只能由一个进程独占使用，若别的进程也要求该资源，则须等待，直至其占用者释放</li>
<li>请求和保持条件<br>允许进程在不释放其已分得资源的情况下请求并等待分配新的资源</li>
<li>不剥夺条件（不可强占）<br>进程所获得的资源在未使用完之前，不能被其它进程强行夺走，而只能由其自身释放</li>
<li>环路等待条件<br>存在一个等待进程集合，P0正在等待一个P1占用的资源，P1正在等待一个P2占用的资源，…，Pn正在等待一个由PO占用的资源</li>
</ul>
<h2 id="5">解决死锁</h2>

<h3 id="5.1">预防死锁</h3>

<ol>
<li>破坏请求和保持条件<br>资源一次性分配；要求每个进程在运行前必须一次性申请它所要求的所有资源，且仅当该进程所要资源均可满足时才给予一次性分配</li>
<li>破坏不可剥夺条件<br>可剥夺资源:某进程新的资源未满足时，释放已占有的资源</li>
<li>破坏环路等待条件<br>资源有序分配法；系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反</li>
</ol>
<p>缺点:影响系统性能</p>
<h3 id="5.2">避免死锁</h3>

<p>系统对进程发出的能够满足的资源申请进行动态检查，若分配后系统可能发生死锁，则不予分配，否则予以分配。这种方法把系统分为安全状态和不安全状态，安全状态就不会发生死锁。</p>
<p><strong>安全状态与不安全状态</strong><br>安全状态指系统能按某种进程顺序来为每个进程分配其所需资源，直至最大需求，使每个进程都可顺序完成。若不存在这样的序列，则为不安全状态。</p>
<p>使用银行家算法可避免死锁：<br>可利用资源向量Available:含m个元素代表每种资源可利用的数目<br>最大需求矩阵Max:n<em>m的矩阵，n代表进程，m代表对资源的最大需求<br>分配矩阵Allocation:n</em>m<br>需求矩阵Need:n*m<br>Need［i,j］=Max［i,j］-Allocation［i,j］<br>Requesti是进程Pi的请求向量</p>
<ol>
<li>Requesti［j］≤Need［i,j］</li>
<li>如果Requesti［j］≤Available［j］，下一步；否则，Pi等待</li>
<li>Available［j］∶=Available［j］-Requesti［j］;<br>Allocation［i,j］∶=Allocation［i,j］+Requesti［j］;<br>Need［i,j］∶=Need［i,j］-Requesti［j］;</li>
<li>系统执行安全性算法，检查资源分配后，系统是否处于安全状态，若安全则分配</li>
</ol>
<h3 id="5.3">死锁检测</h3>

<p>当为进程分配资源时，如果未采取任何限制措施，则必须提供死锁检测和解除功能:<br>允许死锁发生，操作系统不断监视系统进展情况，判断死锁是否发生。<br>一旦死锁发生则采取专门的措施，解除死锁并以最小的代价恢复操作系统运行。</p>
<p>检测时机：</p>
<ul>
<li>进程等待时检测</li>
<li>定时检测</li>
<li>系统资源利用率下降时检测</li>
</ul>
<h3 id="5.4">死锁解除</h3>

<ol>
<li>重新启动</li>
<li>撤消进程</li>
<li>剥夺资源</li>
<li>进程回退</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于死锁的简单内容。&lt;br&gt;
    
    </summary>
    
      <category term="操作系统" scheme="http://www.codingbalian.online/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="处理机" scheme="http://www.codingbalian.online/tags/%E5%A4%84%E7%90%86%E6%9C%BA/"/>
    
      <category term="调度" scheme="http://www.codingbalian.online/tags/%E8%B0%83%E5%BA%A6/"/>
    
      <category term="死锁" scheme="http://www.codingbalian.online/tags/%E6%AD%BB%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>JSP中Servlet的应用</title>
    <link href="http://www.codingbalian.online/2016/12/29/JSP-Servlet/"/>
    <id>http://www.codingbalian.online/2016/12/29/JSP-Servlet/</id>
    <published>2016-12-29T08:04:09.000Z</published>
    <updated>2017-01-02T05:49:03.965Z</updated>
    
    <content type="html"><![CDATA[<p>Servlet是Java编写的服务器端程序，动态的生成Web内容。<br><a id="more"></a></p>
<p></p><h2 id="1">Servlet包的构成</h2><br>Servlet由服务器进行加载，是实现javax.servlet.Servlet接口的对象。大多数Servlet通过GenericServlet或者HttpServlet类来扩展实现。<br>Servlet API包含于javax.servlet和javax.servlet.http两个包中。javax.servlet包中定义了所有Servlet类都必须实现的接口和类：<p></p>
<ul>
<li>interface ServletConfig：定义Servlet config 对象，由Servlet 引擎用在 Servlet 初始化时，向 Servlet 传递信息。</li>
<li>interface ServletContext：定义Servlet用于获取容器信息的方法。</li>
<li>interface ServletRequest：向服务器请求信息。</li>
<li>interface ServletResponse：响应客户端请求。</li>
<li>interface Servlet：定义了所有 Servlet 必须实现的方法。</li>
<li>interface SingleThreadModel:用于保证Servlet在任一时刻只处理一个请求。</li>
<li>class ServletInputStream:用于读取客户请求的二进制数据。</li>
<li>class ServletOutputStream:向客户发送二进制数据。</li>
<li>class GenericServlet:继承Servlet接口，定义了一个通用的，独立协议的Servlet。</li>
</ul>
<p>javax.servle.http包中定义了采用HTTP通信的HttpServlet类：</p>
<ul>
<li>interface HttpServletRequest：提供http请求。</li>
<li>interface HttpServletResponse：提供http相应。</li>
<li>interface HttpSession：用于标识客户端并存储有关客户信息。</li>
<li>interface HttpSessionAttributeListener：需要用户获取回话的属性列表实现这个监听接口。</li>
<li>class HttpServlet：扩展GenericServlet用于创建HttpServlet。</li>
<li>class Cookie：创建一个Cookie类，用于存储Servlet发送给客户端的信息。</li>
</ul>
<p>Servlet的工作模式：</p>
<ol>
<li>客户端发送请求至服务器。</li>
<li>服务器启动并调用Servlet，根据客户端请求生成响应内容并传到服务器。</li>
<li>服务器将响应返回客户端。</li>
</ol>
<p></p><h3 id="1.1">GenericServlet</h3><br>一般通用Servlet由javax.servle的GenericServlet实现Servlet接口。它定义了一个通用独立于底层协议的Servlet。通过使用或者继承来实现Servlet应用。<br>GenericServlet的主要方法：<p></p>
<ul>
<li>String getInitParameter(String name):返回具有指定名称的初始化参数。</li>
<li>ServletConfig getServletConfig():返回传递到init()方法的ServletConfig对象。</li>
<li>ServletContext gerServletContext():返回在config对象中引用的ServletContext。</li>
<li>String getServletName():返回在web应用发布描述器(web.xml)中指定的Servlet名字。</li>
</ul>
<p></p><h3 id="1.2">HttpServlet</h3><br>javax.servle.http.HttpServlet实现了专门相应HTTP请求的Servlet。提供doGet(),doPost(),doDelete(),doOptions(),doPut(),doTrace()方法响应请求。<br>Web容器创建HttpServlet对象，并把HTTP请求封装到HttpServlet对象中。其相应web客户端的流程：<p></p>
<ol>
<li>web客户向web容器发送http请求</li>
<li>web容器解析请求</li>
<li>web容器创建一个HttpRequest对象，封装http请求信息</li>
<li>web容器创建一个HttpResponse对象</li>
<li>web容器调用service方法将之前两个对象作为service的参数传给HttpRequest对象</li>
<li>HttpServlet调用HttpRequest对象获取请求信息</li>
<li>HttpServlet调用HttpResponse生成响应数据】</li>
<li>web容器把HttpServlet传给web客户</li>
</ol>
<p>创建HttpServlet:</p>
<ol>
<li>继承HttpServlet抽象类</li>
<li>覆盖HttpServlet的部分方法</li>
<li>获取HTTP的请求信息</li>
<li>生成响应结果</li>
</ol>
<p></p><h3 id="1.3">Servlet生命周期</h3><br>Servlet框架的核心是javax.servlet.Servlet方法，它包含的三种方法代表了Servlet的生命周期：<p></p>
<ul>
<li>init():初始化Servlet。</li>
<li>service():负责对客户端的请求。</li>
<li>destory():当Servlet对象生命结束时释放占用的资源。</li>
</ul>
<p>Servlet只会在第一次请求到来时被加载和实例化。一旦被加载一般不会被删除，除非应用服务器关闭或者重新启动。当容器做内存回收动作时Servlet可能被删除。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">/*初始化Servlet*/</div><div class="line">public void init(ServletConfig config) throws ServletException&#123;</div><div class="line">	...</div><div class="line">&#125;</div><div class="line">/*init(ServletConfig)代表配置信息在web.xml中修改。*/</div><div class="line">/*响应客户端请求*/</div><div class="line">public void doPost(ServletRequest request, ServletResponse response)throws ServletException, IOException &#123;</div><div class="line">...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p></p><h3 id="1.4">配置web.xml</h3><br>建立mainServlet.java，配置web.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</div><div class="line">&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</div><div class="line">	xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee</div><div class="line">                      http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot;</div><div class="line">	version=&quot;3.1&quot;&gt;</div><div class="line">	&lt;display-name&gt;&lt;/display-name&gt;</div><div class="line">	&lt;!-- Servlet可以被外部访问 访问它需要一个地址 通过WEB的地址映射解决 --&gt;</div><div class="line">	&lt;servlet&gt;</div><div class="line">		&lt;servlet-name&gt;mainServlet&lt;/servlet-name&gt; &lt;!--定义Servlet应用名字 --&gt;</div><div class="line">		&lt;servlet-class&gt;cn.edu.ccnu.imd.mainServlet&lt;/servlet-class&gt;&lt;!--自定义的Servlet应用名字对应的具体Servlet文件 --&gt;</div><div class="line">	&lt;/servlet&gt;</div><div class="line"></div><div class="line">	&lt;servlet-mapping&gt; &lt;!--地址映射 --&gt;</div><div class="line">		&lt;servlet-name&gt;mainServlet&lt;/servlet-name&gt;</div><div class="line">		&lt;url-pattern&gt;/service.do&lt;/url-pattern&gt;&lt;!--地址名 --&gt;</div><div class="line">	&lt;/servlet-mapping&gt;</div><div class="line">	&lt;!--输入地址：http://localhost:端口号/service.do定位servlet--&gt;</div><div class="line">&lt;/web-app&gt;</div></pre></td></tr></table></figure><p></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Servlet是Java编写的服务器端程序，动态的生成Web内容。&lt;br&gt;
    
    </summary>
    
      <category term="JSP" scheme="http://www.codingbalian.online/categories/JSP/"/>
    
    
      <category term="Servlet" scheme="http://www.codingbalian.online/tags/Servlet/"/>
    
  </entry>
  
</feed>
