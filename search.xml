<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[JavaScript:学习笔记1]]></title>
      <url>http://www.codingbalian.online/2017/02/21/JavaScript-Note/</url>
      <content type="html"><![CDATA[<p>JavaScript的学习笔记，记录个人认为重要的内容。<br><a id="more"></a></p>
<h2 id="1">JS变量作用域</h2>

<p>全局变量与局部变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var total = 10</div><div class="line">function square(num) &#123;</div><div class="line">    total = num * num</div><div class="line">    return total</div><div class="line">&#125;</div><div class="line">square(4)</div><div class="line">alert(total)</div></pre></td></tr></table></figure>
<p>返回的total值为16<br>在调用<code>square()</code>函数时改变了total的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var total = 10</div><div class="line">function square(num) &#123;</div><div class="line">    var total = num * num</div><div class="line">    return total</div><div class="line">&#125;</div><div class="line">square(4)</div><div class="line">alert(total)</div></pre></td></tr></table></figure>
<p>返回total值为10<br>在函数中使用var定义变量后函数中的total则变成局部变量，不在使用之前定义的全局变量total。</p>
<h2 id="2">JS DOM使用</h2>

<p><code>getElementById(idname)</code>获取id值为idname的元素，返回一个对象</p>
<p><code>getElementsByName(namevalue)</code> 获取所有name属性为namevalue的元素，返回一个数组</p>
<p><code>getElementsByTagName(tagnamevalue)</code> 获取所有标签为tagnamevalue的元素，返回一个数组</p>
<p><code>getElementsByClassName(class1 (class2 ...))</code>获取所有class值包括class1(class2 …)的元素，其中class值以空格隔开，不分顺序，返回值是一个数组</p>
<p>以上方法都适用于document对象，也可组合使用。</p>
<p><code>obj.getAttribute(attribute)</code>只使用于object对象即节点元素，获取对象的属性值</p>
<p><code>obj.setAttribute(attribute,value)</code>也只适用于节点元素，为元素添加值为value的attribute属性</p>
<p><code>document.getElementsByTagName(&quot;form&quot;)=document.forms</code></p>
<p><code>element.getAttribute(&#39;src&#39;)=element.src</code></p>
<p><code>element.getAttribute(&#39;href&#39;)=element.href</code></p>
<p><code>document.getElementsByTagName(&#39;body&#39;)=document.body</code></p>
<p><code>element.className=element.setAttribute(&#39;class&#39;,value)</code></p>
<h3 id="2.1">分离Javascript</h3>

<p><code>element.event=action</code></p>
<p>监听：<code>element.addEventListener(event, function, useCapture)</code><br>useCapture默认为false在冒泡阶段执行，true为在捕获阶段执行</p>
<p>移除监听：<code>element.removeEventListener(event, function, useCapture)</code><br>useCapture默认为false在冒泡阶段执行，true为在捕获阶段执行</p>
<table>
<thead>
<tr>
<th>DOM 0</th>
<th>DOM 2</th>
</tr>
</thead>
<tbody>
<tr>
<td>onblur()</td>
<td>blur</td>
</tr>
<tr>
<td>onfocus()</td>
<td>focus</td>
</tr>
<tr>
<td>onchange()</td>
<td>change</td>
</tr>
<tr>
<td>onmouseover()</td>
<td>mouseover</td>
</tr>
<tr>
<td>onmouseout()</td>
<td>mouseout</td>
</tr>
<tr>
<td>onmousemove()</td>
<td>mousemove</td>
</tr>
<tr>
<td>onmousedown()</td>
<td>mousedown</td>
</tr>
<tr>
<td>onmouseup()</td>
<td>mouseup</td>
</tr>
<tr>
<td>onclick()</td>
<td>click</td>
</tr>
<tr>
<td>ondblclick()</td>
<td>dblclick</td>
</tr>
<tr>
<td>onkeydown()</td>
<td>keydown</td>
</tr>
<tr>
<td>onkeyup()</td>
<td>keyup</td>
</tr>
<tr>
<td>onkeypress()</td>
<td>keypress</td>
</tr>
<tr>
<td>onsubmit()</td>
<td>submit</td>
</tr>
<tr>
<td>onload()</td>
<td>load</td>
</tr>
<tr>
<td>onunload()</td>
<td>unload</td>
</tr>
</tbody>
</table>
<ul>
<li>DOM2可以使用js监听事件</li>
</ul>
<h3 id="2.2">共享onload事件</h3>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">      function addLoadEvent(fuc) &#123;</div><div class="line">          var oldOnLoad = window.onload</div><div class="line">          if (typeof window.onload != &apos;function&apos;) &#123;</div><div class="line">              window.onload = fuc</div><div class="line">          &#125;</div><div class="line">          else &#123;</div><div class="line">              window.onload = function () &#123;</div><div class="line">                  oldOnLoad();</div><div class="line">                  fuc()</div><div class="line">              &#125;</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line">addLoadEvent(function1)</div><div class="line">addLoadEvent(function2)</div></pre></td></tr></table></figure>
<h3 id="2.3">insertAfter方法</h3>

<p>DOM中定义了insertBefore方法，却没有给出相应的insertAfter方法，但是可以自己实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function insertAfter(newElement, targetElement) &#123;</div><div class="line">    var parent = targetElement.parentNode</div><div class="line">    if (parent.lastChild == targetElement) &#123;</div><div class="line">        parent.appendChild(newElement)</div><div class="line">    &#125;</div><div class="line">    else &#123;</div><div class="line">        parent.insertBefore(newElement, targetElement.nextSibling)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="2.4">获取下一个元素节点</h3>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">   function getNextElement(node) &#123;</div><div class="line">       if (node.nodeType == 1) &#123;</div><div class="line">           return node</div><div class="line">       &#125;</div><div class="line">       if (node.nextSibling) &#123;</div><div class="line">           getNextElement(node.nextSibling)</div><div class="line">       &#125;</div><div class="line">       return null</div><div class="line">   &#125;</div><div class="line">getNextElement(node.nextSibling)</div></pre></td></tr></table></figure>
<h2 id="3">Ajax的兼容</h2>

<p>Ajax使用XMLHttpRequest对象，但是由于IE与其他浏览器的实现方式不同，需要创建一个兼容对象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">      function requestObject() &#123;</div><div class="line">          if (typeof XMLHttpRequest == &apos;undefined&apos;)</div><div class="line">              XMLHttpRequest = function () &#123;</div><div class="line">                  try &#123;</div><div class="line">                      return new ActiveXObject(&quot;Msxml2.XMLHTTP.6.0&quot;)</div><div class="line">                  &#125;</div><div class="line">                  catch (e) &#123;</div><div class="line">                  &#125;</div><div class="line">                  try &#123;</div><div class="line">                      return new ActiveXObject(&quot;Msxml2.XMLHTTP.3.0&quot;)</div><div class="line">                  &#125;</div><div class="line">                  catch (e) &#123;</div><div class="line">                  &#125;</div><div class="line">                  try &#123;</div><div class="line">                      return new ActiveXObject(&quot;Msxml2.XMLHTTP&quot;)</div><div class="line">                  &#125;</div><div class="line">                  catch (e) &#123;</div><div class="line">                  &#125;</div><div class="line">                  return false</div><div class="line">              &#125;</div><div class="line">          return new XMLHttpRequest()</div><div class="line">      &#125;</div><div class="line">var request = new  requestObject()</div></pre></td></tr></table></figure></p>
<p>XMLHTTPREQUEST对象发送的请求只能访问同一个域的数据。<br>Ajax在发送请求之后脚本会继续执行。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[操作系统：文件管理]]></title>
      <url>http://www.codingbalian.online/2017/01/06/OS-File%20Management/</url>
      <content type="html"><![CDATA[<p>操作系统中文件管理功能的概述。<br><a id="more"></a></p>
<h2 id="1">文件和文件系统</h2>

<p>文件是数据的一种组织形式，由数据项和记录构成。<br>数据项包括基本数据项和组合数据项。用于描述对象的某个属性。<br>记录是一组相关数据项的集合。<br>文件在文件系统中是一个最大的数据单位。</p>
<h3 id="1.1">文件分类</h3>

<p>文件的分类可以更好地管理和使用，提高了文件的存取速度，对文件的共享和保护也有利。<br>一般系统级与用户级要进行不同的管理。<br>按性质和用途分：</p>
<ul>
<li>系统文件：由系统软件构成的文件，只允许用户通过系统调用或系统提供的专用命今来执行它们，不允许对其进行读写和修改。</li>
<li>库文件：文件允许用户对其进行读取和执行，但不允许对其进行修改。</li>
<li>用户文件：是用户通过操作系统保存的用户文件，由文件的所有者或所有者授权的用户才能使用。</li>
</ul>
<p>按操作保护分类：</p>
<ul>
<li>可执行文件：允许调用而不允许读写</li>
<li>只读文件：可读不可写</li>
<li>可读可写文件</li>
</ul>
<p>按使用情况分类：</p>
<ul>
<li>临时文件：用于系统在工作过程中产生的中间文件，一般有暂存目录，工作完毕会自动删除。</li>
<li>永久文件: 受系统管理的各种系统和用户文件。</li>
<li>档案文件: 系统或一些实用工具软件包在工作过程中记录在案的文挡资料文件，以便查阅历史档案。</li>
</ul>
<p>按用户观点分类：</p>
<ul>
<li>普通文件：字符流组成的无结构文件</li>
<li>目录文件：文件的目录信息构成的特殊文件</li>
<li>特殊文件（设备驱动程序）</li>
</ul>
<p>按存取的物理结构分类：</p>
<ul>
<li>顺序文件：文件中的纪录，顺序地存储到连续的物理盘块中</li>
<li>链接文件：文件中的纪录可存储在并不相邻接的各个物理块中，通过物理块中的链接指针组成一个链表管理，形成一个完整的文件</li>
<li>索引文件：文件中的纪录可存储在并不相邻接的各个物理块中，纪录和物理块之间通过索引表项按关键字存取文件，通过物理块中的索引表管理，形成一个完整的文件</li>
</ul>
<p>按文件的逻辑存储结构分类：</p>
<ul>
<li>有结构文件：由若干个记录所构成的文件</li>
<li>无结构文件：这是直接由字符序列所构成的文件</li>
</ul>
<p>按文件中的数据形式分类：</p>
<ul>
<li>源文件：由源程序和数据构成的文件</li>
<li>目标文件：由源程序经过编译，但尚未经过链接程序链接的目标代码所形成的文件</li>
</ul>
<h3 id="1.2">文件系统</h3>

<p>文件系统：操作系统中统一管理信息资源的一种软件，管理文件的存储、检索、更新，提供安全可靠的共享和保护手段，并且方便用户使用。<br>文件系统包含文件管理程序（文件与目录的集合）和所管理的全部文件。</p>
<h2 id="2">文件逻辑结构</h2>

<p>有结构文件：</p>
<ol>
<li>定长记录</li>
<li>变长记录</li>
</ol>
<p>无结构文件：流式文件是相关信息的有序集合如源程序、可执行文件、库函数，可以提供很好的灵活性。</p>
<h3 id="2.1">顺序文件</h3>

<p>逻辑记录的排序:</p>
<ul>
<li>串结构:各记录之间的顺序与关键字无关,通常按存入的时间排序。</li>
<li>顺序结构：所有记录按关键字排列。</li>
</ul>
<p>对顺序文件的读写操作：</p>
<ul>
<li>定长记录：所有记录长度相等</li>
<li>变长记录：记录长度不固定</li>
</ul>
<p>优点：每次要读或写一大批记录时，对顺序文件的存取效率是所有逻辑文件中最高的；能存储在磁带上，并能有效地工作。</p>
<p>缺点：查找或修改单个记录，系统要逐个地查找诸记录；增加或删除一个记录较困难。</p>
<h3 id="2.2">索引文件</h3>

<p>对于定长记录文件，如果要查找第i个记录，获得首地址：<br>$$A_i=i*L$$</p>
<p>对于可变长度记录的文件，要查找其第i个记录时，须首先计算出该记录的首地址。为此，须顺序地查找每个记录，从中获得相应记录的长度Li，然后才能按下式计算出第i个记录的首址:<br>$$ \sum_{i=0}^{i-1} L_i+i = A_i $$<br>因此，对于可变长度记录的文件难以实现直接存储。<br>文件中每个记录，在索引表中有一相应表项<br>因为索引表本身是一个定长记录的顺序文件，从而可以方便的实现直接存取。</p>
<h3 id="2.3">索引顺序文件</h3>

<p>顺序文件与索引文件相结合,将顺序文件中记录分为若干个组，为各组的第一个记录建立一个索引表。</p>
<h3 id="2.4">存储介质</h3>

<p>在文件系统中，文件的存储设备常常划分为若干大小相等的物理块。同时也将文件信息划分成相同大小的逻辑块，所有块统一编号。以块为单位进行信息的存储、传输，分配。<br>常见的存储介质:磁盘，磁带，光盘</p>
<h2 id="3">文件的物理结构</h2>

<p>文件的物理结构也即文件的外存分配方式。</p>
<h3 id="3.1">连续分配</h3>

<p>一个文件的信息存放在若干连续的物理块中。<br>优点：</p>
<ul>
<li>简单</li>
<li>支持顺序存取和随机存取</li>
<li>顺序存取速度快</li>
<li>所需的磁盘寻道次数和寻道时间最少</li>
</ul>
<p>缺点：</p>
<ul>
<li>要求有连续的存储空间 </li>
<li>必须事先知道文件的长度 </li>
</ul>
<p>连续文件：由一组相邻的物理块组成，是对记录式文件取连续区分配而构成的文件。</p>
<h3 id="3.2">链接分配</h3>

<p>一个文件的信息存放在若干不连续的物理块中，各块之间通过指针连接，前一个物理块指向下一个物理块。<br>优点：</p>
<ul>
<li>提高了磁盘空间利用率</li>
<li>不存在外部碎片问题</li>
<li>有利于文件插入和删除</li>
<li>有利于文件动态扩充</li>
</ul>
<p>缺点：</p>
<ul>
<li>存取速度慢，不适于随机存取</li>
<li>可靠性问题，如指针出错</li>
<li>更多的寻道次数和寻道时间</li>
<li>链接指针占用一定的空间</li>
<li>不能支持高效的直接存取。要对一个较大的文件进行直接存取，须首先在FAT中顺序地查找许多盘块号</li>
<li>FAT需占用较大的内存空间</li>
</ul>
<p>隐式链接：文件名，始址，末址<br>显式链接：文件名，块号，块中显示指针</p>
<h3 id="3.3">索引分配</h3>

<p>一个文件的信息存放在若干不连续物理块中，系统为每个文件建立一个专用数据结构–索引表，并将这些块的块号存放在一个索引表中。<br>一个索引表就是磁盘块地址数组,其中第i个条目指向文件的第i块。</p>
<p>优点：能顺序存取,也能随机存取，满足了文件动态增长、插入删除的要求，也能充分利用外存空间<br>缺点：较多的寻道次数和寻道时间，索引表本身带来了系统开销，如：内外存空间，存取时间。每个文件的索引表要分配盘块，可以存放成百上千的盘块号，但对于大量的小文件，索引块利用率极低。</p>
<h3 id="3.4">混合分配方式</h3>

<p>UNIX文件系统采用的是多级索引结构(混合分配模式)。每个文件的索引表为13个索引项，每项2个字节。最前面10项（ iaddr(0)~iaddr(9) ）直接登记存放文件信息的物理块号（直接寻址）。如果文件大于10块，则利用第11项指向一个物理块，该块中最多可放256个文件物理块的块号（一次间接寻址）。对于更大的文件还可利用第12和第13项作为二次和三次间接寻址。</p>
<h2 id="4">目录管理</h2>

<p>目录管理的目的：</p>
<ol>
<li>实现“按名存取” </li>
<li>提高对目录的检索速度 </li>
<li>文件共享 </li>
<li>允许文件重名 </li>
</ol>
<p>文件控制块FCB：操作系统为管理文件而设置的数据结构，存放了为管理文件所需的所有有关信息。包含文件名及文件的各种属性。文件和文件控制块一一对应，而把文件控制块的有序集合称为文件目录。即一个文件控制块就是一个文件目录项。</p>
<p>文件控制块的内容：</p>
<ol>
<li>基本信息类：文件名；文件物理位置；文件逻辑结构；文件的物理结构 </li>
<li>存取控制信息类 </li>
<li>使用信息类 </li>
</ol>
<h3 id="4.1">索引结点</h3>

<p>索引结点：查找文件，通常只需要文件名，因此将文件的其它描述信息放在索引节点中 ，这样查找目录更快。</p>
<p>磁盘索引结点：每个文件有唯一的索引节点</p>
<ol>
<li>文件主标识符</li>
<li>文件类型 </li>
<li>文件存取权限 </li>
<li>文件物理地址 </li>
<li>文件长度 </li>
<li>文件连接计数 </li>
<li>文件存取时间 </li>
</ol>
<p>内存索引结点：</p>
<ol>
<li>索引结点编号：用于标识内存索引结点</li>
<li>状态：指示i结点是否上锁或被修改</li>
<li>访问计数：每当有一进程要访问此i结点时， 将该访问计数加1， 访问完再减1</li>
<li>文件所属文件系统的逻辑设备号</li>
<li>链接指针：设置有分别指向空闲链表和散列队列的指针</li>
</ol>
<h3 id="4.2">目录</h3>

<p>文件目录：文件控制块FCB的有序集合<br>目录项：构成文件目录的项目FCB<br>目录文件：为了实现对文件目录的管理，通常将文件目录以文件的形式保存在外存</p>
<p>单级目录结构：为所有文件建立一个目录文件。<br>优点：简单，按名存取。<br>缺点：查找速度慢;不允许重名;不便于实现文件共享</p>
<p>二级目录结构：一级称为主文件目录，给出用户名，用户子目录所在的物理位置；二级称为用户文件目录，给出该用户所有文件的FCB<br>优点：提高了检索目录的速度；在不同的用户目录中，可以使用相同的文件名；不同用户还可使用不同的文件名来访问系统中的同一个共享文件。<br>缺点：不太适合大量用户和大量文件的大系统，增加了系统开销。</p>
<p>多级目录结构：目录与文件在一起，目录也做成文件。<br>优点：层次结构清晰，便于管理和保护；有利于文件分类；解决重名问题；提高文件检索速度；能进行存取权限的控制。<br>缺点：查找一个文件按路径名逐层检查，由于每个文件都放在外存，多次访盘影响速度。</p>
<h2 id="5">文件存储空间的管理</h2>

<p>外存空间管理:记录空闲存储空间，设置相应的数据结构;对存储空间进行分配与回收。<br>方法：</p>
<ol>
<li>空闲块表（空白文件目录）：将所有空闲块记录在一个表中，即空闲块表</li>
<li>空闲块链表：把所有空闲块链成一个链</li>
<li>位图法：用一串二进制位反映磁盘空间中分配使用情况, 每个物理块对应一位, 分配物理块为1，否则为0</li>
</ol>
<p>空闲表法属于连续分配方式。<br>一个连续的未分配区域称为“空白文件”，系统为所有这些“空白文件”单独建立一个目录。每个空白文件，在目录中建立一个表目。<br>表目内容：第一空白物理块的地址（块号）、空白块的数目。<br>当请求分配存储空间时，系统依次扫描空白文件目录的表目，直到找到一个合适的空白文件为止,当用户撤消一个文件时，系统回收该文件所占用的空间。扫描目录，寻找一个空表目，并将释放空间的第一物理号及它所占的物理块数填到这个表目中。</p>
<p>仅当有少量的空白区时才有较好的效果;如果存取空间中有着大量的小的空白区，则其目录变得很大，因而效率大为降低;这种分配技术适用于建立连续文件。</p>
<p>空闲盘区的分配与内存管理的动态分区方式类似：首次适应算法；循环首次适应算法；最佳适应算法；最坏适应算法。</p>
<p>空闲块链：把其中所有的“空白块” 链在一起。<br>创建文件需要一个或几个物理块时，就从链头依次取下一块或几块。<br>回收文件时回收块链到空白链上。</p>
<p>位示图法：反映整个存取空间的分配请况：用一串二进制位反映磁盘空间中分配使用情况, 每个物理块对应一位, “1”表示对应的物理块已分配，”0”表示其对应的块未分配。申请物理块时，可以在位示图中查找为0的位，返回对应物理块号，归还时；将对应位转置0。描述能力强，适合各种物理结构。</p>
<h2 id="6">文件共享和保护</h2>

<p>文件共享节省时间和存储空间，减少了用户工作量；进程间通过文件交换信息。</p>
<h3 id="6.1">共享</h3>

<p>共享形式：</p>
<ul>
<li>被多个用户使用，由存取权限控制</li>
<li>被多个程序使用，但各用自己的读写指针</li>
<li>被多个程序使用，但共享读写指针</li>
<li>多个用户用相同或不同的名字来访问同一文件。</li>
</ul>
<p>实现：</p>
<ol>
<li>建立值班目录：由系统目录实现对文件的共享；用户通过全路径名共享地访问这些文件</li>
<li>采用链访技术：对要共享的文件进行连接:通过Link命令，在用户自己的目录项中对要共享的文件建立起相应的表目，即建立两个文件的等价关系</li>
<li>基于索引结点的共享方式:将文件的物理地址和文件属性等信息放在索引结点中，在文件目录中，设文件名及指向索引结点的指针，另外在索引结点中增加链接计数count,表示共享的用户数删除时必须count=0</li>
<li>利用符号链实现文件共享:共享某文件时创建新文件，加到用户目录中，该文件仅包含被链接文件F的路径名,只有文件才拥有指向其索引结点的指针，其它共享的用户只有该文件的路径名</li>
</ol>
<h3 id="6.2">保护</h3>

<p>文件的保护机制:对拥有权限的用户，应该让其进行相应操作，否则禁止,防止其他用户冒充对文件进行操作。</p>
<p>存取控制矩阵：整个系统一个表，二维矩阵，行：系统中的全部用户；列：系统中的全部文件，系统允许用户i访问文件j，则B[i,j]＝1否则B[i,j]＝0。</p>
<p>存取控制表：一个文件一个表。按用户对文件的访问权力对用户进行分类，所有用户组的存取权限的集合就是该文件的存取控制表。</p>
<ol>
<li>文件主</li>
<li>指定的用户：由文件主指定的允许使用此文件的用户。</li>
<li>同组用户：与文件主属于某一特定项目的成员，同组用户与此文件有关</li>
<li>其他用户</li>
</ol>
<ul>
<li>将所有对某一文件有存取要求的用户按某种关系或工程项目的类别分成若干组，</li>
<li>另外的用户归入其他用户类，</li>
<li>规定每一组用户的存取权限。</li>
</ul>
<p>口令：用户为自己的每个文件规定一个口令，并附在用户文件目录中。凡请求该文件的用户必须先提供口令，只有当提供的口令与目录中的口令一致才允许用户存取该文件。<br>当文件主允许其他用户使用他的文件时，必须将口令告诉其他用户。<br>优点是：简便，节省空间。<br>缺点：</p>
<ul>
<li>可靠性差。口令易被窃取。</li>
<li>存取控制不易改变。</li>
<li>保护级别少：只有允许和不允许两种，对于允许，没有指明只读、只写等权限。 </li>
</ul>
<p>密码：<br>编码：当用户建立一个文件时，利用一个代码键来启动一个随机数发生器，产生一系列随机数，由文件系统将这些相继的随机数依次加到文件的字节上去。<br>译码：使用相同的代码键启动随机数发生器，从存入的文件中依次减去所得到随机数，文件就还原了。<br>只有当用户存取文件时，才需将代码键送入系统。文件主只将代码键告诉允许访问该文件的用户。<br>优点：保密性强，节省存储空间。<br>缺点：必须花费大量的编码和译码时间，从而增加了系统的开销。</p>
<h3 id="6.3">磁盘容错技术</h3>

<p>容错技术是通过在系统中设置冗余部件来提高系统可靠性的一种技术。<br>磁盘容错技术则是通过增加冗余的磁盘驱动器、磁盘控制器等，来提高磁盘系统的可靠性，从而构成实际上的稳定存储器系统。 </p>
<p>第一级容错技术SFT－I：<br>修复重定向：在磁盘中划出一部分作为热修复重定向区，存放坏磁道的待写数据<br>写后读校验：内存—（写）盘时，从盘读出与内存校验看是否一致，不一致，重写入热修复重定向区，标记坏盘块</p>
<p>第二级容错技术SFT-II：<br>磁盘镜像：增设一个完全相同的磁盘驱动器。<br>优点：磁盘驱动器发生故障时切换，仍能正常工作。<br>缺点：磁盘的利用率为50％。<br>磁盘双工(Disk Duplexing)：将两台磁盘驱动器分别接两个磁盘控制器。每个磁盘有自己独立的通道，可同时将数据写入，加块数据读取速度。</p>
<p>廉价磁盘冗余阵列：利用一磁盘阵列控制器，统一管理和控制一组磁盘驱动器，并行交叉存取，传输时间大大减少，RAID分级，可靠性高，磁盘I/O速度高，性能/价格比高。<br>最简单的RAID组织方式：镜像<br>最复杂的RAID组织方式：块交错校验</p>
<h2 id="7">数据一致性控制</h2>

<p>事务是用于访问和修改各种数据项的一个程序单位，也可以被看作是一系列相关读和写操作。</p>
<p>事务记录包含运行时数据修改的全部信息：</p>
<ul>
<li>事务名：用于标识该事务的惟一名字</li>
<li>数据项名：它是被修改数据项的惟一名字</li>
<li>旧值：修改前数据项的值</li>
<li>新值：修改后数据项将具有的值</li>
</ul>
<p>恢复算法：undo〈Ti〉：该过程把所有被事务Ti修改过的数据，恢复为修改前的值；redo〈Ti〉：该过程能把所有被事务Ti修改过的数据，设置为新值。</p>
<p>并发控制：<br>利用互斥锁实现“顺序性”<br>利用互斥锁和共享锁实现顺序性</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[操作系统:设备管理]]></title>
      <url>http://www.codingbalian.online/2017/01/05/OS-Device%20Management/</url>
      <content type="html"><![CDATA[<p>介绍I/O设备的管理<br><a id="more"></a></p>
<h2 id="1">I/O概述</h2>

<ol>
<li>I/O性能经常成为系统性能的瓶颈</li>
<li>操作系统庞大复杂的原因之一是：资源多、杂，并发，均来自I/O</li>
<li>理解I/O的工作过程与结构是理解操作系统的工作过程与结构的关键</li>
<li>与其他功能联系密切，特别是文件系统</li>
</ol>
<p>对于不同规模的计算机系统，其I/O系统的结构也有所差异。通常分为两类：</p>
<ul>
<li>微型机I/O系统<ul>
<li>多采用总线I/O系统结构。</li>
<li>CPU通过设备控制器与I/O设备通信。</li>
<li>不同的设备配置相应的控制器。</li>
</ul>
</li>
<li>主机I/O系统<ul>
<li>增加一级I/O通道，用以代替CPU与各设备控制器通信。</li>
<li>四级结构。</li>
</ul>
</li>
</ul>
<h3 id="1.1">设备分类</h3>

<ul>
<li>按使用特性分<ul>
<li>存储型设备</li>
<li>输入型设备（外设→主机）</li>
<li>输出型设备（主机→外设）</li>
<li>输入输出型设备（交互型设备）</li>
</ul>
</li>
<li>按信息交换单位分<ul>
<li>块设备：用于存储信息。基本特征是其传输速率较高，可寻址，可随机地读/写</li>
<li>字符设备：以字符为单位存储、传输信息；传输速率较低；不可寻址</li>
</ul>
</li>
<li>按外部设备的从属关系分<ul>
<li>系统设备：操作系统生成时，登记在系统中的标准设备</li>
<li>用户设备：系统生成时，未登记在系统中的非标准设备。对于这类设备的处理程序由用户提供，并将其纳入系统，由系统代替用户实施管理。</li>
</ul>
</li>
<li>虚设备<ul>
<li>在一类设备上模拟另一类设备，常用共享设备模拟独占设备，用高速设备模拟低速设备，被模拟的设备称为虚设备</li>
<li>将慢速的独占设备改造成多个用户可共享的设备，提高设备的利用率</li>
</ul>
</li>
</ul>
<blockquote>
<p>SPOOLing技术<br>为解决独立设备数量少，速度慢，不能满足众多进程的要求，而且在进程独占设备期间，设备利用率比较低而提出的一种设备管理技术</p>
</blockquote>
<ul>
<li>从程序使用角度分<ul>
<li>逻辑设备</li>
<li>物理设备</li>
</ul>
</li>
<li>按数据传输率分<ul>
<li>第一类是低速设备，这是指其传输速率仅为每秒钟几个字节至数百个字节的一类设备。典型设备有键盘、鼠标、语音的输入和输出等设备。</li>
<li>第二类是中速设备，这是指其传输速率在每秒钟数千个字节至数万个字节的一类设备。典型设备有行式打印机、激光打印机等。</li>
<li>第三类是高速设备， 这是指其传输速率在数百千个字节至数十兆字节的一类设备。 典型设备有磁带机、 磁盘机、 光盘机等。 </li>
</ul>
</li>
</ul>
<h3 id="1.2">I/O请求处理</h3>

<p>I/O请求过程：用户进程→独立于设备的软件→设备驱动程序→中断处理程序→硬件</p>
<ol>
<li>用户进程层执行输入输出系统调用，对I／O数据进行格式化，为假脱机输入／输出作准备</li>
<li>独立于设备的软件实现设备的命名、设备的保护、成块处理、缓冲技术和设备分配</li>
<li>设备驱动程序设置设备寄存器、检查设备的执行状态</li>
<li>中断处理程序负责I／O完成时，唤醒设备驱动程序进程，进行中断处理</li>
<li>硬件层实现物理I／O的操作</li>
</ol>
<h3 id="1.3">中断处理程序</h3>

<ol>
<li>每个进程在启动一个I／O操作后阻塞 </li>
<li>直到I／O操作完成并产生一个中断</li>
<li>由操作系统接管CPU后唤醒该进程为止</li>
</ol>
<h3 id="1.4">设备驱动程序</h3>

<ul>
<li>与设备密切相关的代码放在设备驱动程序中，每个设备驱动程序处理一种设备类型</li>
<li>每一个控制器都设有一个或多个设备寄存器，用来存放向设备发送的命令和参数。设备驱动程序负责释放这些命令，并监督它们正确执行</li>
<li>设备驱动程序的任务是接收来自与设备无关的上层软件的抽象请求，并执行这个请求</li>
</ul>
<h3 id="1.5">设备独立的软件</h3>

<p>虽然I／O软件中一部分是设备专用的，但大部分软件是与设备无关的。设备驱动程序与设备独立软件之间的确切界限是依赖于具体系统的。<br>独立于设备的软件的基本任务是实现所有设备都需要的功能，并且向用户级软件提供一个统一的接口。</p>
<h3 id="1.6">用户空间的I／O软件</h3>

<p>有一小部分I/O软件是由与用户程序连接在一起的库过程，甚至完全由运行于核外的程序构成。系统调用，包括I／O系统调用，通常由库过程实现。<br>这些过程所做的工作只是将系统调用时所用的参数放在合适的位置。</p>
<h2 id="2">I/O硬件特点</h2>

<h3 id="2.1">I/O设备组成</h3>

<ul>
<li>物理设备:设备本身</li>
<li>设备控制器:完成设备与主机间的连接和通讯</li>
</ul>
<h3 id="2.2">I/O过程</h3>

<ol>
<li>准备</li>
<li>启动</li>
<li>测试和等待</li>
<li>结果检查和错误处理</li>
<li>通过对设备接口寄存器组的读写完成</li>
</ol>
<ul>
<li>操作系统将命令写入控制器寄存器中，以实现输入／输出</li>
<li>当控制器接受一条命令后，可独立于CPU完成指定操作，CPU可以转去执行其它运算</li>
<li>命令完成时，控制器产生一个中断，CPU响应中断，控制转给操作系统。CPU通过读控制器寄存器中的信息，获得操作结果和设备状态</li>
<li>控制器与设备之间的接口常常是一个低级接口</li>
<li>控制器的任务是把串行的位流转换为字节块，并进行必要的错误修正。首先，控制器按位进行组装，然后存入控制器内部的缓冲区中形成以字节为单位的块。在对块验证检查和并证明无错误时，再将它复制到主存中</li>
</ul>
<h2 id="3">I/O控制技术</h2>

<ul>
<li>程序控制</li>
<li>中断驱动</li>
<li>直接存储器存取（DMA）</li>
<li>通道</li>
</ul>
<p>目的：减少CPU对I/O控制的干预，提高CPU与I/O设备的并行度</p>
<h3 id="3.1">程序控制I/O技术</h3>

<p>又称忙－等待方式。<br>由处理器提供I/O相关指令来实现:</p>
<ul>
<li>I/O处理单元处理请求并设置I/O状态寄存器相关位</li>
<li>处理器定期轮询I/O单元的状态，直到处理完毕</li>
</ul>
<p>主要缺陷：</p>
<ul>
<li>处理器必须不断关注I/O处理单元的状态，因而耗费大量时间轮询信息，严重地降低了系统性能</li>
<li>在程序I/O方式中，由于CPU的高速性和I/O设备的低速性， 致使CPU的绝大部分时间都处于等待I/O设备完成数据I/O的循环测试中， 造成对CPU的极大浪费</li>
</ul>
<h3 id="3.2">中断驱动I/O技术</h3>

<p>将处理器从轮询任务中解放出来，使I/O操作和指令执行并行起来。<br>当某进程要启动某个I/O设备时，便由CPU向相应的设备控制器发出一条命令，然后立即返回继续执行原来的任务。设备控制器按照该命令控制I/O设备。此时，CPU和I/O设备并行工作。</p>
<h3 id="3.3">DMA技术</h3>

<p>当处理器和I/O间传送数据时，每完成一个字节，控制器便向CPU请求一次中断效率太低。为此，数据可以成块传送,通过系统总线中一独立控制单元——DMA控制器，完成直接存储器访问（DMA：Direct Memory Access）。</p>
<p>DMA方式的特点：</p>
<ol>
<li>数据传输的基本单位是数据块，即在CPU与I/O设备之间，每次传送至少一个数据块；</li>
<li>所传送的数据是从设备直接送入内存的，或者相反； </li>
<li>仅在传送一个或多个数据块的开始和结束时，才需CPU干预，整块数据的传送是在控制器的控制下完成的。</li>
</ol>
<p>可见，DMA方式较之中断驱动方式，又是成百倍地减少了CPU对I/O的干预，进一步提高了CPU与I/O设备的并行操作程度。 </p>
<p>DMA控制器：</p>
<ul>
<li>命令/状态寄存器CR：用于接收从CPU发来的I/O命令或有关控制信息， 或设备的状态。</li>
<li>内存地址寄存器MAR：在输入时，它存放把数据从设备传送到内存的起始目标地址；在输出时，它存放由内存到设备的内存源地址。</li>
<li>数据寄存器DR：用于暂存从设备到内存，或从内存到设备的数据。</li>
<li>数据计数器DC：存放本次CPU要读或写的一个字(节)</li>
</ul>
<h3 id="3.4">通道</h3>

<p>I/O通道方式是DMA方式的发展，它可进一步减少CPU的干预，即把对一个数据块的读(或写)为单位的干预，减少为对一组数据块的读(或写)及有关的控制和管理为单位的干预。 同时，又可实现CPU、通道和I/O设备三者的并行操作，从而更有效地提高整个系统的资源利用率。</p>
<h2 id="4">设备有关技术</h2>

<h3 id="4.1">Spooling（虚拟设备）技术</h3>

<p>为了缓和CPU的高速性与I/O设备低速性间的矛盾而引入了脱机输入、脱机输出技术。该技术是利用专门的外围控制机， 将低速I/O设备上的数据传送到高速磁盘上。<br>在多道系统中，完全可以利用其中的一道程序，来模拟脱机输入时的外围控制机功能，把低速I/O设备上的数据传送到高速磁盘上；再用另一道程序来模拟脱机输出时外围控制机的功能，把数据从磁盘传送到低速输出设备上。这样，便可在主机的直接控制下，实现脱机输入、输出功能。此时的外围操作与CPU对数据的处理同时进行，我们把这种在联机情况下实现的同时外围操作称为SPOOLing(Simultaneaus Periphernal Operating On-Line)，或称为假脱机操作。</p>
<p>特点：</p>
<ul>
<li>提高了I/O的速度。 </li>
<li>将独占设备改造为共享设备。 </li>
<li>实现了虚拟设备功能。 </li>
</ul>
<h3 id="4.2">中断技术</h3>

<p>中断的概念：<br>CPU对系统发生的某个事件作出的一种反应<br>CPU暂停正在执行的程序，保留现场后自动转去执行相应事件的处理程序，处理完成后返回断点，继续执行被打断的程序<br>特点：</p>
<ol>
<li>中断随机的</li>
<li>中断是可恢复的</li>
<li>中断是自动处理的</li>
</ol>
<p>引入中断的目的:<br>解决主机与外设的并行工作问题<br>提高可靠性<br>实现多机联系<br>实现实时控制</p>
<p>强迫性中断:正在运行的程序所不期望的，由于某种硬件故障或外部请求引起的</p>
<ul>
<li>输入/输出(I/O)中断：主要来自外部设备通道</li>
<li>程序性中断：运行程序中本身的中断(如溢出,缺页中断,缺段中断,地址越界)</li>
<li>时钟中断</li>
<li>控制台中断</li>
<li>硬件故障</li>
</ul>
<p>自愿性中断：用户在程序中有意识安排的中断，是由于用户在编制程序时因为要求操作系统提供服务，有意使用“访管”指令或系统调用，使中断发生</p>
<ul>
<li>执行I/O</li>
<li>创建进程</li>
<li>分配内存</li>
<li>信号量操作</li>
<li>发送/接收消息</li>
</ul>
<p>微机中的中断：</p>
<ol>
<li>可屏蔽中断（I/O中断）</li>
<li>不可屏蔽中断（机器内部故障、掉电中断）</li>
<li>程序错误中断（溢出、除法错等中断）</li>
<li>软件中断（Trap指令或中断指令INT）</li>
</ol>
<p>中断寄存器：</p>
<ul>
<li>有的计算机中，为了区分和不丢失中断信号，对应每个中断源分别用一固定触发器寄存中断信号规定值为1时，表示有中断信号，为0时表示无</li>
<li>这些触发器的全体称为中断寄存器</li>
<li>每个触发器称为一个中断位</li>
<li>所有中断寄存器是由若干个中断位组成</li>
</ul>
<p>中断优先级：</p>
<ul>
<li>以机器故障中断的优先级最高 </li>
<li>程序中断和访问管理程序中断次之</li>
<li>外部中断更次之 </li>
<li>输入输出的优先级最低</li>
</ul>
<p>中断屏蔽：<br>在CPU上运行的程序，有时由于种种原因，不希望其在执行过程中被别的事件所中断，称为中断屏蔽。<br>在PSW中设置中断屏蔽码以屏蔽某些指定的中断类型，各设备接口中也有中断禁止位，以禁止该设备的中断。</p>
<p>实时处理的中断：<br>把具有重要意义传感器发出的中断作为高优先级，中断优先级的设计是灵活可变的，允许用户根据应用需要，选择不同中断优先策略。</p>
<p>中断处理：</p>
<ol>
<li>设备给处理器发一个中断信号</li>
<li>处理器处理完当前指令后响应中断，延迟非常短</li>
<li>处理器处理完当前指令后检测到中断，判断出中断来源并向发送中断的设备发送了确认中断信号，确认信号使得该设备将中断信号恢复到一般状态</li>
<li>处理器开始为软件处理中断做准备：保存中断点的程序执行上下文环境，这通常包括程 序状态字PSW，程序计数器PC中的下一条指令位置，一些寄存器的值，它们通常保存在系统控制栈中,处理器状态被切换到管态</li>
<li>处理器根据中断源查询中断向量表，获得与该中断相联系的处理程序入口地址，并将PC置成该地址，处理器开始一个新的指令周期，控制转移到中断处理程序</li>
<li>中断处理程序开始工作，包括检查I/O相关的状态信息，操纵I/O设备或者在设备和主存之间传送数据</li>
<li>中断处理结束时，处理器检测到中断返回指令，被中断程序的上下文环境从系统堆栈中被恢复，处理器状态恢复成原来的状态</li>
<li>PSW和PC被恢复成中断前的值，处理器开始一个新的指令周期，中断处理结束</li>
</ol>
<p>多个中断（中断处理过程中又发生中断，引起多中断处理问题）的处理：<br>第一种：处理一个中断时禁止中断，对任何新中断置之不理，在这期间发生的中断将保持挂起状态；当再次允许中断时，新中断信号被处理器检测到<br>软件实现方法：</p>
<ul>
<li>在任何中断处理前使用禁止中断指令</li>
<li>在处理结束后开放中断指令</li>
<li>所有中断严格按照发生顺序处理</li>
<li>不考虑中断紧急程度，无法达到较严格时间要求</li>
</ul>
<p>第二种：</p>
<ul>
<li>中断按照优先度分级</li>
<li>允许优先级高中断打断优先级低的中断处理过程，这样中断优先级技术将引起中断处理的嵌套</li>
<li>只要合适地定义中断的优先级别，方法一的弊端大都可以克服</li>
</ul>
<h3 id="4.3">典型的中断处理</h3>

<ol>
<li><p>I/O中断:由I/O设备的控制器或者通道发出</p>
<ul>
<li>I/O操作正常结束:如果要继续I/O操作，需要在准备好以后重新启动I/O，若请求I/O程序正处于等待I/O状态，则应将其唤醒</li>
<li>I/O异常:需要重新执行失败的I/O操作,重试次数有上限，次数过大，系统将判定硬件故障</li>
</ul>
</li>
<li><p>时钟中断:中断处理程序通常做与系统运转、管理和维护相关的工作</p>
<ul>
<li>维护软件时钟：系统有若干个软件时钟，控制定时任务以及进程的处理器时间配额，时钟中断需要维护、定时更新这些软件时钟</li>
<li>处理器时间调度：维护当前进程时间片软件时钟，并在当前进程时间片到时以后运行调度程序选择下一个被调度的进程</li>
<li>控制系统定时任务：通过软件时钟和调度程序定时激活一些系统任务，如监测死锁、系统记帐、系统审计等</li>
<li>实时处理</li>
</ul>
</li>
<li><p>硬件故障中断</p>
<ul>
<li>保存现场，使用一定警告手段，提供些辅助诊断信息</li>
<li>在高可靠系统中，中断处理程序还要评估系统可用性，尽可能恢复系统</li>
</ul>
</li>
<li><p>程序性中断:程序指令出错、指令越权或者指令寻址越界而引发两类处理方法</p>
<ul>
<li>只能由操作系统的相关扩展功能模块完成,多为程序试图作不能做的操作引起的系统保护</li>
<li>可由程序自己完成</li>
<li>系统调试中断（断点中断、单步跟踪）也可被用户程序处理，用以支持各种程序调试</li>
</ul>
</li>
<li><p>系统服务请求（自愿性中断）:系统服务请求由处理器专用指令（访管指令）激发</p>
<ul>
<li>执行专用指令的结果是系统被切换到管态，并且转移到一段专门OS程序处开始执行</li>
<li>指令格式通常是指令名加请求服务识别号（中断号）</li>
<li>OS利用处理器提供的这种接口建立系统服务体系</li>
<li>处理器一般不负责定义系统调用所传递的参数格式</li>
</ul>
</li>
</ol>
<h3 id="4.4">通道技术</h3>

<p>通道又称输入输出处理机，通道是一个比CPU功能较弱、速度较慢、价格较为便宜的处理机，但“通道”一词在微型机中常指与DMA或与I/O处理机相连设备的单纯的数据传送通路，它并不具有处理机的功能。</p>
<p>引入通道的目的：提高CPU与设备，设备与设备之间的并行工作能力<br>通道类型：</p>
<ul>
<li>字节多路通道:通常按字节交叉的方式工作，适用于低速I/O设备。</li>
<li>数据选择通道:按成组方式进行数据传输，适用于高速I/O设备。</li>
<li>数组多路通道:综合前二个优点（数据传送率和通道利用率都较高）。</li>
</ul>
<p>通道工作原理:包含通道指令（空操作，读操作，写操作，控制，转移操作），并可执行用这些指令编写的通道程序<br>通道运算控制部件:</p>
<ul>
<li>通道地址字CAW：记录通道程序在内存中的地址</li>
<li>通道命令字CCW：保存正在执行的通道指令</li>
<li>通道状态字CSW：存放通道执行后的返回结果</li>
<li>通道数据字CDW：存放传输数据通道和CPU共用内存，通过周期窃取方式取得</li>
</ul>
<p>通道命令：用于I/O操作的命令主要有：</p>
<ol>
<li>I/O指令：启动通道程序</li>
<li>通道命令：对I/O操作进行控制：读、反读、写、测试设备状态的数据传输命令、用于设备控制的命令（磁带反绕、换页）、实现通道程序内部控制的转移命令</li>
</ol>
<p>工作原理：</p>
<ul>
<li>CPU：执行用户程序，当遇到I/O请求时，可根据该请求生成通道程序放入内存（也可事先编好放入内存），并将该通道程序的首地址放入CAW中；之后执行“启动I/O”指令，启动通道工作。</li>
<li>通道：接收到“启动I/O”指令后，从CAW中取出通道程序的首地址，并根据首地址取出第一条指令放入CCW中，同时向CPU发回答信号，使CPU可继续执行其他程序，而通道则开始执行通道程序，完成传输工作。</li>
</ul>
<p>通道与CPU的关系：</p>
<ul>
<li>主从关系</li>
<li>可并行工作</li>
<li>有通信方式</li>
<li>作用不同</li>
</ul>
<h3 id="4.5">DMA技术</h3>

<p>DMA 方式与中断的主要区别：<br>中断方式是在数据缓冲寄存区满后，发中断请求，CPU进行中断处理<br>DMA方式则是在所要求传送的数据块全部传送结束时要求CPU进行中断处理，大大减少了CPU进行中断处理的次数<br>中断方式的数据传送是由CPU控制完成的<br>而DMA方式则是在DMA控制器的控制下不经过CPU控制完成的</p>
<p>DMA工作示例</p>
<ol>
<li>CPU提供被读取块磁盘地址；目标存储地址；待读取字节数</li>
<li>整块数据读进缓冲区，核准校验</li>
<li>控制器按照指定存储器地址，把第一个字节送入主存，按指定字节数进行数据传送</li>
<li>每当传送一个字节后，字节计数器值减1，直到字节计数器等于0</li>
<li>控制器引发中断，通知操作系统，操作完成</li>
</ol>
<p>DMA工作原理：</p>
<ul>
<li>存放输入数据的内存起始地址、要传送的字节数送入DMA控制器的内存地址寄存器和传送字节计数器，中断允许位和启动位置成1，启动设备</li>
<li>发出传输要求的进程进入等待状态</li>
<li>执行指令被暂时挂起，进程调度其他进程占据CPU</li>
<li>输入设备不断窃取CPU工作周期，数据不断写入内存</li>
<li>传送完毕，发出中断信号</li>
<li>CPU接到中断信号转入中断处理程序处理</li>
<li>中断处理结束，CPU返回原进程或切换到新的进程</li>
</ul>
<h3 id="4.6">缓冲技术</h3>

<p>缓冲区是有一定容量、暂存信息的存贮装置。凡是数据到达和离去速度不匹配的地方均可使用缓冲区。在操作系统中采用缓冲是为了实现数据的I/O操作，以缓解CPU与外部设备之间速度不匹配的矛盾，提高资源利用率。</p>
<p>引入缓冲区的优点：</p>
<ul>
<li>提高硬件的并行操作能力</li>
<li>减少了I/O设备对处理器的中断请求次数</li>
<li>简化了中断机制</li>
<li>节省了系统开销</li>
</ul>
<p>缺点：</p>
<ul>
<li>在系统区要设置相当大的缓冲池才能满足所有的Ｉ／Ｏ请求</li>
<li>从系统缓冲区传送数据到调用进程缓冲区要花费额外的时间，增加了系统的总开销</li>
</ul>
<p>缓冲区设置：</p>
<ul>
<li>硬缓冲：设备中设置</li>
<li>软缓冲：内存中使用一定的空间作为缓冲区</li>
</ul>
<p>缓冲技术：</p>
<ol>
<li>单缓冲：只设置一个缓冲区，效率低</li>
<li>双缓冲：设置两个缓冲区，交替使用，但不适用于速度差距大的交流</li>
<li>循环缓冲：多个缓冲按顺序构成环形，先进先出队列的形式，设头尾、指针指向同一个缓冲区。头、尾指针读写时不能相互超越</li>
<li>缓冲池：为多个设备共享，设备需要时才接上，用完归还<ul>
<li>空(闲)缓冲区：链成队列空缓冲队列emq</li>
<li>装满输入数据的缓冲区：链成队列输入队列inq</li>
<li>装满输出数据的缓冲区：链成队列输出队列outq</li>
<li>收容输入数据的工作缓冲区</li>
<li>提取输入数据的工作缓冲区</li>
<li>收容输出数据的工作缓冲区</li>
<li>提取输出数据的工作缓冲区</li>
</ul>
</li>
</ol>
<h3 id="4.7">总线与USB技术</h3>

<p>在计算机系统内各种子系统间构建公用的信号或数据传输通道，这种可共享连接的传输通道称为总线。<br>I/O总线分为数据总线、地址总线、控制总线。<br>USB（Universal Serial Bus）通用串行总线，是一种连接I/O串行设备的技术标准。</p>
<p>USB的结构：</p>
<ul>
<li>控制器：控制器主要负责执行由控制器驱动程序发出的命令</li>
<li>控制器驱动程序：控制器驱动程序在控制器与USB设备之间建立通信信道</li>
<li>USB芯片驱动程序：USB芯片驱动程序提供了对USB的支持</li>
</ul>
<p>USB的传输方式：</p>
<ul>
<li>等时传输方式：以固定的传输速率，连续不断传输数据，发生错误时，USB不处理，而是继续传送新的数据。</li>
<li>中断传输方式：该方式传送的数据量很小，但这些数据需要及时处理</li>
<li>控制传输方式：处理主机的USB设备的数据传输，包括设备控制指令、设备状态查询及确认命令，先进先出原则</li>
<li>批传输方式：用来传输要求正确无误的数据</li>
</ul>
<h2 id="5">设备分配与设备处理</h2>

<h3 id="5.1">设备分配与回收</h3>

<p>当某进程向系统提出I/O请求时，设备分配程序按一定策略分配设备、控制器和通道，形成一条数据传输通路，以供主机和设备间信息交换。</p>
<p>设备管理程序对I/O设备进行分配和控制是借助于一些表格；表格中记录了对I/O设备控制所需之信息。它们是设备管理程序实现管理功能的数据结构。</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>设备控制表（DCT）</td>
<td>每个设备一个</td>
</tr>
<tr>
<td>控制器表（COCT）</td>
<td>每个控制器一个</td>
</tr>
<tr>
<td>通道表（CMCT）</td>
<td>每个通道一个</td>
</tr>
<tr>
<td>系统设备表（SDT）</td>
<td>整个系统一个</td>
</tr>
</tbody>
</table>
<h3 id="5.2">设备分配策略</h3>

<p>独占设备的分配:要考虑充分发挥效率，避免由于不合理的分配策略造成死锁。</p>
<ul>
<li>静态分配：在进程运行前, 完成设备分配；运行结束时，收回设备,设备利用率低</li>
<li>动态分配：在进程运行过程中，当用户提出设备要求时，进行分配，一旦停止使用立即收回,效率高，但分配策略不好时, 产生死锁</li>
</ul>
<p>共享设备分配：考虑多个访问请求到达时服务的顺序，使平均服务时间越短越好。</p>
<p>I/O设备的分配算法：先请求先服务；优先权最高者优先</p>
<p>与设备无关性：逻辑设备与物理设备区分使用联系逻辑设备名称和物理设备名称的映射表(LUT)</p>
<p>设备分配程序:根据用户请求的I/O设备的逻辑名，查找逻辑设备和物理设备的映射表；以物理设备为索引，查找SDT，找到该设备所连接的DCT；继续查找与该设备连接的COCT和CHCT，就找到了一条通路。即：分配设备 －&gt;分配控制器-&gt;分配通道</p>
<h3 id="5.3">设备处理</h3>

<p>设备处理程序通常又称为设备驱动程序，它是I/O进程与设备控制器之间的通信程序。</p>
<p>设备处理方式：</p>
<ul>
<li>为每一类设备设置一个进程，专门用于执行这类设备的I/O操作</li>
<li>在整个系统中设置一个I/O进程，专门用于执行系统中所有各类设备的I/O操作</li>
<li>不设置专门的设备处理进程，而只为各类设备设置相应的设备处理程序(模块)，供用户进程或系统进程调用</li>
</ul>
<p>设备驱动程序的功能：</p>
<ol>
<li>接收由I/O进程发来的命令和参数，并将命令中的抽象要求转换为具体要求</li>
<li>检查用户I/O请求的合法性，了解I/O设备的状态，传递有关参数，设置设备的工作方式</li>
<li>发出I/O命令，如果设备空闲，便立即启动I/O设备去完成指定的I/O操作；如果设备处于忙碌状态，则将请求者的请求块挂在设备队列上等待</li>
<li>及时响应由控制器或通道发来的中断请求，并根据其中断类型调用相应的中断处理程序进行处理</li>
<li>对于设置有通道的计算机系统，驱动程序还应能够根据用户的I/O请求，自动地构成通道程序</li>
</ol>
<p>设备驱动程序的特点:</p>
<ol>
<li>驱动程序主要是指在请求I/O的进程与设备控制器之间的一个通信和转换程序</li>
<li>驱动程序与设备控制器和I/O设备的硬件特性紧密相关，因而对不同类型的设备应配置不同的驱动程序。 </li>
<li>驱动程序与I/O设备所采用的I/O控制方式紧密相关。 </li>
<li>由于驱动程序与硬件紧密相关，因而其中的一部分必须用汇编语言书写。 </li>
</ol>
<p>设备驱动程序的处理过程:</p>
<ol>
<li>将抽象要求转换为具体要求 </li>
<li>检查I/O请求的合法性</li>
<li>读出和检查设备的状态 </li>
<li>传送必要的参数 </li>
<li>工作方式的设置 </li>
<li>启动I/O设备 </li>
</ol>
<h2 id="6">磁盘存储器管理</h2>

<p>磁盘存储器管理的目的：</p>
<ul>
<li>为文件分配存储空间</li>
<li>合理地组织文件地存储方式，以提高访问速度</li>
<li>提高磁盘存储空间地利用率</li>
<li>提高磁盘I/O速度，改善文件性能</li>
<li>确保文件系统的可靠性（备份）</li>
</ul>
<p>磁盘高速缓存的形式 ：</p>
<ol>
<li>在内存中开辟一个单独的存储空间来作为磁盘高速缓存，其大小是固定的，不会受应用程序多少的影响</li>
<li>把所有未利用的内存空间变为一个缓冲池，供请求分页系统和磁盘I/O时(作为磁盘高速缓存)共享。此时高速缓存的大小，显然不再是固定的。当磁盘I/O的频繁程度较高时，该缓冲池可能包含更多的内存空间；而在应用程序运行得较多时，该缓冲池可能只剩下较少的内存空间</li>
</ol>
<p>数据交付方式：</p>
<ul>
<li>数据交付：这是直接将高速缓存中的数据，传送到请求者进程的内存工作区中</li>
<li>指针交付：只将指向高速缓存中某区域的指针交付给请求者进程</li>
</ul>
<p>提高磁盘I/O速度的方法：</p>
<ol>
<li>提前读(Read-Ahead) </li>
<li>延迟写 </li>
<li>优化物理块的分布 </li>
<li>虚拟盘 </li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[操作系统：处理机调度与死锁]]></title>
      <url>http://www.codingbalian.online/2017/01/04/OS-Deadlock/</url>
      <content type="html"><![CDATA[<p>关于死锁的简单内容。<br><a id="more"></a></p>
<h2 id="1">处理机调度</h2>

<h3 id="1.1">高级、中级和低级调度</h3>

<ul>
<li>高级调度：也称为作业调度或长程调度，决定将外存上处于后备队列中的哪些作业调入内存，并为它们创建进程，排入就绪队列，准备执行。作业调度的时间尺度通常是分钟级。</li>
<li>低级调度：也称进程调度、短程调度，它决定就绪队列中的哪个进程获得处理机。进程调度的时间尺度通常是毫秒级的。      </li>
<li>中级调度：也称中程调度。引入中级调度的主要目的，是为了提高内存利用率和系统吞吐量。 </li>
</ul>
<p>中级调度的实现：把暂时不能运行的进程调至外存等待，此时的进程状态称为就绪驻外存状态或挂起状态。当又具备运行条件、且内存又稍有空闲时，由中级调度来决定把外存上的就绪进程重新调入内存，并修改其状态为就绪状态，挂在就绪队列上等待调度。涉及进程在内外存间的交换。</p>
<h3 id="1.2">进程调度的作用</h3>

<p>使用调度算法从就绪队列中选中一个进程，把CPU的使用权交给被选中的进程</p>
<h3 id="1.3">确定算法原则</h3>

<ul>
<li>公平性</li>
<li>资源利用率高</li>
</ul>
<h3 id="1.4">进程调度方式</h3>

<ul>
<li>非剥夺方式：分派程序把处理机分配给进程后便让它一直运行下去，直到进程完成或发生某事件而阻塞时，才把处理机分配给另一个进程。</li>
<li>剥夺方式：当一个进程正在运行时，系统可以基于某种原则，剥夺已分配给它的处理机，将之分配给其它进程。剥夺原则有：优先权原则、短进程优先原则、时间片原则。</li>
</ul>
<h3 id="1.5">进程调度性能衡量的指标</h3>

<ul>
<li>周转时间</li>
<li>响应时间</li>
<li>CPU-I/O执行期</li>
</ul>
<h3 id="1.6">调度准则</h3>

<ul>
<li>面向用户的准则：<ul>
<li>周转时间短，即作业从提交到完成（作业的周转时间T与系统为它提供服务的时间TS之比，即W=T/TS，称为带权周转时间）</li>
<li>响应时间快</li>
<li>截止时间的保证</li>
<li>优先权准则</li>
</ul>
</li>
<li>面向系统的准则：<ul>
<li>系统吞吐量高</li>
<li>处理机利用率好</li>
<li>各类资源的平衡利用</li>
</ul>
</li>
</ul>
<h2 id="2">进程调度算法</h2>

<h3 id="2.1">先进先出(FIFO)算法</h3>

<p>把处理机分配给最先进入就绪队列的进程，一个进程一旦分得处理机，便执行下去，直到该进程完成或阻塞时，才释放处理机。<br>优点:实现简单,有利于长作业,CPU繁忙型作业<br>缺点:没考虑进程的优先级,不利于I/O繁忙型作业</p>
<h3 id="2.2">短作业(进程)优先调度算法</h3>

<ul>
<li>短作业优先(SJF)的调度算法:从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行</li>
<li>短进程优先(SPF)调度算法:从就绪队列中选出一估计运行时间最短的进程，使它立即执行</li>
</ul>
<p>缺点：对长作业不利；不能保证紧迫性作业(进程)会被及时处理；根据用户估计可能存在错误</p>
<h3 id="2.3">最高优先权优先调度算法</h3>

<p>把处理机分配给就绪队列中具有最高优先权的进程。<br>决定优先权的方法：</p>
<ol>
<li>静态优先数法：静态优先权是在创建进程时确定的，在整个运行期间不再改变。依据有：进程类型；进程对资源的要求；用户要求的优先权。</li>
<li>动态优先数法：在进程创建时创立一个优先数，但在其生命周期内优先权可以随进程的推进或随其等待时间的增加而改变的，以便获得更好的调度性能。</li>
</ol>
<h3 id="2.4">高响应比优先调度算法</h3>

<p>$$优先权={等待时间+要求服务时间 \over 要求服务时间}={响应时间  \over 要求服务时间}$$</p>
<p>特点：</p>
<ol>
<li>作业等待时间相同，要求服务的时间愈短，其优先权愈高，有利于短作业</li>
<li>要求服务的时间相同时，等待时间愈长，其优先权愈高，因而它实现的是先来先服务</li>
<li>对于长作业，作业的优先级随等待时间的增加而提高，当其等待时间足够长时，其优先级便可升到很高， 从而也可获得处理机。  </li>
</ol>
<h3 id="2.5">转轮法</h3> 

<p>把CPU划分成若干时间片,并且按顺序赋给就绪队列中的每一个进程，进程轮流占有CPU，当时间片用完时，即使进程未执行完毕，系统也剥夺该进程的CPU，将该进程排在就绪队列末尾。同时系统选择另一个进程运行。</p>
<p>简单轮转法：系统将所有就绪进程按FIFO规则排队，按一定的时间间隔把处理机分配给队列中的进程。<br>多级队列方法：将系统中所有进程分成若干类，每类为一级。<br>时间片选择：固定时间片；可变时间片<br>与时间片大小有关的因素：系统响应时间(正比);就绪进程个数(反比);CPU能力 </p>
<h3 id="2.6">多队列反馈调度算法</h3> 

<ul>
<li>系统中设置多个就绪队列，并为各个队列赋予不同的优先级。第一个队列的优先级最高，第二个队列次之，其余各队列的优先权逐个降低</li>
<li>每个就绪队列分配给不同时间片，优先级高的为第一级队列，时间片最小，随着队列级别的降低，时间片加大</li>
<li>各个队列按照先进先出调度算法</li>
<li>一个新进程就绪后进入第一级队列</li>
<li>进程由于等待而放弃CPU后，进入等待队列，一旦等待的事件发生，则回到原来的就绪队列</li>
<li>当有一个优先级更高的进程就绪时，可以抢占CPU，被抢占进程回到原来一级就绪队列末尾</li>
<li>当第一级队列空时，就去调度第二级队列，如此类推</li>
<li>当时间片到后，进程放弃CPU，回到下一级队列，如此下去，一个长作业从第一队列依次降到第n队列</li>
</ul>
<h2 id="3">实时调度</h2>

<h3 id="3.1">基本条件</h3>

<ul>
<li>提供必要的信息(就绪时间、截止时间、处理时间、资源、优先级)</li>
<li>系统处理能力强</li>
<li>采用抢占式调度机制</li>
<li>具有快速切换机制</li>
</ul>
<h3 id="3.2">算法的分类</h3>

<ol>
<li>非抢占式调度算法:非抢占式轮转调度算法;非抢占式优先调度算法</li>
<li>抢占式调度算法:基于时钟中断的抢占优先调度算法;立即抢占优先权调度算法</li>
</ol>
<p>常用算法：<br>最早截止时间优先即EDF算法：只考虑了进程的截止时间，未考虑其运行时间<br>最低松弛度优先(LLF)算法：该算法是根据任务紧急(或松弛)的程度，来确定任务的优先级。该算法主要用于可抢占调度方式中。<br>松弛度=必须完成时间-其本身的运行时间-当前时间 </p>
<h3 id="3.2">多处理机系统中的调度</h3>

<ol>
<li>多处理器系统的类型<br>紧密耦合(Tightly Coupted)MPS:<br>通过高速总线或高速交叉开关，来实现多个处理器之间的互连的。它们共享主存储器系统和I/O设备，并要求将主存储器划分为若干个能独立访问的存储器模块，以便多个处理机能同时对主存进行访问。系统中的所有资源和进程，都由操作系统实施统一的控制和管理<br>松散耦合(Loosely Coupled)MPS:<br>通过通道或通信线路，来实现多台计算机之间的互连。每台计算机都有自己的存储器和I/O设备，并配置了OS来管理本地资源和在本地运行的进程,每一台计算机都能独立地工作， 必要时可通过通信线路与其它计算机交换信息，以及协调它们之间的工作</li>
<li>对称多处理器系统:<br>系统中所包含的各处理器单元，在功能和结构上都是相同的<br>非对称多处理器系统:<br>在系统中有多种类型的处理单元， 它们的功能和结构各不相同，其中只有一个主处理器</li>
<li>进程分配方式:<br>对称多处理器系统中的进程分配方式：<br>静态分配(Static Assigenment)方式<br>动态分配(Dynamic Assgement)方式<br>非对称MPS中的进程分配方式</li>
<li>进程(线程)调度方式<br>自调度(Self-Scheduling)方式<br>成组调度(Gang Scheduling)方式</li>
</ol>
<h2 id="4">死锁</h2>

<h3 id="4.1">死锁的概念</h3>

<p>一组进程中，每个进程都无限等待被该组进程中另一进程所占有的资源，因而永远无法得到的资源，这种现象称为进程死锁，这一组进程就称为死锁进程。</p>
<h3 id="4.2">死锁的原因</h3>

<ol>
<li>竞争系统资源<br>竞争非剥夺性资源<br>竞争临时性资源<br>只可使用一次的资源<br>“申请–分配–使用–释放”模式</li>
<li>进程的推进顺序不当 </li>
</ol>
<p>在同时具备下列四个条件时，就会产生死锁:</p>
<ul>
<li>互斥条件（资源独占）<br>在一段时间内，一个资源只能由一个进程独占使用，若别的进程也要求该资源，则须等待，直至其占用者释放</li>
<li>请求和保持条件<br>允许进程在不释放其已分得资源的情况下请求并等待分配新的资源</li>
<li>不剥夺条件（不可强占）<br>进程所获得的资源在未使用完之前，不能被其它进程强行夺走，而只能由其自身释放</li>
<li>环路等待条件<br>存在一个等待进程集合，P0正在等待一个P1占用的资源，P1正在等待一个P2占用的资源，…，Pn正在等待一个由PO占用的资源</li>
</ul>
<h2 id="5">解决死锁</h2>

<h3 id="5.1">预防死锁</h3>

<ol>
<li>破坏请求和保持条件<br>资源一次性分配；要求每个进程在运行前必须一次性申请它所要求的所有资源，且仅当该进程所要资源均可满足时才给予一次性分配</li>
<li>破坏不可剥夺条件<br>可剥夺资源:某进程新的资源未满足时，释放已占有的资源</li>
<li>破坏环路等待条件<br>资源有序分配法；系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反</li>
</ol>
<p>缺点:影响系统性能</p>
<h3 id="5.2">避免死锁</h3>

<p>系统对进程发出的能够满足的资源申请进行动态检查，若分配后系统可能发生死锁，则不予分配，否则予以分配。这种方法把系统分为安全状态和不安全状态，安全状态就不会发生死锁。</p>
<p><strong>安全状态与不安全状态</strong><br>安全状态指系统能按某种进程顺序来为每个进程分配其所需资源，直至最大需求，使每个进程都可顺序完成。若不存在这样的序列，则为不安全状态。</p>
<p>使用银行家算法可避免死锁：<br>可利用资源向量Available:含m个元素代表每种资源可利用的数目<br>最大需求矩阵Max:n<em>m的矩阵，n代表进程，m代表对资源的最大需求<br>分配矩阵Allocation:n</em>m<br>需求矩阵Need:n*m<br>Need［i,j］=Max［i,j］-Allocation［i,j］<br>Requesti是进程Pi的请求向量</p>
<ol>
<li>Requesti［j］≤Need［i,j］</li>
<li>如果Requesti［j］≤Available［j］，下一步；否则，Pi等待</li>
<li>Available［j］∶=Available［j］-Requesti［j］;<br>Allocation［i,j］∶=Allocation［i,j］+Requesti［j］;<br>Need［i,j］∶=Need［i,j］-Requesti［j］;</li>
<li>系统执行安全性算法，检查资源分配后，系统是否处于安全状态，若安全则分配</li>
</ol>
<h3 id="5.3">死锁检测</h3>

<p>当为进程分配资源时，如果未采取任何限制措施，则必须提供死锁检测和解除功能:<br>允许死锁发生，操作系统不断监视系统进展情况，判断死锁是否发生。<br>一旦死锁发生则采取专门的措施，解除死锁并以最小的代价恢复操作系统运行。</p>
<p>检测时机：</p>
<ul>
<li>进程等待时检测</li>
<li>定时检测</li>
<li>系统资源利用率下降时检测</li>
</ul>
<h3 id="5.4">死锁解除</h3>

<ol>
<li>重新启动</li>
<li>撤消进程</li>
<li>剥夺资源</li>
<li>进程回退</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JSP中Servlet的应用]]></title>
      <url>http://www.codingbalian.online/2016/12/29/JSP-Servlet/</url>
      <content type="html"><![CDATA[<p>Servlet是Java编写的服务器端程序，动态的生成Web内容。<br><a id="more"></a></p>
<p></p><h2 id="1">Servlet包的构成</h2><br>Servlet由服务器进行加载，是实现javax.servlet.Servlet接口的对象。大多数Servlet通过GenericServlet或者HttpServlet类来扩展实现。<br>Servlet API包含于javax.servlet和javax.servlet.http两个包中。javax.servlet包中定义了所有Servlet类都必须实现的接口和类：<p></p>
<ul>
<li>interface ServletConfig：定义Servlet config 对象，由Servlet 引擎用在 Servlet 初始化时，向 Servlet 传递信息。</li>
<li>interface ServletContext：定义Servlet用于获取容器信息的方法。</li>
<li>interface ServletRequest：向服务器请求信息。</li>
<li>interface ServletResponse：响应客户端请求。</li>
<li>interface Servlet：定义了所有 Servlet 必须实现的方法。</li>
<li>interface SingleThreadModel:用于保证Servlet在任一时刻只处理一个请求。</li>
<li>class ServletInputStream:用于读取客户请求的二进制数据。</li>
<li>class ServletOutputStream:向客户发送二进制数据。</li>
<li>class GenericServlet:继承Servlet接口，定义了一个通用的，独立协议的Servlet。</li>
</ul>
<p>javax.servle.http包中定义了采用HTTP通信的HttpServlet类：</p>
<ul>
<li>interface HttpServletRequest：提供http请求。</li>
<li>interface HttpServletResponse：提供http相应。</li>
<li>interface HttpSession：用于标识客户端并存储有关客户信息。</li>
<li>interface HttpSessionAttributeListener：需要用户获取回话的属性列表实现这个监听接口。</li>
<li>class HttpServlet：扩展GenericServlet用于创建HttpServlet。</li>
<li>class Cookie：创建一个Cookie类，用于存储Servlet发送给客户端的信息。</li>
</ul>
<p>Servlet的工作模式：</p>
<ol>
<li>客户端发送请求至服务器。</li>
<li>服务器启动并调用Servlet，根据客户端请求生成响应内容并传到服务器。</li>
<li>服务器将响应返回客户端。</li>
</ol>
<p></p><h3 id="1.1">GenericServlet</h3><br>一般通用Servlet由javax.servle的GenericServlet实现Servlet接口。它定义了一个通用独立于底层协议的Servlet。通过使用或者继承来实现Servlet应用。<br>GenericServlet的主要方法：<p></p>
<ul>
<li>String getInitParameter(String name):返回具有指定名称的初始化参数。</li>
<li>ServletConfig getServletConfig():返回传递到init()方法的ServletConfig对象。</li>
<li>ServletContext gerServletContext():返回在config对象中引用的ServletContext。</li>
<li>String getServletName():返回在web应用发布描述器(web.xml)中指定的Servlet名字。</li>
</ul>
<p></p><h3 id="1.2">HttpServlet</h3><br>javax.servle.http.HttpServlet实现了专门相应HTTP请求的Servlet。提供doGet(),doPost(),doDelete(),doOptions(),doPut(),doTrace()方法响应请求。<br>Web容器创建HttpServlet对象，并把HTTP请求封装到HttpServlet对象中。其相应web客户端的流程：<p></p>
<ol>
<li>web客户向web容器发送http请求</li>
<li>web容器解析请求</li>
<li>web容器创建一个HttpRequest对象，封装http请求信息</li>
<li>web容器创建一个HttpResponse对象</li>
<li>web容器调用service方法将之前两个对象作为service的参数传给HttpRequest对象</li>
<li>HttpServlet调用HttpRequest对象获取请求信息</li>
<li>HttpServlet调用HttpResponse生成响应数据】</li>
<li>web容器把HttpServlet传给web客户</li>
</ol>
<p>创建HttpServlet:</p>
<ol>
<li>继承HttpServlet抽象类</li>
<li>覆盖HttpServlet的部分方法</li>
<li>获取HTTP的请求信息</li>
<li>生成响应结果</li>
</ol>
<p></p><h3 id="1.3">Servlet生命周期</h3><br>Servlet框架的核心是javax.servlet.Servlet方法，它包含的三种方法代表了Servlet的生命周期：<p></p>
<ul>
<li>init():初始化Servlet。</li>
<li>service():负责对客户端的请求。</li>
<li>destory():当Servlet对象生命结束时释放占用的资源。</li>
</ul>
<p>Servlet只会在第一次请求到来时被加载和实例化。一旦被加载一般不会被删除，除非应用服务器关闭或者重新启动。当容器做内存回收动作时Servlet可能被删除。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">/*初始化Servlet*/</div><div class="line">public void init(ServletConfig config) throws ServletException&#123;</div><div class="line">	...</div><div class="line">&#125;</div><div class="line">/*init(ServletConfig)代表配置信息在web.xml中修改。*/</div><div class="line">/*响应客户端请求*/</div><div class="line">public void doPost(ServletRequest request, ServletResponse response)throws ServletException, IOException &#123;</div><div class="line">...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p></p><h3 id="1.4">配置web.xml</h3><br>建立mainServlet.java，配置web.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</div><div class="line">&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</div><div class="line">	xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee</div><div class="line">                      http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot;</div><div class="line">	version=&quot;3.1&quot;&gt;</div><div class="line">	&lt;display-name&gt;&lt;/display-name&gt;</div><div class="line">	&lt;!-- Servlet可以被外部访问 访问它需要一个地址 通过WEB的地址映射解决 --&gt;</div><div class="line">	&lt;servlet&gt;</div><div class="line">		&lt;servlet-name&gt;mainServlet&lt;/servlet-name&gt; &lt;!--定义Servlet应用名字 --&gt;</div><div class="line">		&lt;servlet-class&gt;cn.edu.ccnu.imd.mainServlet&lt;/servlet-class&gt;&lt;!--自定义的Servlet应用名字对应的具体Servlet文件 --&gt;</div><div class="line">	&lt;/servlet&gt;</div><div class="line"></div><div class="line">	&lt;servlet-mapping&gt; &lt;!--地址映射 --&gt;</div><div class="line">		&lt;servlet-name&gt;mainServlet&lt;/servlet-name&gt;</div><div class="line">		&lt;url-pattern&gt;/service.do&lt;/url-pattern&gt;&lt;!--地址名 --&gt;</div><div class="line">	&lt;/servlet-mapping&gt;</div><div class="line">	&lt;!--输入地址：http://localhost:端口号/service.do定位servlet--&gt;</div><div class="line">&lt;/web-app&gt;</div></pre></td></tr></table></figure><p></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[操作系统：进程管理]]></title>
      <url>http://www.codingbalian.online/2016/12/25/OS-Process/</url>
      <content type="html"><![CDATA[<p>简单介绍操作系统中的进程管理机制。<br><a id="more"></a></p>
<h2 id="1">进程特征</h2>

<ul>
<li>动态性：进程的实质是程序的一次执行过程，进程是动态产生，动态消亡的，进程在其生命周期内，在三种基本状态之间转换</li>
<li>并发性：任何进程都可以同其他进程一起向前推进<br>独立性：进程是一个能独立运行的基本单位，同时也是系统分配资源和调度的独立单位</li>
<li>异步性：由于进程间的相互制约，使进程具有执行的间断性，即进程按各自独立的、不可预知的速度向前推进</li>
<li>结构特征：为了控制和管理进程，系统为每个进程设立一个进程控制块:PCB</li>
</ul>
<h2 id="2">进程状态</h2>

<ul>
<li>就绪态：进程已分配到除CPU以外的所有必要资源</li>
<li>执行态：就绪态的进程获得CPU</li>
<li>阻塞态：正在执行的进程，由于某个事件而暂时无法执行，放弃CPU进入阻塞态(时间消失后由阻塞态进入就绪态) </li>
<li>创建状态：已构造进程标识符，创建管理进程所需的表格，由于资源有限还没有进入就绪队列</li>
<li>终止状态：中止后进程移入该状态，不再有执行资格但并未撤消，表格和其它信息暂时由辅助程序保留，其他进程可以利用这些信息，当数据不再需要后被删除</li>
<li>挂起状态：进程处于静止状态，包括静止就绪，静止阻塞</li>
</ul>
<h2 id="3">进程控制块PCB</h2>

<p>系统为了管理进程设置了一个专门的数据结构，存放了用于描述该进程情况和控制进程运行所需的全部信息：PCB，是系统感知进程存在的唯一标志，与进程一一对应。<br>PCB内容：</p>
<ul>
<li>进程标识符：标识一个进程的编号，进程的内部名</li>
<li>现行状态：说明进程的当前状态</li>
<li>现场保留区：保存进程由执行状态变为其它状态时的CPU现场信息 </li>
<li>程序与数据地址：该进程的程序和数据所在位置信息</li>
<li>互斥与同步机构：实现进程间互斥与同步时所必须的机构 </li>
<li>进程通信机制：用于实现进程间的通信所需的数据结构 </li>
<li>优先级：表示进程使用CPU时优先级别的一个整数 </li>
<li>资源清单：列出进程拥有的资源的记录</li>
<li>连接字：给出本进程所在队列中的下一个进程的PCB首址 </li>
<li>家族联系：用于说明本进程与其它家族成员间的关系</li>
</ul>
<p>进程映像：</p>
<ul>
<li>用户程序</li>
<li>用户数据</li>
<li>栈(用于过程调用和参数传递)</li>
<li>进程控制块PCB(执行上下文，包括控制进程所需的数据：处理器状态信息，进程标识符信息，进程控制信息)</li>
</ul>
<p>PCB的组织方式：</p>
<ol>
<li>连接方式：不同状态的进程分别组成队列：运行队列、就绪队列、等待队列</li>
<li>索引方式：相同状态的进程设置各自的PCB索引表表面地址</li>
</ol>
<h2 id="4">进程控制</h2>

<p>一般是由操作系统的内核通过执行各种原语操作来对系统中所有进程从产生、存在到消亡的全过程管理和控制。</p>
<ul>
<li>内核：加在硬件上的第一层软件，通过执行各种原语操作来实现各种控制和管理功能，具有创建、撤消、进程通信、资源管理的功能</li>
<li>内核的基本功能:支撑功能：中断处理、时钟管理、原语操作;资源管理功能：进程管理、存贮管理、设备管理</li>
<li>原语：是由若干条机器指令所构成，用以完成特定功能的一段程序</li>
</ul>
<h3 id="4.1">创建原语</h3>

<ul>
<li>功能：创建一个具有指定标识符进程</li>
<li>入口信息：进程标识符、优先级、进程开始地址、初始CPU状态、资源清单等</li>
</ul>
<p>进程创建过程</p>
<ol>
<li>创建一个PCB</li>
<li>赋予一个统一进程标识符</li>
<li>为进程映象分配空间</li>
<li>初始化进程控制块</li>
<li>设置相应的链接</li>
</ol>
<p>创建原语的实现过程:</p>
<ol>
<li>查PCB总链</li>
<li>向PCB资源地申请空的PCB结构</li>
<li>将入口信息填入PCB对应项</li>
<li>PCB入就绪队列，入总链</li>
</ol>
<h3 id="4.2">撤销原语</h3>

<ul>
<li>功能：撤消一个指定的进程</li>
<li>入口信息：被撤消的进程名</li>
<li>实现:收回进程所占有的资源,撤消该进程的PCB</li>
</ul>
<p>撤消原语的实现过程：</p>
<ol>
<li>在总链中查需要撤销的PCB</li>
<li>将该列进程从现行队列的总链中摘除</li>
<li>回收该进程的资源</li>
<li>若有子进程：将子进程的PCB从有关链中摘除并回收</li>
<li>回收PCB</li>
</ol>
<h3 id="4.3">阻塞原语</h3><br>处于运行状态的进程，在其运行过程中期待某一事件发生，当被等待的事件未发生时，由进程自己执行阻塞原语，使自己由运行态变为阻塞态。<br>阻塞原语实现过程：<br>1. 将现行进程的CPU现场送到该进程的PCB保护现场<br>2. 设置该进程为阻塞<br>3. 把该进程插入相应的等待队列<br><br><h3 id="4.4">唤醒原语</h3>

<ul>
<li>功能：唤醒某一处于等待队列当中的进程</li>
<li>入口信息：被唤醒进程的名字</li>
</ul>
<p>唤醒原语的实现：</p>
<ol>
<li>从相应的等待队列中摘下该进程PCB</li>
<li>设置该进程为就绪</li>
<li>将PCB插入就绪队列</li>
</ol>
<h3 id="4.5">挂起与激活原语</h3>

<ul>
<li>挂起原语的功能：自身挂起、挂起具有指定标识符的进程、将其进程及其全部或部分子孙进程挂起</li>
<li>激活原语功能：使处于静止状态的进程变为活动</li>
</ul>
<h2 id="5">线程</h2>

<h3 id="5.1">线程简介</h3>

<p>进程拥有资源、是调度单位，系统对进程需要完成的操作：创建进程、撤销进程、进程切换，但是操作时间空间开销大，限制并发度高，因此将进程的两个属性分开，将线程作为调度单位，只拥有必要资源。</p>
<p>线程的特点：</p>
<ol>
<li>是进程的一个实体，可作为系统独立调度和分派的基本单位</li>
<li>不拥有系统资源(只拥有从属进程的全部资源，资源是分配给进程)</li>
<li>一个进程中的多个线程可并发执行(进程可创建线程执行同一程序的不同部分) </li>
<li>系统开销小、切换快(进程的多个线程都在进程的地址空间活动)</li>
</ol>
<p>引入线程的优点：</p>
<ol>
<li>创建一个新线程花费时间少</li>
<li>两个线程的切换花费时间少</li>
<li>因为同一进程内的线程共享内存和文件，因此它们之间相互通信无须调用内核</li>
<li>适合多处理机系统</li>
</ol>
<h3 id="5.2">线程的实现机制</h3>


<ul>
<li>用户级线程UTL<ul>
<li>由应用程序完成所有线程的管理</li>
<li>通过线程库(用户空间)</li>
<li>一组管理线程的过程</li>
<li>核心不知道线程的存在，但仍然管理线程的进程的活动</li>
<li>线程切换不需要核心态特权</li>
<li>调度是应用特定的</li>
<li>当线程调用系统调用时，整个进程阻塞</li>
<li>线程状态是与进程状态独立的</li>
</ul>
</li>
</ul>
<p>优点：</p>
<ul>
<li>线程切换不调用核心</li>
<li>调度是应用程序特定的：可以选择最好的算法</li>
<li>ULT可运行在任何操作系统上（只需要线程库）</li>
</ul>
<p>缺点：</p>
<ul>
<li>大多数系统调用是阻塞的，因此核心阻塞进程，故进程中所有线程将被阻塞</li>
<li>核心只将处理器分配给进程，同一进程中的两个线程不能同时运行于两个处理器上</li>
</ul>
<ul>
<li>核心级线程KTL<ul>
<li>所有线程管理由核心完成</li>
<li>没有线程库，但对核心线程工具提供API</li>
<li>核心维护进程和线程的上下文</li>
<li>线程之间的切换需要核心支持</li>
<li>以线程为基础进行调度 </li>
</ul>
</li>
</ul>
<p>优点:</p>
<ul>
<li>对多处理器，核心可以同时调度同一进程的多个线程</li>
<li>阻塞是在线程一级完成</li>
<li>核心例程是多线程的</li>
</ul>
<p>缺点：</p>
<ul>
<li>在同一进程内的线程切换调用内核，导致速度下降</li>
</ul>
<ul>
<li>两者结合<ul>
<li>线程创建在用户空间完成</li>
<li>大量线程调度和同步在用户空间完成</li>
<li>以调整KLT的数量</li>
</ul>
</li>
</ul>
<h2 id="6">进程同步</h2>

<p>在多道程序系统中，系统中的多个进程存在两种关系：</p>
<ul>
<li>相互合作（直接作用）<ul>
<li>进程间存在相互合作地关系</li>
<li>进程同步的任务：保证各进程在执行次序上不出现与时间有关的差错</li>
</ul>
</li>
<li>资源共享（间接作用）：<ul>
<li>进程间彼此无关，但因为同处一个系统，必然存在资源共享的关系。</li>
<li>进程同步的任务：保证各进程能互斥地访问临界资源</li>
</ul>
</li>
</ul>
<p>这两种关系这需要用进程互斥与同步机制来协调。<br>进程同步的主要任务是使并发执行的进程间有效的共享资源和相互合作，同步机制：信号量、P.V操作。</p>
<h3 id="6.1">基本概念</h3>

<ul>
<li>进程互斥：由于各进程要求共享资源，而有些资源需要互斥使用，因此各进程间竞争使用这些资源，进程的这种关系为进程的互斥。</li>
<li>进程同步：指多个相关进程在执行次序上的协调。</li>
<li>临界资源:系统中某些资源一次只允许一个进程使用，称这样的资源为临界资源或互斥资源或共享变量。</li>
<li>临界区：在进程中涉及到临界资源的程序段</li>
<li>相关临界区：多个进程的临界区</li>
</ul>
<h3 id="6.2">使用互斥区的原则</h3>

<ul>
<li>空闲让进：当无进程在互斥区时，任何有权使用互斥区的进程可进入</li>
<li>忙则等待：不允许两个以上的进程同时进入互斥区</li>
<li>有限等待：任何进入互斥区的要求应在有限的时间内得到满足</li>
<li>让权等待：处于等待状态的进程应放弃占用CPU，以使其他进程有机会得到CPU的使用权</li>
</ul>
<h3 id="6.3">信号与P.V操作</h3>

<p>信号量semaphore：是一个数据结构<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">定义： </div><div class="line"> struc semaphore </div><div class="line"> &#123;</div><div class="line">	int value; //信号量</div><div class="line">	pointer_PCB queue; //队列操作</div><div class="line">  &#125;</div><div class="line">声明：</div><div class="line">  semaphore s;</div></pre></td></tr></table></figure></p>
<p>P操作：请求分配一个单位资源<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">P(s)</div><div class="line">&#123;</div><div class="line">  s.value = s.value --;</div><div class="line">  if (s.value &lt; 0)</div><div class="line">  &#123;</div><div class="line">	 该进程状态置为等待状态</div><div class="line">   将该进程的PCB插入相应的等待队列末尾s.queue;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>V操作：意味着释放一个单位资源<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">V(s)</div><div class="line">&#123;</div><div class="line">  s.value = s.value ++;</div><div class="line">  if (s.value &lt; = 0)</div><div class="line">  &#123;</div><div class="line">   唤醒相应等待队列s.queue中等待的一个进程</div><div class="line">   改变其状态为就绪态，并将其插入就绪队列</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>信号量必须且只能置一次非负的初值，且只能进行PV操作。</p>
<ul>
<li>P(S)表示申请一个资源 </li>
<li>V(S)表示释放一个资源。</li>
<li>信号量的初值应该大于等于0</li>
<li>S&gt;0表示有S个资源可用</li>
<li>S=0表示无资源可用</li>
<li>S&lt;0则|S|表示等待队列中的进程个数S个 </li>
</ul>
<p>P.V操作必须成对出现，有一个P操作就一定有一个V操作</p>
<ul>
<li>当为互斥操作时，它们同处于同一进程</li>
<li>当为同步操作时，则不在同一进程中出现</li>
<li>如果P(S1)和P(S2)两个操作在一起，那么P操作的顺序至关重要，一个同步P操作与一个互斥P操作在一起时同步P操作在互斥P操作前</li>
</ul>
<h3 id="6.4">AND信号量集</h3>

<p>AND型信号量集是指同时需要多种资源,将进程在整个运行过程中需要的所有资源，一次性全部地分配给进程，待进程使用完后再一起释放。只要有一个资源未能分配给进程，其他的资源也都不分配。对若干个临界资源的分配，要么全部分配到进程，要么一个也不分配。 这样就可避免上述死锁情况的发生。为此，在wait操作中，增加了一个“AND”条件，故称为AND同步。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Swait(S1, S2, …, Sn)&#123;AND型信号量P原语；</div><div class="line">	while (TRUE)&#123;</div><div class="line">		if (S1 &gt;=1 &amp;&amp; S2 &gt;= 1 &amp;&amp; … &amp;&amp; Sn &gt;= 1)&#123;//满足资源要求时的处理；</div><div class="line">	   		for (i = 1; i &lt;= n; ++i) -–Si;</div><div class="line">    //注：与P的处理不同，这里是在确信可满足资源要求时，才进行减1操作；</div><div class="line">			break;</div><div class="line">		&#125;</div><div class="line">		else&#123;	//某些资源不够时的处理；</div><div class="line">   			调用进程进入第一个小于1信号量的等待队列Sj.queue;</div><div class="line">   			阻塞调用进程;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">Ssignal(S1, S2, …, Sn)//V操作</div><div class="line">&#123;</div><div class="line">for (i = 1; i &lt;= n; ++i)</div><div class="line">  &#123;</div><div class="line">    ++Si;		//释放占用的资源；</div><div class="line">    for (在Si.queue中等待的每一个进程P)</div><div class="line">    //检查每种资源的等待队列的所有进程；</div><div class="line">    &#123;</div><div class="line">    从等待队列Si.queue中取出进程P;</div><div class="line">    if (判断进程P是否通过Swait中的测试)</div><div class="line">       //注：与signal不同，这里要进行重新判断；</div><div class="line">      &#123;//通过检查（资源够用）时的处理；</div><div class="line">      进程P进入就绪队列;</div><div class="line">      &#125;</div><div class="line">    else</div><div class="line">      &#123;//未通过检查（资源不够用）时的处理；</div><div class="line">      进程P进入某等待队列；</div><div class="line">      &#125;</div><div class="line">   &#125;</div><div class="line"> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="6.5">一般信号量集</h3>

<ol>
<li>一般信号量集是指同时需要多种资源、每种占用的数目不同、且可分配的资源还存在一个临界值时的信号量处理 </li>
<li>一般信号量集的基本思路就是在AND型信号量集的基础上进行扩充，在一次原语操作中完成所有的资源申请。</li>
</ol>
<p>进程对信号量Si：</p>
<ul>
<li>测试值为ti（表示信号量的判断条件，要求Si &gt;= ti；即当资源数量低于ti时，便不予分配）</li>
<li>占用值为di（表示资源的申请量，即Si = Si - di）</li>
</ul>
<p>对应的P、V原语格式为：<br><code>Swait(S1, t1, d1; ...; Sn, tn, dn);</code><br><code>Ssignal(S1, d1; ...; Sn, dn);</code></p>
<p>几种特殊情况:<br><code>Swait(S, d, d)</code>表示每次申请d个资源，当少于d个时，便不分配<br><code>Swait(S, 1, 1)</code>表示互斥信号量<br><code>Swait(S, 1, 0)</code>可作为一个可控开关（当S&gt;=1时，允许多个进程进入临界区；当S=0时，禁止任何进程进入临界区）</p>
<p>P.V机制的缺点：</p>
<ol>
<li>易读性差，因为要了解对于一组共享变量及信号量的操作是否正确，则必须通读整个系统或者并发程序</li>
<li>不利于修改和维护，因为程序的局部性很差，所以任一组变量或一段代码的修改都可能影响全局</li>
<li>正确性难以保证，因为操作系统或并发程序通常很大，要保证这样一个复杂的系统没有逻辑错误是很难的</li>
</ol>
<h2 id="7">管程机制</h2>

<h3 id="7.1">管程概念</h3>

<blockquote>
<p>管程是关于共享资源的数据及在其上操作的一组过程或共享数据结构及其规定的所有操作。<br>系统按资源管理的观点分解成若干模块，用数据表示抽象系统资源，同时分析了共享资源和专用资源在管理上的差别，按不同的管理方式定义模块的类型和结构，使同步操作相对集中，从而增加了模块的相对独立性。</p>
</blockquote>
<h3 id="7.2">管程组成</h3>

<ul>
<li>名称</li>
<li>数据结构说明</li>
<li>对该数据结构进行操作的一组过程/函数</li>
<li>初始化语句</li>
</ul>
<h3 id="7.3">管程的特性</h3>

<ul>
<li>模块化:一个管程是一个基本程序单位，可以单独编译</li>
<li>抽象数据类型:管程是一种特殊的数据类型，其中不仅有数据，而且有对数据进行操作的代码</li>
<li>信息掩蔽:管程是半透明的，管程中的局部过程（函数）实现了某些功能，至于这些功能是怎样实现的，在其外部则是不可见的</li>
</ul>
<h3 id="7.4">管程的要素</h3>

<ul>
<li>管程中的共享变量在管程外部是不可见的，外部只能通过调用管程中所说明的外部过程（函数）来间接地访问管程中的共享变量</li>
<li>为了保证管程共享变量的数据完整性，规定管程互斥进入</li>
<li>管程通常是用来管理资源的，因而在管程中应当设有进程等待队列以及相应的等待及唤醒操作</li>
</ul>
<p>在管程内部可以说明和使用一种特殊类型的变量，称作条件变量：<code>VAR C:condition</code><br>对于条件型变量，可以执行wait和signal操作：<br>wait（c）：如果紧急等待队列非空，则唤醒第一个等待者；否则释放管程的互斥权，执行此操作的进程的PCB入c链尾部<br>signal（c）：如果c链为空，则相当于空操作，执行此操作的进程继续；否则唤醒第一个等待者，执行此操作的进程的PCB入紧急等待队列的尾部</p>
<h3 id="7.5">管程实现</h3>

<ol>
<li>直接构造(效率高)</li>
<li>间接构造，即用某种已经实现的同步机制去构造</li>
</ol>
<h3 id="7.5">管程和进程的异同</h3>

<ol>
<li>设置进程和管程的目的不同</li>
<li>系统管理数据结构:进程：PCB;管程：等待队列</li>
<li>管程被进程调用</li>
<li>管程是操作系统的固有成分，无创建和撤消</li>
</ol>
<h2 id="8">进程通信</h2>


<blockquote>
<p>P.V操作实现的是进程之间的低级通讯，只能传递简单的信号,如果要在进程间传递大量信息则要用Send/Receive原语。</p>
</blockquote>
<h3 id="8.1">实现进程通信的方式</h3>

<ul>
<li>共享存储器系统(Shared-Memory System)<ul>
<li>共享数据结构方式</li>
<li>共享存储区方式</li>
</ul>
</li>
<li>消息传递系统(Message passing system)</li>
<li>管道(Pipe)通信<ul>
<li>用于连接一个读进程和一个写进程以实现他们之间通信的一个共享文件 </li>
<li>写进程以字符流形式将大量的数据送入管道，读进程从管道中接收数据</li>
</ul>
</li>
</ul>
<h3 id="8.2">通信实现的方式</h3>

<ol>
<li><p>直接通信方式<br>指发送进程利用OS所提供的发送命令，直接把消息发送给目标进程<br><code>Send(Receiver, message);</code>发送一个消息给接收进程<br><code>Receive(Sender, message);</code>接收Sender发来的消息</p>
</li>
<li><p>间接通信方式<br>进程间通过中间媒介：信箱实现通信。</p>
</li>
</ol>
<p>信箱包括：</p>
<ul>
<li>私用信箱</li>
<li>公用信箱</li>
<li>共享信箱<br><code>Send(mailbox, message);</code>将一个消息发送到指定信箱<br><code>Receive(mailbox, message);</code>从指定信箱中接收一个消息</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[操作系统:存储管理]]></title>
      <url>http://www.codingbalian.online/2016/12/24/OS-Storage%20Management/</url>
      <content type="html"><![CDATA[<blockquote>
<p>存储管理可以提高主存的利用率，共享某个区域的信息，保证程序都在各自的存储区内操作，互不干扰。<br><a id="more"></a></p>
</blockquote>
<h2 id="1">存储管理基本概念</h2>

<ol>
<li>定位（存储分配）：为具体的程序和数据等分配存储单元或存储区工作。</li>
<li>映射：把逻辑地址转换为相应的物理地址的过程。</li>
<li>隔离：按存取权限把合法区与非法区分隔，实现存储保护。</li>
<li>名空间：程序中定义的标识符，程序符号集合，没有地址的概念，包括：符号指令、数据说明、I/O说明。</li>
<li>地址空间：程序用来访问信息所用地址单元的集合，是逻辑地址的集合，由编译程序生成。</li>
<li>存储空间：主存中物理单元的集合，物理地址的集合。</li>
<li>逻辑地址：程序形成目标代码使用的首地址为0的相对地址。</li>
<li>物理地址：内存中存储单元的地址，可直接寻址。</li>
</ol>
<p>内存共享：</p>
<ul>
<li>两个或多个进程共用内存中相同区域</li>
<li>节省内存空间，提高内存利用率</li>
<li>实现进程通信(数据共享)</li>
</ul>
<p>存储保护：</p>
<ul>
<li>保护系统程序区不被用户侵犯</li>
<li>不允许用户程序读写不属于自己地址空间的数据</li>
</ul>
<h2 id="2">程序的装入和链接</h2>

<h3 id="2.1">装入方式</h3>

<ul>
<li><p>绝对装入方式：程序使用的绝对地址在编译或者汇编时给出，或者采用符号地址在编译汇编中转为绝对地址。由于编译程序不能预知所编译的目标模块在内存中的位置，因此，只适用于单道程序环境。</p>
</li>
<li><p>可重定位装入方式：在多道程序环境下，使用的目标模块起始地址通常为0，再把逻辑地址映射到物理地址。但一个进程被多次换入换出位置通常不同，因此无法满足。</p>
</li>
<li><p>动态运行时装入方式：把装入模块装入内存后仍然使用相对地址，到程序真正要执行时才改为转换为绝对地址。</p>
</li>
</ul>
<h3 id="2.2">程序的链接</h3>

<p>程序的处理步骤：</p>
<ol>
<li>编译程序产生目标模块和所需的库函数</li>
<li>链接程序</li>
<li>装入模块</li>
<li>装入程序到内存中</li>
</ol>
<ul>
<li><p>装入时静态链接方式：装入前链接，以后不再拆开</p>
</li>
<li><p>装入时动态链接：边装入边链接,装入一个目标模块时，若发生一个外部模块调用，装入程序将找出相应的外部目标模块，并装入内存。</p>
</li>
</ul>
<p>动态链接的优点:便于软件版本的更新和修改，实现对目标模块的共享。<br>动态链接的缺点:在进程整个执行期间，装入模块是不改变的，每次运行时的装入模块是相同的。</p>
<ul>
<li>运行时的动态链接：将对某些模块的链接推迟到执行时才执行，可加快程序的装入过程，而且可节省大量的内存空间。 </li>
</ul>
<h2 id="3">连续分配存储管理方式</h2>

<h3 id="3.1">单一连续分配</h3>

<p>在单道环境下（单用户系统、单道批处理系统）进程执行时除了系统占用一部分主存外，剩下的主存区域全部归它占用。<br>主存划分为：系统区、用户区。系统区供操作系统使用，用户区是一个连续的存储区所以又称单用户存储管理。<br>单用户系统在一段时间内，只有一个进程在内存，故内存分配管理十分简单，但内存利用率低。<br>工作流程：<br>单一连续区分配采用静态分配和静态重定位方式，即作业或进程一旦进入主存，就一直等到它运行结束后才能释放主存。<br>存储保护：由装入程序检查其绝对地址是否超越，若超越则自动修改地址。<br>缺点：</p>
<ol>
<li>主存利用率不高。</li>
<li>程序的运行受主存容量限制。</li>
<li>不支持多道。      </li>
</ol>
<h3 id="3.2">固定分区分配</h3>

<p>分区式将内存划分成若干个连续区域，满足多道程序，每个分区只能存储一个程序，且程序只能在此分区中运行。<br>通过设置内存分配表分配内存。</p>
<p>划分内存方法：<br>分区大小相等：<br>适用于控制多个相同对象的场合。<br>分区大小不等：<br>多个较小分区、适量中等分区、少量大分区</p>
<h3 id="3.3">动态分区分配</h3>

<p>内存等作业装入时，根据其需求和内存空间的使用情况来决定是否分配。</p>
<p>分区分配中的数据结构：</p>
<ol>
<li>分区分配表 </li>
<li>空闲分区链：空闲块的前后设置两个单元，放置必要的说明信息和指针。系统只要设立一个链首指针，指向第一个空闲块即可。分配程序可以依照自由块链表，来查找适合的空闲块进行分配。</li>
</ol>
<h3 id="3.4">分配算法</h3>

<p>按照空闲块的连接方式分为四种算法：</p>
<ul>
<li><p>最佳适应算法：</p>
<ul>
<li>接到内存申请时，在空闲块表中找到一个不小于且大小最接近于作业所要求的存储区域</li>
<li>要求将空闲区按大小顺序形成空闲区链</li>
<li>用最小空间满足要求，保留大的空闲区 </li>
<li>当次最优，但宏观上未必最优，每次分配后所分割下的剩余部分，总是最小很难再利用，从而形成碎块。</li>
</ul>
</li>
<li><p>最坏适应算法</p>
<ul>
<li>接到内存申请时，在空闲块表中找到一个不小于且最大的空白区。</li>
<li>尽量利用存储空间，节约时间和开销，当分割后空闲块仍为较大空块，但是空间浪费比较大，碎片多。</li>
</ul>
</li>
<li><p>首次适应法</p>
<ul>
<li>要求空闲分区链以地址递增的次序链接。分配内存时，从链首开始顺序查找，直到找到满足其大小要求的空闲为止。</li>
<li>优先利用内存低址区，从而保留高址部分的大空闲区，但会在低址区留下很多碎片，而每次查找又都是从低址区开始，增加查找空闲分区的开销。</li>
</ul>
</li>
<li><p>下次适应法</p>
<ul>
<li>总是从上次查找结束的地方开始，找到一个足够大的空白区分配。</li>
<li>减小查找空闲分区开销，使内存中的空闲分区分布更均匀，但会缺乏大的空闲分区。</li>
</ul>
</li>
</ul>
<p>分区式存储管理的优点:</p>
<ul>
<li>便于动态申请内存</li>
<li>便于共享内存</li>
<li>便于动态链接<br>分区式存储管理的缺点:</li>
<li>碎片问题(外碎片)</li>
<li>内存利用率不高</li>
<li>受实际内存容量限制</li>
</ul>
<h3 id="3.5">可重定位分区分配</h3>

<p>碎片问题:<br>经过分配回收后，内存中存在很多小的空闲块,被称为碎片。这些碎片不足以满足分配要求，但其总和满足分配要求。<br>通过在内存移动程序，将所有小的空闲区域合并为大的空闲区域来解决碎片问题：紧凑技术。</p>
<p>经过紧凑后的用户程序在内存中对的位置发生了变化，若不对程序和数据的地址进行修改，则程序无法运行。这种地址的变换称为重定位。</p>
<ul>
<li>静态重定位:当用户程序被装入内存时，一次性实现逻辑地址到物理地址的转换，以后不再转换，作业i在执行前一次变址，直到该作业完成退出内存为止。</li>
<li>动态重定位:在程序运行过程中要访问数据时再进行地址变换。由地址变换机构进行的地址变换，硬件上需要重定位寄存器的支持。</li>
</ul>
<p>优点:消除内存碎片，提高内存利用率。<br>缺点:提高硬件成本，紧凑时花费CPU时间。</p>
<h2 id="4">分页存储管理</h2>

<p>使用动态分区的存储空间存在碎片问题，使用“紧凑”移动大量信息花去不少的处理机时间，将一个进程直接分散地分配到许多不相邻的分区中，就不必再进行“紧凑”，即离散分配方式。</p>
<p>分页存储管理是将一个进程的逻辑地址空间分成若干个大小相等的片，称为页，并为各页加以编号，从0开始；把内存空间分成与页面相同大小的若干个存储块，称为块或页框， 加以编号。在为进程分配内存时，以块为单位将进程中的若干个页分别装入到多个可以不相邻接的物理块中。<br>由于进程的最后一页经常装不满一块而形成了不可利用的碎片，称之为“页内碎片”。<br>页面通常为8~512KB<br>页面太小：<br>使内存碎片减小，从而减少了内存碎片的总空间， 有利于提高内存利用率；<br>使每个进程占用较多的页面，从而导致进程的页表过长，占用大量内存；还会降低页面换进换出的效率。<br>页面较大<br>减少页表的长度，提高页面换进换出的速度，但却会使页内碎片增大。</p>
<p>页表：<br>一个页表中包含若干个表目，表目的自然序号对应于用户程序中的页号，表目中的块号是该页对应的物理块号。<br>实现从作业的逻辑地址（页号）到其在主存中的物理地址（块号）间的地址映射。<br>页表的每一个表目除了包含指向页框的指针外，还包括一个存取控制字段。<br>表目也称为页描述子。</p>
<h3 id="4.1">具有快表的地址变换机构</h3>

<p>把页表放在主存中会影响系统的性能。因为每次访问主存，首先必须访问页表，读出页描述子，之后根据形成的实际地址再访问主存，这样使访问主存的次数加倍，因而使总的处理速度明显下降。<br>因此采用一组硬件寄存器，存放当前访问过的页的页描述子，<br>每次访问主存时，首先查找快表，若找到所需的页描述子，则快速形成物理地址。否则从页表中查找后形成物理地址，同时把页描述子写入快表。如果设计得当，快表的命中率可以很高。 </p>
<h3 id="4.2">两级页表</h3>

<p>由于现在的计算机支持非常大的逻辑地址空间(232~264)。页表就变得非常大，要占用相当大的内存空间。</p>
<p>解决方法：</p>
<ol>
<li>采用离散分配方式来解决难以找到一块连续的大内存空间的问题：</li>
<li>只将当前需要的部分页表项调入内存，其余的页表项仍驻留在磁盘上，需要时再调入。 </li>
</ol>
<p>将页表进行分页，使每个页面的大小与内存物理块的大小相同，可以离散地将各个页面分别放在不同的物理块中。<br>要为离散分配的页表再建立一张页表，称为外层页表，在每个页表项中记录页表页面的物理块号。</p>
<p>对于64位机器，对于外层页表还需要进行分页，即采用多级页表。</p>
<h2 id="5">分段存储管理</h2>

<p>在分页存储系统中，作业的地址空间是一维线性的，这破坏了程序内部天然的逻辑结构,造成共享、保护的困难。<br>使用分段式存储管理可以方便编程、信息共享、信息保护、动态链接、动态增长。</p>
<p>段表：记录了段号，段的首（地）址和长度之间的关系。<br>段表始址寄存器：<br>用于保存正在运行进程的段表的始址。<br>段表长度寄存器：<br>用于保存正在运行进程的段表的长度。</p>
<p>分页由系统实现，大小固定，作业地址是单一的线性地址空间，段由用户编写的程序决定，长度不固定，需要段名和段内地址。</p>
<p>优点：<br>便于动态申请内存<br>管理和使用统一化<br>便于共享<br>便于动态链接<br>缺点：<br>产生碎片</p>
<h2 id="6">交换与覆盖</h2>

<p>躲到环境下的问题：<br>内存中某些进程阻塞后仍占据内存<br>外存上尚有许多作业，因无内存而不能进入</p>
<h3 id="6.1">覆盖技术</h3>

<p>覆盖技术主要用在早期的操作系统中。<br>把程序划分为若干个功能上相对独立的程序段，按照其自身的逻辑结构将那些不会同时执行的程序段共享同一块内存区域<br>程序段先保存在磁盘上，当有关程序段的前一部分执行结束，把后续程序段调入内存，覆盖前面的程序段<br>覆盖：一个作业的若干程序段，或几个作业的某些部分共享某一个存储空间<br>一般要求作业各模块之间有明确的调用结构，向系统指明覆盖结构，然后由由操作系统完成自动覆盖。<br>缺点：对用户不透明，增加用户负担。</p>
<h3 id="6.2">交换技术</h3>

<p>交换技术多用于分时系统中，当内存空间紧张时，把内存中暂时不能运行的进程或者暂时不用的程序和数据，调出到外存上，再把已具备运行条件的进程或进程所需要的程序和数据，调入内存，占据前者所占用的区域，这种技术是进程在内存与外存之间的动态调度。</p>
<p>选择原则：只能换出非共享的程序和数据段。忧先选择处于阻塞状态且优先级最低的进程作为换出进程，为防止低优先级进程刚进来就被换出，在选择换出进程时，要考虑换出的进程的内存驻留时间。从不换出处于等待I/O状态的进程。<br>交换时机：只要不用就换出;只在内存空间不够或有不够的危险时换出。</p>
<p>与覆盖的区别：<br>与覆盖技术相比，交换技术不要求用户给出程序段之间的逻辑覆盖结构；而且，交换发生在进程或作业之间。<br>覆盖发生在同一进程或作业内。此外，覆盖只能覆盖那些与覆盖段无关的程序段。</p>
<h2 id="7">段页存储管理 </h2>

<p>内存划分：按页式存储管理方案<br>内存分配：以页为单位进行分配<br>逻辑地址：段号、段内地址（段内页号、页内地址）</p>
<p>地址变换过程：</p>
<ol>
<li>从控制寄存器读取段表始址，找到段表；</li>
<li>段号＋段表始址 得到段描述子地址；</li>
<li>从段描述子读取页表始址，找到页表；</li>
<li>页号＋页表始址 得到页描述子地址；</li>
<li>从页描述子读取物理块号；</li>
<li>物理块号＋页内位移量 得到物理地址。</li>
</ol>
<h2 id="8">虚拟存储器</h2>

<p>常规存储器管理方式的特征：<br>一次性（一次性将作业全部装入）<br>驻留性（作业长期驻留内存）<br>出现的问题：<br>暂时不用的进程占用大量内存，使得需要运行的作业无法装入<br>大于内存容量的作业无法装入</p>
<p>虚拟存储器的基本思想是：程序、数据、堆栈的大小可以超过内存的大小，操作系统把程序当前使用的部分保留在内存，而把其它部分保存在磁盘上，并在需要时在内存和磁盘之间动态交换。<br>所谓虚拟存储器，是指具有请求调入功能和置换功能,能从逻辑上对内存容量进行扩充的存储器系统。<br>其逻辑容量（虚存）由内存容量和外存容量之和所决定，其运行速度接近于内存速度，而每位的成本却又接近于外存。<br>对用户：指令地址部分所限定的比实存大得多的地址实间。<br>对系统：借助于各种表格机构，体现虚拟实间。     </p>
<p>虚拟存储器的实现方式是建立在离散分配存储管理方式的基础上：请求分页与请求分段。</p>
<h2 id="9">请求分页存储管理</h2>

<p>请求式分页管理系统在进程开始运行之前，不是装入全部页面，而是装入一个或零个页面，之后根据进程运行的需要，动态装入其它页面；当内存空间已满，而又需要装入新的页面时，则根据某种算法淘汰某个页面，以便装入新的页面。</p>
<p>页表项：页号；状态位；物理块号；外存地址；访问位；修改位。</p>
<p>页面中断：当存在位指示该页不在主存时，则引起一个缺页中断发生，相应的中断处理程序把控制转向缺页中断子程序。<br>执行缺页中断子程序，根据页表中给出的外存地址，将该页调入内存，使作业继续运行下去。<br>如果内存中有空闲块，则分配一页，将新调入页装入内存，并修改页表中相应页表项目的驻留位及相应的内存块号。<br>若此时内存中没有空闲块，则要淘汰某页，若该页在内存期间被修改过，则要将其写回外存。</p>
<h3 id="9.1">页面置换算法</h3>

<ul>
<li><p>最佳置换算法</p>
<ul>
<li>选择的被淘汰页面，将是以后永不使用的，或者是在最长(未来)时间内不再被访问的页面。采用最佳置换算法，通常可保证获得最低的缺页率</li>
<li>无法实现，只能用来评价其他算法</li>
</ul>
</li>
<li><p>先进先出(FIFO)页面置换算法</p>
<ul>
<li>置换时选择在内存中驻留时间最长的页淘汰</li>
<li>只考虑页面调入内存的时间，而没有考虑页面的使用情况，性能差</li>
</ul>
</li>
<li><p>最近最久未使用(LRU)置换算法 </p>
<ul>
<li>淘汰没有使用的时间最长的页</li>
<li>实现代价高</li>
</ul>
</li>
<li><p>Clock置换算法 </p>
<ul>
<li>由访问位A和修改位M可以组合成下面四种类型的页面：<br>1类(A=0, M=0): 表示该页最近既未被访问， 又未被修改， 是最佳淘汰页。<br>2类(A=0, M=1)： 表示该页最近未被访问， 但已被修改， 并不是很好的淘汰页。<br>3类(A=1, M=0)： 最近已被访问， 但未被修改， 该页有可能再被访问。<br>4类(A=1, M=1): 最近已被访问且被修改， 该页可能再被访问。</li>
</ul>
</li>
</ul>
<h3 id="9.2">性能问题</h3>

<p>在虚存中，页面在内存与外存之间频繁调度，以至于调度页面所需时间比进程实际运行的时间还多，此时系统效率急剧下降，甚至导致系统崩溃。这种现象称为颠簸或抖动<br>原因：<br>页面淘汰算法不合理<br>分配给进程的物理页面数太少</p>
<p>工作集模型：进程在一段时间内总是集中访问一些页面，这些页面称为活跃页面，如果分配给一个进程的物理页面数太少了，使该进程所需的活跃页面不能全部装入内存，则进程在运行过程中将频繁发生中断；如果能为进程提供与活跃页面数相等的物理页面数，则可减少缺页中断次数；对于给定的访问序列选取定长的区间，称为工作集窗口，落在工作集窗口中的页面集合称为工作集。</p>
<h2 id="10">请求分段存储管理</h2>

<p>在分段系统的基础上建立的虚拟存储器,以段为单位进行换入、换出。<br>段表：段名；段长；段地址；存取方式；访问位A；修改位M；存在位P；增补位；外存实址<br>增加硬件和相应软件：</p>
<ul>
<li>段表机制</li>
<li>缺段中断机构</li>
<li>地址变换机构</li>
</ul>
<h3 id="10.1">分段共享与保护</h3>

<p>每个进程都有一个段表，记录所使用的段的信息，要实现分段共享，应设置相应的数据结构：共享段表。<br>共享段表包括：<br>共享此分段的每个进程的情况<br>该段共享进程数－count<br>每个进程名、进程号以及该共享段在该进程中的段号（对于同一个共享段，不同进程可以使用不同的段号来共享该段）、允许的存取方式等。<br>每个允许被共享的段，当其调入主存时，均在此表上登记。当一共享作业退出系统后，则应将共享本段作业数减１并取消其在共享表中的相应的记录。若共享作业数为０，则请求系统回收相应的存储空间。</p>
<table>
<thead>
<tr>
<th>分页系统</th>
<th>分段系统</th>
</tr>
</thead>
<tbody>
<tr>
<td>单一地址空间</td>
<td>二位地址空间</td>
</tr>
<tr>
<td>页是物理单位</td>
<td>段是逻辑单位</td>
</tr>
<tr>
<td>页大小固定</td>
<td>段大小可变</td>
</tr>
<tr>
<td>对用户透明</td>
<td>对用户可见</td>
</tr>
</tbody>
</table>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[XML:DOM]]></title>
      <url>http://www.codingbalian.online/2016/12/23/XML-DOM/</url>
      <content type="html"><![CDATA[<p>本篇介绍DOM来解析XML文档内容。暂时应该不会再更新XML的内容了。</p>
<blockquote>
<p>DOM基于树或基于对象，方便应用程序对数据和结构进行更改，且任何时候可以在树中上下导航。<br><a id="more"></a></p>
</blockquote>
<h2 id="1">XML解析器</h2>

<h3 id="1.1">DOM概述</h3>

<p>可以将DOM看做一组API，将HTML、XML看做文档对象，在接口中存放对这些文档的操作属性和方法定义，允许程序和脚本动态地访问、更新文档内容、结构、脚本程序。<br>利用DOM处理XML时，先是将XML文档加载到内存中去，以树结构存在，应用程序再对其节点对象进行修改。</p>
<h3 id="1.2">DOM结构</h3>

<p>DOM是XML文档的结构化视图，将XML看做一棵节点树，每一个节点都代表一个可以与其进行交互的对象，因此可以将DOM看做一个节点的集合。</p>
<ul>
<li>整个文档是一个文档节点</li>
<li>每个XML标记是一个元素节点</li>
<li>包含在XML元素中的文本都是文本节点</li>
<li>每一个XML属性是一个属性节点</li>
<li>注释属于注释节点</li>
</ul>
<p>一个节点树中的所有节点彼此都是有关系的，一个节点树可以将一个XML文档战术为一个节点集以及他们之间的链接。在一棵节点树中，最顶端节点作为根，除根外每一个节点都有父节点，一个节点可以有无限的子节点，但叶节点无子节点，拥有相同父节点的节点称为同级节点。</p>
<h3 id="1.3">DOM对象</h3>

<p>DOM作为API接口存放着不同的未实例化的对象，对应着XML文档中不同类型的节点和数据。</p>
<ul>
<li>基本接口<ol>
<li>Document接口：文档树的根，提供对文档数据的最初（或最顶层）的访问入口。由于元素节点、文本节点、注释、处理指令等均无法存在于文档之外，Document 对象也提供了创建这些对象的方法。通过其创造ID节点对象都有ownerDocument属性。Document节点可以有多个注释、处理指令节点，但是文档类型节点和根节点都是唯一的。</li>
<li>Node接口：Node 是整个文档对象的主要数据类型，表示文档树中的单个节点。DOM中很大一部分的接口是从Node接口中继承过来的，提供了访问DOM树中元素内容的途径，给出了遍历的支持。</li>
<li>NodeList接口：节点列表中的节点可以通过其对应的索引数字（从 0 开始计数）进行访问。节点列表可保持其自身的更新。如果节点列表或 XML 文档中的某个元素被删除或添加，列表也会被自动更新。</li>
<li>NamedNodeMap接口：包含可以通过名字访问一组节点的集合，且是无序的不能通过索引来访问，主要用于属性节点的表示，与NodeList一样其对象也是自动更新的。</li>
<li>Element接口：继承于NodeList接口，表示文档中的一个元素标记，可包含属性、其他元素或文本。如果元素含有文本，则在文本节点中表示该文本。可以使用attribute来获得元素的所有属性集合。</li>
<li>Text接口：Text 节点继承了CharacterData接口，通过从CharacterData接口继承的data属性或从Node接口继承的 nadevalue 属性，可以访问Text节点的文本内容。<br>更多对象接口参考<a herf="http://www.w3school.com.cn/xmldom/xmldom_reference.asp">XML DOM 参考手册</a></li>
</ol>
</li>
</ul>
<ul>
<li>DOM对象<ol>
<li>XML文档对象：代表整个XML文档，由Document对象实现，由根源素和子元素组成。对XML进行操作就要先获取XML文档对象。</li>
<li>XML节点对象：代表XML文档中单个节点,由Node接口实现。</li>
<li>XML节点列表对象：XML文档模块列表代表节点的集合由NodeList接口实现。</li>
<li>对XML文档操作就是创建不同的对象来进行操作。</li>
</ol>
</li>
</ul>
<h2 id="2">DOM的使用</h2>

<p>对XML文档进行操作需要先创建一个DOM对象并以此为句柄把XML文档对象加载到内存中的节点树进行操作。</p>
<h3 id="2.1">JAXP简介、类和方法</h3>

<p>JAXP(Java API for XMLParsing)是解析XML文件的API。包括此法分析器、标注NSAX，可以选择事件流或者建立对象来解析数据，且提供XSLT标准支持、名称空间支持、在没有命名冲突的情况下使用DTD。</p>
<h3 id="2.2">JAXP的类和方法</h3>

<ol>
<li>解析器工厂类(DocumentBuliderFactory)：要使用DOM对XML文档进行操作先要建立一个解析器工厂实例，通过它来获得一个具体的解析器对象。<br><code>DocumentBuliderFactory dbf=DocumentBuliderFactory.newInstance();</code></li>
<li>解析器类(DocumentBulider)：开发者可以使用它从XML文档获取DOM实例。<br><code>DocumentBulider db=dbf.newDocumentBulider();</code></li>
<li>文档树模型(Document)：代表一个XML文档树模型，其中的所有节点都以一定顺序包含在Document对象内，之后的所有操作都与解析器无关，直接对Document对象操作即可。<br>使用DocumentBuilder的parse()方法接受一个XML文档名作为输入参数，返回一个Document实例：<code>Document doc=db.parse(&quot;example.xml&quot;);</code><br>把XML文档转化为输入流，作为parse()方法的参数，一遍DOM解析器解析：<br><code>InputStream is=new FileInputStream(&quot;example.xml&quot;);Document DOC=DB.PARSE(is);</code><br>从得到Document对象开始就可以使用DOM操作XML文档。使用Document对象的getElementsByTagsName()方法可以得到一个NodeList对象：<code>NodeList nl=doc.getElementByTagsName(&quot;example&quot;)</code> <ul>
<li>createAttribute(String)：用给定的属性名创建一个Attr对象，并可在其后使用setAttributeNode方法来放置在某一个Element对象上面。 </li>
<li>createElement(String)：用给定的标签名创建一个Element对象，代表XML文档中的一个标签，然后就可以在这个Element对象上添加属性或进行其它的操作。 </li>
<li>createTextNode(String)：用给定的字符串创建一个Text对象，Text对象代表了标签或者属性中所包含的纯文本字符串。如果在一个标签内没有其它的标签，那么标签内的文本所代表的Text对象是这个Element对象的唯一子对象。 </li>
<li>getElementsByTagName(String)：返回一个NodeList对象，它包含了所有给定标签名字的标签。 </li>
<li>getDocumentElement()：返回一个代表这个DOM树的根节点的Element对象，也就是代表XML文档根元素的那个对象。 </li>
</ul>
</li>
<li>节点类(Node):Node是最基本的对象，代表文档树中一个抽象的节点，实际操作中很少用到，而是使用其子对象来进行操作。<ul>
<li>appendChild(org.w3c.dom.Node)：为这个节点添加一个子节点，并放在所有子节点的最后，如果这个子节点已经存在，则先把它删掉再添加进去。 </li>
<li>getFirstChild()：如果节点存在子节点，则返回第一个子节点，对等的，还有getLastChild()方法返回最后一个子节点。 </li>
<li>getNextSibling()：返回在DOM树中这个节点的下一个兄弟节点，对等的，还有getPreviousSibling()方法返回其前一个兄弟节点。 </li>
<li>getNodeName()：根据节点的类型返回节点的名称。 </li>
<li>getNodeType()：返回节点的类型。 </li>
<li>getNodeValue()：返回节点的值。 </li>
<li>hasChildNodes()：判断是不是存在有子节点。 </li>
<li>hasAttributes()：判断这个节点是否存在有属性。 </li>
<li>getOwnerDocument()：返回节点所处的Document对象。 </li>
<li>insertBefore(org.w3c.dom.Node new，org.w3c.dom.Node ref)：在给定的一个子对象前再插入一个子对象。 </li>
<li>removeChild(org.w3c.dom.Node)：删除给定的子节点对象。 </li>
<li>replaceChild(org.w3c.dom.Node new，org.w3c.dom.Node old)：用一个新的Node对象代替给定的子节点对象。 </li>
</ul>
</li>
<li>节点列表类(NodeList)：代表一个包含Node的列表，可以简单的看成Node数组。<ul>
<li>GetLength():返回列表长度</li>
<li>Item(int):返回指定位置的Node对象。</li>
</ul>
</li>
<li><p>元素类(Element)：代表XML文档中的标记元素，继承于Node，有存取标记属性的方法，任何Node定义的方法可以用到Element对象上。</p>
<ul>
<li>getElementsByTagName(String)：返回一个NodeList对象，它包含了在这个标签中其下的子孙节点中具有给定标签名字的标签。 </li>
<li>getTagName()：返回一个代表这个标签名字的字符串。 </li>
<li>getAttribute(String)：返回标签中给定属性名称的属性的值。在这儿需要主要的是，应为XML文档中允许有实体属性出现，而这个方法对这些实体属性并不适用。这时候需要用到getAttributeNodes()方法来得到一个Attr对象来进行进一步的操作。</li>
<li>getAttributeNode(String)：返回一个代表给定属性名称的Attr对象。 </li>
</ul>
</li>
<li><p>属性类(Attr)：代表每个标记中的属性。不能做为DOM树中单独的一个节点出现。</p>
</li>
</ol>
<p>更多类与方法参考：<a herf="https://jaxp.java.net/">Project JAXP</a></p>
<p>实例参考：<a herf="http://baliancheng.github.io/2016/12/24/XML-DOM-Test/">JAXP操作XML实例</a></p>
<h3 id="2.3">附：JAXP套件</h3>

<table>
<thead>
<tr>
<th>JAXP提供的套件</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Java.xml.parsers</td>
<td>提供处理XML文件的类</td>
</tr>
<tr>
<td>Java.xml.transform</td>
<td>提供处理XSLT文件的类</td>
</tr>
<tr>
<td>org.xml.sax</td>
<td>SAX解析器，提供以事件驱动方式解析XML的API</td>
</tr>
<tr>
<td>org.xml.saxhelpers</td>
<td>提供解析错误处理的相关类，可以帮助程序设计中使用SAX API</td>
</tr>
<tr>
<td>org.w3c.dom</td>
<td>提供支持DOM建议规格的套件</td>
</tr>
</tbody>
</table>
<h2 id="3">JAXP操作XML</h2>

<h3 id="3.1">遍历XML文档</h3>

<p>book.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;GB2312&quot;?&gt;</div><div class="line">&lt;图书列表&gt;</div><div class="line">	&lt;图书&gt;</div><div class="line">		&lt;书名&gt;三国演义&lt;/书名&gt;</div><div class="line">		&lt;作者&gt;罗贯中&lt;/作者&gt;</div><div class="line">		&lt;价格&gt;38.00元&lt;/价格&gt;</div><div class="line">		&lt;出版社&gt;人民文学出版社&lt;/出版社&gt;</div><div class="line">	&lt;/图书&gt;</div><div class="line">	&lt;图书&gt;</div><div class="line">		&lt;书名&gt;西游记&lt;/书名&gt;</div><div class="line">		&lt;作者&gt;吴承恩&lt;/作者&gt;</div><div class="line">		&lt;价格&gt;48.00元&lt;/价格&gt;</div><div class="line">		&lt;出版社&gt;人民文学出版社&lt;/出版社&gt;</div><div class="line">	&lt;/图书&gt;</div><div class="line">&lt;/图书列表&gt;</div></pre></td></tr></table></figure></p>
<p>bookxml.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">import javax.xml.parsers.*;</div><div class="line">import org.w3c.dom.*;</div><div class="line">public class bookxml&#123;</div><div class="line">	public static void main(String[] args)&#123;</div><div class="line">		try&#123;</div><div class="line">			DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance(); //获得工厂实例</div><div class="line">			DocumentBuilder builder = factory.newDocumentBuilder();  //获得DOM解析器</div><div class="line">			Document doc = builder.parse(&quot;book.xml&quot;); //将需要解析的XML文档读入DOM</div><div class="line">			System.out.println(doc.getImplementation());</div><div class="line">            NodeList nl = doc.getElementsByTagName(&quot;图书&quot;);  //获得“图书”元素的节点列表</div><div class="line">            for (int i = 0; i &lt; nl.getLength(); i++) &#123;  //遍历</div><div class="line">				Element node=(Element)nl.item(i);</div><div class="line">				System.out.print(&quot;书名&quot;);</div><div class="line">				System.out.println(node.getElementsByTagName(&quot;书名&quot;).item(0).getFirstChild().getNodeValue());</div><div class="line">				System.out.print(&quot;作者&quot;);</div><div class="line">				System.out.println(node.getElementsByTagName(&quot;作者&quot;).item(0).getFirstChild().getNodeValue());</div><div class="line">				System.out.print(&quot;价格&quot;);</div><div class="line">				System.out.println(node.getElementsByTagName(&quot;价格&quot;).item(0).getFirstChild().getNodeValue());</div><div class="line">				System.out.print(&quot;出版社&quot;);</div><div class="line">				System.out.println(node.getElementsByTagName(&quot;出版社&quot;).item(0).getFirstChild().getNodeValue());</div><div class="line">            &#125;</div><div class="line">		&#125;</div><div class="line">		catch(Exception e)&#123;</div><div class="line">				e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="3.2">访问属性节点</h3>

<p>book.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;GB2312&quot;?&gt;</div><div class="line">&lt;图书列表&gt;</div><div class="line">	&lt;图书 作者=&quot;罗贯中&quot; 价格=&quot;38.00元&quot; 出版社=&quot;人民文学出版社&quot;&gt;</div><div class="line">		三国演义</div><div class="line">	&lt;/图书&gt;</div><div class="line">	&lt;图书 作者=&quot;吴承恩&quot; 价格=&quot;48.00元&quot; 出版社=&quot;人民文学出版社&quot;&gt;</div><div class="line">		西游记</div><div class="line">	&lt;/图书&gt;</div><div class="line">&lt;/图书列表&gt;</div></pre></td></tr></table></figure></p>
<p>bookxml.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">import javax.xml.parsers.*;</div><div class="line">import org.w3c.dom.*;</div><div class="line">public class bookxml&#123;</div><div class="line">	public static void main(String[] args)&#123;</div><div class="line">		try&#123;</div><div class="line">			DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance(); </div><div class="line">			DocumentBuilder builder = factory.newDocumentBuilder(); </div><div class="line">			Document doc = builder.parse(&quot;book.xml&quot;); </div><div class="line">			Element root=doc.getDocumentElement();</div><div class="line">			String rootName=root.getNodeName();</div><div class="line">			System.out.println(&quot;XML文件根节点命名为：&quot;+rootName);</div><div class="line">			NodeList nl = root.getElementsByTagName(&quot;图书&quot;); //获取图书节点对象集合</div><div class="line">			for (int i = 0; i &lt; nl.getLength(); i++) &#123;</div><div class="line">				Node node=nl.item(i);</div><div class="line">				String name=node.getNodeName(); //获取节点名</div><div class="line">				NamedNodeMap map=node.getAttributes(); //获取每个节点的属性集合</div><div class="line">				String content =node.getTextContent(); //获取节点中包含的数据</div><div class="line">				System.out.print(name);</div><div class="line">				for(int k = 0;k&lt;map.getLength();k++)&#123; //获取节点长度，输出属性集合的名称和值</div><div class="line">					Attr attrNode=(Attr)map.item(k);</div><div class="line">					String attName=attrNode.getName(); //获得属性名称</div><div class="line">					String attValue=attrNode.getValue(); //获得属性值</div><div class="line">					System.out.print(&quot; &quot;+attName+&quot;=&quot;+attValue);</div><div class="line">				&#125;</div><div class="line">				System.out.print(content);</div><div class="line">            &#125;</div><div class="line">		&#125;</div><div class="line">		catch(Exception e)&#123;</div><div class="line">				e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="3.3">动态创建XML文档</h3>


<p>解析器建立与XML文档相应的树状结构数据，也可以根据数据建立一个XML文档，即将整个被解析的XML文档封装成一个Document节点返回，使用Transformer将其转化为一个XML文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">import javax.xml.parsers.*;</div><div class="line">import javax.xml.transform.*;</div><div class="line">import javax.xml.transform.stream.*;</div><div class="line">import javax.xml.transform.dom.*;</div><div class="line">import org.w3c.dom.*;</div><div class="line">import java.io.*;</div><div class="line">public class peoplexml &#123;</div><div class="line">	public static void main(String[] args)&#123;</div><div class="line">		Document doc;</div><div class="line">		Element people,person;</div><div class="line">		Element name=null;</div><div class="line">		Element address=null;</div><div class="line">		Element tel=null;</div><div class="line">		Element fax=null;</div><div class="line">		Element email=null;</div><div class="line">		try&#123;</div><div class="line">			DocumentBuilderFactory dbf=DocumentBuilderFactory.newInstance();//创建工厂实例</div><div class="line">			DocumentBuilder builder=dbf.newDocumentBuilder();//获得DOM解析器</div><div class="line">			doc=builder.newDocument();//创建文档树模型对象</div><div class="line">			if(doc!=null)&#123; //判断是否为空</div><div class="line">				people=doc.createElement(&quot;联系人列表&quot;);//创建根源素</div><div class="line">				person=doc.createElement(&quot;联系人&quot;);//创建联系人元素</div><div class="line">				people.appendChild(person);//将联系人元素作为根源素的子元素</div><div class="line">				name=doc.createElement(&quot;姓名&quot;);</div><div class="line">				name.appendChild(doc.createTextNode(&quot;Cheng&quot;));</div><div class="line">				person.appendChild(name);</div><div class="line">				address=doc.createElement(&quot;地址&quot;);</div><div class="line">				address.appendChild(doc.createTextNode(&quot;华中师范大学&quot;));</div><div class="line">				person.appendChild(address);</div><div class="line">				tel=doc.createElement(&quot;电话&quot;);</div><div class="line">				tel.appendChild(doc.createTextNode(&quot;133XXXXX&quot;));</div><div class="line">				person.appendChild(tel);</div><div class="line">				fax=doc.createElement(&quot;传真&quot;);</div><div class="line">				fax.appendChild(doc.createTextNode(&quot;080-XXXX&quot;));</div><div class="line">				person.appendChild(fax);</div><div class="line">				email=doc.createElement(&quot;电子邮箱&quot;);</div><div class="line">				email.appendChild(doc.createTextNode(&quot;2324@qq.com&quot;));</div><div class="line">				person.appendChild(email);</div><div class="line">				doc.appendChild(people);//将联系人列表作为根源素添加到XML文档中</div><div class="line">				TransformerFactory transFactory=TransformerFactory.newInstance();//创建转换工厂对象</div><div class="line">				Transformer transformer =transFactory.newTransformer();//创建文件转换对象</div><div class="line">				DOMSource domScource =new DOMSource(doc);//把要转换的Document对象封装到DOMSource类中</div><div class="line">				File file =new File(&quot;people.xml&quot;);</div><div class="line">				FileOutputStream out= new FileOutputStream(file);</div><div class="line">				StreamResult xmlResult =new StreamResult(out);//将要转换的XML文件保存在StreamResult中</div><div class="line">				transformer.transform(domScource, xmlResult);//把节点树转化成XML文件</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		catch(Exception e)&#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在同一目录下生产peoplexml.xml文件</p>
<h3 id="3.4">文本节点操作：修改</h3>

<p>book.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt;</div><div class="line">&lt;图书列表&gt;</div><div class="line">	&lt;图书&gt;三国演义&lt;/图书&gt;</div><div class="line">	&lt;图书&gt;&lt;/图书&gt;</div><div class="line">&lt;/图书列表&gt;</div></pre></td></tr></table></figure></p>
<p>bookxml.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">import javax.xml.parsers.*;</div><div class="line">import javax.xml.transform.*;</div><div class="line">import javax.xml.transform.stream.*;</div><div class="line">import javax.xml.transform.dom.*;</div><div class="line">import org.w3c.dom.*;</div><div class="line">import java.io.*;</div><div class="line"></div><div class="line">public class bookxml &#123;</div><div class="line">    public static void main(String[] args)&#123;</div><div class="line">		try&#123;</div><div class="line">			DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();</div><div class="line">			DocumentBuilder builder = factory.newDocumentBuilder();  </div><div class="line">			Document doc = builder.parse(new File(&quot;book.xml&quot;));</div><div class="line">			Element root=doc.getDocumentElement();</div><div class="line">			NodeList nl = root.getElementsByTagName(&quot;图书&quot;);//取得图书命名节点的集合</div><div class="line">			for (int i = 0; i &lt; nl.getLength(); i++) &#123;//取得长度</div><div class="line">				Node node=nl.item(i);</div><div class="line">				if(node.getNodeType()==Node.ELEMENT_NODE)&#123;//判断节点类型</div><div class="line">					Element enode=(Element)node;//强制转换类型</div><div class="line">					String str=enode.getTextContent();//获取节点值</div><div class="line">					if(str.equals(&quot;&quot;))&#123;</div><div class="line">						enode.setTextContent(&quot;水浒传&quot;);//设置节点值</div><div class="line">					&#125;</div><div class="line">					if(str.equals(&quot;三国演义&quot;))&#123;</div><div class="line">						enode.setTextContent(&quot;西游记&quot;);</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			TransformerFactory transFactory=TransformerFactory.newInstance();//创建转换工厂对象</div><div class="line">			Transformer transformer =transFactory.newTransformer();//创建文件转换对象</div><div class="line">			DOMSource domScource =new DOMSource(doc);//把要转换的Document对象封装到DOMSource类中</div><div class="line">			File file =new File(&quot;book.xml&quot;);</div><div class="line">			FileOutputStream out= new FileOutputStream(file);</div><div class="line">			StreamResult xmlResult =new StreamResult(out);//将要转换的XML文件保存在StreamResult中</div><div class="line">			transformer.transform(domScource, xmlResult);//把节点树转化成XML文件</div><div class="line">		&#125;</div><div class="line">		catch(Exception e)&#123;</div><div class="line">			e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="3.4">文本节点操作：删除</h3>

<p>book.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</div><div class="line">&lt;图书列表&gt;</div><div class="line">	&lt;图书&gt;西游记&lt;/图书&gt;</div><div class="line">	&lt;图书&gt;三国演义&lt;/图书&gt;</div><div class="line">	&lt;图书 作者=&quot;曹雪芹&quot;&gt;红楼梦&lt;/图书&gt;</div><div class="line">	&lt;图书&gt;水浒传&lt;/图书&gt;</div><div class="line">&lt;/图书列表&gt;</div></pre></td></tr></table></figure></p>
<p>bookxml.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">import javax.xml.parsers.*;</div><div class="line">import javax.xml.transform.*;</div><div class="line">import javax.xml.transform.stream.*;</div><div class="line">import javax.xml.transform.dom.*;</div><div class="line">import org.w3c.dom.*;</div><div class="line"></div><div class="line">import java.io.*;</div><div class="line"></div><div class="line">public class bookxml &#123;</div><div class="line">    public static void main(String[] args)&#123;</div><div class="line">		try&#123;</div><div class="line">			DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();</div><div class="line">			DocumentBuilder builder = factory.newDocumentBuilder();  </div><div class="line">			Document doc = builder.parse(new File(&quot;book.xml&quot;));</div><div class="line">			Element root=doc.getDocumentElement();</div><div class="line">			NodeList nl = root.getElementsByTagName(&quot;图书&quot;);//取得图书命名节点的集合</div><div class="line">			for (int i = 0; i &lt; nl.getLength(); i++) &#123;//取得长度</div><div class="line">				Node node=nl.item(i);</div><div class="line">				if(node.getNodeType()==Node.ELEMENT_NODE)&#123;//判断节点类型</div><div class="line">					Element enode=(Element)node;//强制转换类型</div><div class="line">					if(i==2)&#123;</div><div class="line">						enode.removeAttribute(&quot;作者&quot;);//移除属性</div><div class="line">					&#125;</div><div class="line">					System.out.println(i);</div><div class="line">					System.out.println(enode.getTextContent());</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			Node node=nl.item(1);//获得该处索引处的node节点</div><div class="line">			root.removeChild(node);//移除节点</div><div class="line">			TransformerFactory transFactory=TransformerFactory.newInstance();//创建转换工厂对象</div><div class="line">			Transformer transformer =transFactory.newTransformer();//创建文件转换对象</div><div class="line">			DOMSource domScource =new DOMSource(doc);//把要转换的Document对象封装到DOMSource类中</div><div class="line">			File file =new File(&quot;book.xml&quot;);</div><div class="line">			FileOutputStream out= new FileOutputStream(file);</div><div class="line">			StreamResult xmlResult =new StreamResult(out);//将要转换的XML文件保存在StreamResult中</div><div class="line">			transformer.transform(domScource, xmlResult);//把节点树转化成XML文件</div><div class="line">		&#125;</div><div class="line">		catch(Exception e)&#123;</div><div class="line">			e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[XML:XSL转换]]></title>
      <url>http://www.codingbalian.online/2016/12/22/XML-XSL/</url>
      <content type="html"><![CDATA[<p>XSL是基于XML的语言，用于显示XML的规范。<br><a id="more"></a></p>
<h2 id="1">XSL转换原理</h2><br>XSL样式表对XML文档转化的过程：<br>1. 根据XML文档构造源树，根据XSL规则将源树转化成结果树，转换协议为XSLT。<br>2. 生成结果树后进行解释，产生一种社和显示的格式（格式化）。<br><br>XSL处理器负责转换成。XML文档先被解析成DOM树存放在内存中，接着进行分析，每一个DOM树的节点都与一个模式相比较，匹配上按模板进行转换否则继续往下匹配。<br><h2 id="2">XSL文档结构</h2><br>XSL是扩展名为xsl的文本文件使用XML，其基本结构：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;GB2312&quot;?&gt;</div><div class="line">&lt;xsl:stylesheet version=&quot;1.0&quot; xmlns:xsl=&quot;http://www.w3.org/1999/XSL/Transform&quot;&gt;</div><div class="line">&lt;xsl:template match=&quot;/&quot;&gt;</div><div class="line">	.....</div><div class="line">&lt;/xsl:template&gt;</div><div class="line">&lt;xsl:template match=&quot;指定的XML元素&quot;&gt;</div><div class="line">	.....</div><div class="line">&lt;/xsl:template&gt;</div><div class="line">	.....</div><div class="line">&lt;/xsl:stylesheet&gt;</div></pre></td></tr></table></figure><br><br>把XSL样式表链接到XML文档:<code>&lt;?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;文件名.xsl&quot;?&gt;</code><br><br><h2 id="3">XSL模板</h2><br>XSL模板由两部分组成：匹配模式和执行，匹配模式指定文档中节点处理，执行定义输出。<br><em> 定义模板：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;xsl:template match=&quot;pattern&quot; name=&quot;name&quot; priority=&quot;number&quot; mode=&quot;mode&quot;&gt;</div><div class="line">	&lt;!--具体执行内容--&gt;</div><div class="line">&lt;/xsl:template&gt;</div></pre></td></tr></table></figure>

</em> match属性的pattern指定为<code>/</code>表示与根节点匹配，指定为为<em>表示与所有未指定规则的节点匹配。<br><code>match=&quot;(title|author)&quot;</code>表示匹配所有title和author元素，<code>match=&quot;(title/author)</code>表示匹配所有父节点为title的author元素

</em> xsl:apply-template：处理当前节点的所有子节点，总是包含在xsl:template元素中。<br><code>&lt;xsl:apply-template select=&quot;expression&quot; mode=&quot;nam&quot;/&gt;</code><br><em> select属性是一个Xpath表达式，规定要用模板来处理节点。值为’</em>‘时去整个节点集，省略则是整个节点的子节点与模板比较选择匹配的处理。<br><em> mode选择同元素定义的多种处理方法。<br><br><h2 id="4">常用属性</h2><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">#xsl:element 用于在输出文档创建节点</div><div class="line">&lt;xsl:element name=&quot;name&quot; namespace=&quot;URI&quot; use-attribute-sets=&quot;namelist&quot;&gt;</div><div class="line">	&lt;!--template--&gt;</div><div class="line">&lt;/xsl:element&gt;</div><div class="line">#xsl:attribute</div><div class="line">&lt;xsl:attribute name=&quot;attributename&quot; namespace=&quot;URI&quot;&gt;</div><div class="line">	&lt;!--template--&gt;</div><div class="line">&lt;/xsl:attribute&gt;</div><div class="line">#xsl:text</div><div class="line">&lt;xsl:text disable-output-escaping=&quot;yes|no&quot;&gt;</div><div class="line">	&lt;!--content--&gt;</div><div class="line">&lt;/xsl:text&gt;</div></pre></td></tr></table></figure>

 </em> name规定创建元素的名称<br> <em> namespace规定名称空间的URI
 </em> use-attribute-sets空格分隔属性集，包含需要添加的属性<br> <em> <code>xsl:text</code>用于输出文本节点包括文本、#PCDATA等
 </em> disable-output-escaping默认为no，输出时将对文本进行转义。如<code>&lt;</code>输出为<code>&amp;lt</code><br><br><h2 id="5">XSL节点选择</h2><br>XSL样式表中有一个根模板，从根模板开始匹配XML文档，处理时调用其他模板，要匹配模板和标记时要设计“标记匹配模式”。<br>使用元素名匹配<br>XSL处理器根据match提供的元素名称去XML文档提取该节点的数据，需要用到<code>xsl:value-of</code>元素，用于选取文档中某个元素的值并输出。<br><code>&lt;xsl:value-of select=&quot;expression&quot; disable-output-escaping=&quot;yes|no&quot;&gt;</code><br> <em> select属性值是XPath表达式，规定从哪个节点或属性来提取<br>使用路径匹配<br>通过详细的路径选择节点，即模板中的标记匹配模式可以由子标记、根标记、/、//共同组成。<br><code>&lt;xsl:template match=&quot;图书/书名&quot;&gt;</code>表示匹配图书下的任意书名子节点。<br><code>&lt;xsl:template match=&quot;//书名&quot;&gt;</code>表示匹配任意节点下的书名子节点。<br><br>使用匹配字符匹配
 </em> 根节点匹配符<code>&lt;xsl:template match=&quot;/&quot;&gt;</code><br> <em> 根源素匹配符`&lt;xsl:template match=”/</em>“&gt;<code>* 当前节点</code><xsl:template match="."><code>父节点</code><xsl:template match=".."><code>4. 使用元素属性匹配
使用</code>标记[@属性]<code>或</code>标记[@属性=’属性值’]`进行筛选匹配。<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">#xml文档</div><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;GB2312&quot;?&gt;</div><div class="line">&lt;名单&gt;</div><div class="line">	&lt;姓名&gt;张三&lt;/姓名&gt;</div><div class="line">	&lt;姓名 ID=&quot;1&quot;&gt;李四&lt;/姓名&gt;</div><div class="line">&lt;/名单&gt;</div><div class="line">#获得李四数据</div><div class="line">&lt;xsl:template match=&quot;名单/姓名[@ID=&apos;1&apos;]&quot;&gt;</div><div class="line">	&lt;!--模板内容--&gt;</div><div class="line">&lt;/xsl:template&gt;</div></pre></td></tr></table></figure><br><br><h2 id="6">XSL控制指令</h2>

<ol>
<li>简单判断指令<code>&lt;xsl:if&gt;</code><ul>
<li>以元素名为条件<code>&lt;xsl:if match=&quot;元素名&quot;&gt;</code></li>
<li>以元素内容为条件<code>&lt;xsl:if test=&quot;元素名[.=元素内容]&quot;&gt;</code></li>
<li>以元素属性为条件<code>&lt;xsl:if match=&quot;.[@属性名称=&#39;属性值&#39;]&quot;&gt;</code></li>
<li>以元素属性为条件<code>&lt;xsl:if test=&quot;.[@属性名称=&#39;属性值&#39;]&quot;&gt;</code></li>
</ul>
</li>
<li><p>多条件判断指令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;xsl:choose&gt;</div><div class="line">	&lt;xsl:when test=&quot;pattern&quot;&gt;</div><div class="line">		&lt;!--样式定义语句--&gt;</div><div class="line">	&lt;/xsl:when&gt;</div><div class="line">	&lt;xsl:when test=&quot;pattern&quot;&gt;</div><div class="line">		&lt;!--样式定义语句--&gt;</div><div class="line">	&lt;/xsl:when&gt;</div><div class="line">	......</div><div class="line">	&lt;xsl:otherwise&gt;</div><div class="line">		&lt;!--样式定义语句--&gt;</div><div class="line">	&lt;/xsl:otherwise&gt;</div><div class="line">&lt;/xsl:choose&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>循环处理指令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;xsl:for-each select=&quot;pattern&quot; order-by=&quot;patternlist&quot;&gt;</div><div class="line">	&lt;xsl:value-of../&gt;</div><div class="line">&lt;/xsl:for-each&gt;</div></pre></td></tr></table></figure>
<ul>
<li>用于对多个节点继续相同的处理</li>
<li>select选择需要循环输出的节点元素</li>
<li>order-by默认与+使用升序，-使用降序</li>
<li><xsl:value-of>具体输出指定子节点内容</xsl:value-of></li>
</ul>
</li>
<li>输出内容排序<br><code>&lt;xsl:sort select=&quot;元素名&quot; order=&quot;ascending|descending&quot; case-order=&quot;upper-first|lower-first&quot; data-type=&quot;text|number|qname&quot; /&gt;</code><ul>
<li>xsl:sort作为xsl:apply-template或者xsl:for-each的子元素出现</li>
<li>data-type标书排序数据类型</li>
<li>select定义关键字</li>
<li>order设置升降序</li>
<li>case-order设置大小写字母排序</li>
</ul>
</li>
</ol>
<p></p><h2 id="7">XPath</h2><br>XPath用于XML文字导航，将节点划分成8种节点类型<p></p>
<ol>
<li>根节点：唯一，最上层。根源素是根节点的第一层子节点，一般包括两个子节点：xsl-stylesheet处理指令和根源素。</li>
<li>元素节点：对应文档中的每一元素，可以定义唯一的标识ID，可以有扩展：命名空间URI、本地命名。</li>
<li>文本节点：包含一组数据即CDATA包含的字符，没有紧邻的兄弟文本节点，没有扩展名。</li>
<li>属性节点：元素节点有一个关联的属性节点的集合，元素是属性节点的父节点，但属性节点却不是其父元素的子节点。通过查找元素的子节点可以单向匹配出元素的属性节点，且不同的元素节点不共有同一个属性节点。 </li>
<li>命名空间节点：每一个元素节点都有一个相关的命名空间节点集。在XML文档中，命名空间是通过保留属性声明的，它们与父元素之间的关系是单向的，并且不具有共享性。 </li>
<li>处理指令节点：对应于XML文档中的每一条处理指令。它也有扩展名，扩展名的本地命名指向处理对象，而命名空间部分为空。</li>
<li>注释节点：对应文档中的注释。 </li>
<li>上下文节点：是将要查询的XML文档树种的一个特定节点，可以认为是查询的起点。</li>
</ol>
<p></p><h2 id="8">XPath路径表达式</h2><br>位置路径可以是绝对的，也可以是相对的。绝对路径起始于正斜杠( / )。都包含位置步。<br>绝对位置路径:<code>/step/step/...</code><br>相对位置路径:<code>step/step/...</code><br>步的语法：<code>轴名称::节点测试[谓语]</code><br>步包括：<p></p>
<ul>
<li>轴:定义所选节点与当前节点之间的树关系</li>
<li>节点测试:识别某个轴内部的节点</li>
<li>谓词:更深入地提炼所选的节点集</li>
</ul>
<table>
<thead>
<tr>
<th>轴</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>ancestor</td>
<td>选取当前节点的所有先辈</td>
</tr>
<tr>
<td>ancestor-or-self</td>
<td>选取当前节点的所有先辈以及当前节点本身</td>
</tr>
<tr>
<td>attribute</td>
<td>选取当前节点的所有属性</td>
</tr>
<tr>
<td>child</td>
<td>选取当前节点的所有子元素</td>
</tr>
<tr>
<td>descendant</td>
<td>选取当前节点的所有后代元素</td>
</tr>
<tr>
<td>descendant-or-self</td>
<td>选取当前节点的所有后代元素以及当前节点本身</td>
</tr>
<tr>
<td>following</td>
<td>选取文档中当前节点的结束标签之后的所有节点</td>
</tr>
<tr>
<td>namespace</td>
<td>选取当前节点的所有命名空间节点</td>
</tr>
<tr>
<td>parent</td>
<td>选取当前节点的父节点</td>
</tr>
<tr>
<td>preceding</td>
<td>选取文档中当前节点的开始标签之前的所有节点</td>
</tr>
<tr>
<td>preceding-sibling</td>
<td>选取当前节点之前的所有同级节点</td>
</tr>
<tr>
<td>self</td>
<td>选取当前节点</td>
</tr>
</tbody>
</table>
<p>节点测试允许从轴中选择特定的元素或者节点类型</p>
<ul>
<li>元素名称节点测试：指定与具有名称的节点匹配</li>
<li>“*”节点测试:指定轴中的所有元素</li>
<li>node()节点测试:指定轴中的所有元素</li>
<li>comment()节点测试：指定轴中的所有注释</li>
<li>text()指定轴中的所有文本</li>
<li>processing-instruction()节点测试：指定轴中所有的处理指令元素</li>
</ul>
<p>谓词用于对节点集进行更神的过滤，用于查找特定节点</p>
<table>
<thead>
<tr>
<th>谓词</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>[position()=n]</td>
<td>选取当前节点的第n个节点</td>
</tr>
<tr>
<td>[last()]</td>
<td>选取当前节点的最后一个节点</td>
</tr>
<tr>
<td>[attribute::name]</td>
<td>选择所有拥有name属性的节点</td>
</tr>
<tr>
<td>[attribute::name1 and attribute::name2]</td>
<td>选取所有拥有名为name1、name2属性的节点</td>
</tr>
<tr>
<td>[nodename=value]</td>
<td>选取所有nodename子元素的值为value的节点</td>
</tr>
<tr>
<td>[count()]</td>
<td>返回符合条件的节点个数</td>
</tr>
</tbody>
</table>
<p>路径缩写表达式</p>
<table>
<thead>
<tr>
<th>表达式</th>
<th>描述</th>
<th>原语法</th>
</tr>
</thead>
<tbody>
<tr>
<td>nodename</td>
<td>选取此节点的所有子节点</td>
<td>child::nodename</td>
</tr>
<tr>
<td>/</td>
<td>从根节点选取</td>
<td>..</td>
</tr>
<tr>
<td>//</td>
<td>从匹配选择的当前节点选择文档中的节点，而不考虑它们的位置</td>
<td>/descendant-or-self::node()/</td>
</tr>
<tr>
<td>.</td>
<td>选取当前节点</td>
<td>self::node()</td>
</tr>
<tr>
<td>..</td>
<td>选取当前节点的父节点</td>
<td>parent::node()</td>
</tr>
<tr>
<td>@</td>
<td>选取属性</td>
<td>attribute::</td>
</tr>
</tbody>
</table>
<p>XPath标准函数:参考<a href="http://www.w3school.com.cn/xpath/xpath_functions.asp" target="_blank" rel="external">XPath、XQuery以及XSLT函数</a></p>
</xsl:template></xsl:template>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[用CSS显示XML]]></title>
      <url>http://www.codingbalian.online/2016/12/22/XML-CSS/</url>
      <content type="html"><![CDATA[<p>在XML里用到过的CSS的一点点基础内容<br><a id="more"></a></p>
<p></p><h2 id="1">CSS基础</h2><br>CSS的定义语法由三部分构成：选择器(selector)，属性(property)，属性值(value)<br>基本格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">selector&#123;</div><div class="line">	property1:value;</div><div class="line">	property2:value;</div><div class="line">	.....</div><div class="line">	propertyN:value</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p>
<p>CSS可以设置多个元素的选择器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">selector1, selector2, selector3&#123;</div><div class="line">	property1:value;</div><div class="line">	property2:value;</div><div class="line">	.....</div><div class="line">	propertyN:value</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>selector1、selector2、selector3公用同一种样式<br>类(class)选择器可以为同名的元素设置不同的样式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Tag.class&#123;</div><div class="line">	property1:value;</div><div class="line">	property2:value;</div><div class="line">	.....</div><div class="line">	propertyN:value</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">#XML</div><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;GB2312&quot;?&gt;</div><div class="line">&lt;?xml-stylesheet type=&quot;text/css&quot; href=&quot;book.css&quot;?&gt;</div><div class="line">&lt;DocumentElement&gt;</div><div class="line">	&lt;book Class=&quot;1&quot;&gt;</div><div class="line">		&lt;name&gt;数据挖掘&lt;/name&gt;</div><div class="line">		&lt;price&gt;16&lt;/price&gt;</div><div class="line">	&lt;/book&gt;</div><div class="line">	&lt;book Class=&quot;2&quot;&gt;</div><div class="line">		&lt;name&gt;机器学习&lt;/name&gt;</div><div class="line">		&lt;price&gt;18&lt;/price&gt;</div><div class="line">	&lt;/book&gt;</div><div class="line">&lt;/DocumentElement&gt;</div><div class="line">#CSS</div><div class="line">	book&#123;</div><div class="line">		display:block;</div><div class="line">		margin-top:16px</div><div class="line">		&#125;</div><div class="line">	name&#123;</div><div class="line">		display:block;</div><div class="line">		font-weight:bold</div><div class="line">		&#125;</div><div class="line">	book.1&#123;</div><div class="line">		font-size:18px</div><div class="line">		&#125;</div><div class="line">	book.2&#123;</div><div class="line">		font-style:italic;</div><div class="line">		font-size:16px</div><div class="line">		&#125;</div><div class="line">	name,price&#123;</div><div class="line">		margin:16px</div><div class="line">		&#125;</div></pre></td></tr></table></figure>
<p>标识(ID)选择器：唯一标识一个元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Tag#ID&#123;</div><div class="line">	property1:value;</div><div class="line">	property2:value;</div><div class="line">	.....</div><div class="line">	propertyN:value</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p></p><h2 id="2">CSS属性</h2><br>display常用属性<p></p>
<table>
<thead>
<tr>
<th>属性值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>none</td>
<td>不显示</td>
</tr>
<tr>
<td>block</td>
<td>块级元素，换行与别的元素分开</td>
</tr>
<tr>
<td>inline</td>
<td>默认，同一行显示</td>
</tr>
<tr>
<td>list-item</td>
<td>作为列表显示</td>
</tr>
</tbody>
</table>
<p>font常用属性</p>
<table>
<thead>
<tr>
<th>属性值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>font-family</td>
<td>字体</td>
</tr>
<tr>
<td>font-size</td>
<td>尺寸</td>
</tr>
<tr>
<td>font-style</td>
<td>字形样式</td>
</tr>
<tr>
<td>font-variant</td>
<td>大小写</td>
</tr>
<tr>
<td>font-weight</td>
<td>粗细</td>
</tr>
</tbody>
</table>
<p>CSS可以使用color指定元素字体颜色</p>
<p>CSS允许添加边框</p>
<table>
<thead>
<tr>
<th>属性值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>none</td>
<td>无边框</td>
</tr>
<tr>
<td>dotted</td>
<td>点状边框</td>
</tr>
<tr>
<td>dashed</td>
<td>虚线</td>
</tr>
<tr>
<td>solid</td>
<td>实线</td>
</tr>
<tr>
<td>double</td>
<td>双线</td>
</tr>
<tr>
<td>groove</td>
<td>3D 凹槽边框</td>
</tr>
<tr>
<td>ridge</td>
<td>3D 垄状边框</td>
</tr>
<tr>
<td>inset</td>
<td>3D inset 边框</td>
</tr>
<tr>
<td>outset</td>
<td>3D outset 边框</td>
</tr>
<tr>
<td>inherit</td>
<td>从父元素继承</td>
</tr>
</tbody>
</table>
<p>XML背景属性</p>
<table>
<thead>
<tr>
<th>属性值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>background-color</td>
<td>背景颜色</td>
</tr>
<tr>
<td>background-position</td>
<td>背景图像的位置</td>
</tr>
<tr>
<td>background-size</td>
<td>规定背景图片的尺寸</td>
</tr>
<tr>
<td>background-repeat</td>
<td>规定如何重复背景图像</td>
</tr>
<tr>
<td>background-origin</td>
<td>背景图片的定位区域</td>
</tr>
<tr>
<td>background-clip</td>
<td>规定背景的绘制区域</td>
</tr>
<tr>
<td>background-attachment</td>
<td>规定背景图像是否固定</td>
</tr>
<tr>
<td>background-image</td>
<td>背景图像</td>
</tr>
<tr>
<td>inherit</td>
<td>从父元素继承</td>
</tr>
</tbody>
</table>
<p>更多属性参考<a href="http://www.w3school.com.cn/cssref/index.asp" target="_blank" rel="external">CSS参考手册</a></p>
<p>链接样式：在xml中加入<code>&lt;?xml-stylesheet type=&quot;text/css&quot; href=&quot;样式名.css&quot;?&gt;</code><br>或者<code>@import url(stylesheetURL)</code><br>无需链接的内部CSS<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;?xml-stylesheet type=&quot;text/css&quot;?&gt;</div><div class="line">&lt;根源素 xmlns:HTML=&quot;URL&quot;&gt;</div><div class="line">	&lt;HTML:STYLE&gt;</div><div class="line">		&lt;!--CSS--&gt;</div><div class="line">	&lt;/HTML:STYLE&gt;</div><div class="line">	&lt;!--XML子元素--&gt;</div><div class="line">&lt;/根源素&gt;</div></pre></td></tr></table></figure></p>
<p>CSS中的注释:<code>/*注释内容*/</code></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[XML Schema]]></title>
      <url>http://www.codingbalian.online/2016/12/21/XML-Schema/</url>
      <content type="html"><![CDATA[<p>XML Schema为详细规定XML文档数据类型与组织结构的标准，且基于XML语法，更加规范。</p>
<blockquote>
<p>本篇介绍W3C标准</p>
</blockquote>
<a id="more"></a>
<p></p><h2 id="1">Schema格式</h2><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;xsd:schema xmlns:xsd=”http://www.w3.org/2001/XMLSchema”&gt;</div><div class="line">    &lt;xsd:element name=&quot;name&quot;&gt;</div><div class="line">        &lt;xsd:complexType&gt;</div><div class="line">            &lt;xsd:sequence&gt;</div><div class="line">                &lt;xsd:element name=&quot;example&quot; type=&quot;xsd:string&quot;/&gt;</div><div class="line">            &lt;/xsd:sequence&gt;</div><div class="line">        &lt;/xsd:complexType&gt;</div><div class="line">    &lt;/xsd:element&gt;</div><div class="line">&lt;/xsd:schema&gt;</div></pre></td></tr></table></figure><p></p>
<p>schema以<code>&lt;xsd:schema xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;</code>开头<code>&lt;/xsd:schema&gt;</code>结尾</p>
<p>complexTypey用来定义复杂类型（包含子元素或者带有属性）<br>type定义数据类型，包括string,int,double,dateTime,Boolean,long,integer,float等<br>sequence规定元素需要依次出现</p>
<p></p><h2 id="2">元素声明</h2><br>schema必须且只能声明一个schema以根元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;xsd:schema xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;</div><div class="line">...</div><div class="line">...</div><div class="line">&lt;/xsd:schema&gt;</div></pre></td></tr></table></figure><p></p>
<p>element声明元素</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>id</td>
<td>规定该元素的唯一的ID</td>
</tr>
<tr>
<td>name</td>
<td>规定元素的名称。父元素是schema则必须含name</td>
</tr>
<tr>
<td>ref</td>
<td>对另一个元素的引用</td>
</tr>
<tr>
<td>type</td>
<td>规定内建数据类型的名称，或者规定 simpleType 或 complexType 元素的名称。</td>
</tr>
<tr>
<td>substitutionGroup</td>
<td>规定可用来替代该元素的元素的名称。 该元素必须具有相同的类型或从指定元素类型派生的类型。</td>
</tr>
<tr>
<td>default</td>
<td>为元素规定默认值（仅当元素内容是简单类型或 textOnly ）。</td>
</tr>
<tr>
<td>fixed</td>
<td>为元素规定固定值（仅当元素内容是简单类型或 textOnly ）</td>
</tr>
<tr>
<td>form</td>
<td>该元素的形式。</td>
</tr>
<tr>
<td>maxOccurs</td>
<td>在父元素中可出现的最大次数。不设限制：”unbounded”</td>
</tr>
<tr>
<td>minOccurs</td>
<td>在父元素中可出现的最小次数。</td>
</tr>
<tr>
<td>nillable</td>
<td>是否可以将显式的零值分配给该元素。此项应用于元素内容并且不是该元素的属性。 默认值为 false。</td>
</tr>
<tr>
<td>abstract</td>
<td>元素是否可以在实例文档中使用。true不能出现在文档中。</td>
</tr>
<tr>
<td>block</td>
<td>派生的类型。防止具有指定派生类型的元素被用于替代该元素。</td>
</tr>
<tr>
<td>final</td>
<td>设置 element 元素上 final 属性的默认值。</td>
</tr>
</tbody>
</table>
<p>block参数：<br>extension - 防止通过扩展派生的元素被用来替代该元素。<br>restriction - 防止通过限制派生的元素被用来替代该元素。<br>substitution - 防止通过替换派生的元素被用来替代该元素。<br>#all - 防止所有派生的元素被用来替代该元素。</p>
<p>final参数：<br>extension - 防止通过扩展派生的元素被用来替代该元素<br>restriction - 防止通过限制派生的元素被用来替代该元素<br>#all - 防止所有派生的元素被用来替代该元素</p>
<p>element常用子元素</p>
<table>
<thead>
<tr>
<th>元素名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>annotation</td>
<td>定义批注</td>
</tr>
<tr>
<td>simpleType</td>
<td>简单类型</td>
</tr>
<tr>
<td>complexType</td>
<td>复杂类型</td>
</tr>
<tr>
<td>key</td>
<td>属性或元素必须是指定的键</td>
</tr>
<tr>
<td>unique</td>
<td>属性或元素在指定范围内唯一</td>
</tr>
<tr>
<td>keyref</td>
<td>指定的元素或属性与指定的key/unique相对应</td>
</tr>
</tbody>
</table>
<p>空元素定义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;xsd:element name=&quot;name&quot;&gt;</div><div class="line">  &lt;xsd:complexType&gt;</div><div class="line">    &lt;xsd:complexContent&gt;</div><div class="line">      &lt;xsd:restriction base=&quot;xs:integer&quot;&gt;</div><div class="line">        &lt;xsd:attribute name=&quot;attribute&quot; type=&quot;xsd:string&quot;/&gt;</div><div class="line">      &lt;/xsd:restriction&gt;</div><div class="line">    &lt;/xsd:complexContent&gt;</div><div class="line">  &lt;/xsd:complexType&gt;</div><div class="line">&lt;/xsd:element&gt;</div></pre></td></tr></table></figure></p>
<p>对应的XML元素定义<code>&lt;name attribute=&quot;string&quot;/&gt;</code></p>
<p>默认值<br><code>&lt;xsd:element name=&quot;author&quot; type=&quot;xsd:string&quot; default=&quot;cheng&quot;&gt;</code></p>
<p>固定值<br><code>&lt;xsd:element name=&quot;author&quot; type=&quot;xsd:integar&quot; fixed=&quot;20&quot;&gt;</code></p>
<p>元素引用<code>&lt;xsd:element name=&quot;&quot; ref=&quot;&quot;&gt;</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">person.xsd</div><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;GB2312&quot;?&gt;</div><div class="line">&lt;xsd:schema xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;</div><div class="line">	&lt;xsd:element name=&quot;person&quot;&gt;</div><div class="line">		&lt;xsd:complexType&gt;</div><div class="line">            &lt;xsd:sequence&gt;</div><div class="line">                &lt;xsd:element name=&quot;name&quot; type=&quot;xsd:string&quot;/&gt;</div><div class="line">				&lt;xsd:element ref=&quot;phone&quot;/&gt;</div><div class="line">            &lt;/xsd:sequence&gt;</div><div class="line">        &lt;/xsd:complexType&gt;</div><div class="line">    &lt;/xsd:element&gt;</div><div class="line">	&lt;xsd:element name=&quot;phone&quot;&gt;</div><div class="line">		&lt;xsd:complexType&gt;</div><div class="line">            &lt;xsd:sequence&gt;</div><div class="line">                &lt;xsd:element name=&quot;number&quot; type=&quot;xsd:string&quot;/&gt;</div><div class="line">            &lt;/xsd:sequence&gt;</div><div class="line">        &lt;/xsd:complexType&gt;</div><div class="line">    &lt;/xsd:element&gt;</div><div class="line">&lt;/xsd:schema&gt;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">XML</div><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;GB2312&quot;?&gt;</div><div class="line">&lt;person xmlns:xsi&quot;http://www.w3.org/2001/XMLSchema&quot; xsi:noNamespaceSchemaLocation=&quot;person.xsd&quot;&gt;</div><div class="line">	&lt;name&gt;Cheng&lt;/name&gt;</div><div class="line">	&lt;phone&gt;</div><div class="line">		&lt;number&gt;123456&lt;/number&gt;</div><div class="line">	&lt;/phone&gt;</div><div class="line">&lt;/person&gt;</div></pre></td></tr></table></figure>
<p>元素替换<br><code>&lt;xs:element name=&quot;&quot; substitutionGroup=&quot;name&quot;/&gt;</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;GB2312&quot;?&gt;</div><div class="line">&lt;xsd:schema xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;</div><div class="line">	&lt;xsd:element name=&quot;person&quot;&gt;</div><div class="line">		&lt;xsd:complexType&gt;</div><div class="line">            &lt;xsd:sequence&gt;</div><div class="line">                &lt;xsd:element name=&quot;name&quot; type=&quot;xsd:string&quot;/&gt;</div><div class="line">				&lt;xsd:element ref=&quot;phone&quot;/&gt;</div><div class="line">            &lt;/xsd:sequence&gt;</div><div class="line">        &lt;/xsd:complexType&gt;</div><div class="line">    &lt;/xsd:element&gt;</div><div class="line">	&lt;xsd:element name=&quot;phone&quot;&gt;</div><div class="line">    &lt;xsd:element name=&quot;number&quot; type=&quot;xsd:string&quot; substitutionGroup=&quot;phone&quot;/&gt;</div><div class="line">&lt;/xsd:schema&gt;</div></pre></td></tr></table></figure>
<p></p><h2 id="3">数据类型</h2><br>内置数据类型<br><code>&lt;xsd:element name=&quot;&quot; type=&quot;&quot;&gt;</code><p></p>
<table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>string</td>
<td>字符串</td>
</tr>
<tr>
<td>boolean</td>
<td>true/false</td>
</tr>
<tr>
<td>date</td>
<td>日期 YYYY-MM-DD</td>
</tr>
<tr>
<td>dateTime</td>
<td>YYYY-MM-DD hh:mm:ss</td>
</tr>
<tr>
<td>time</td>
<td>hh:mm:ss</td>
</tr>
<tr>
<td>decimal</td>
<td>任意精度和位数的十进制数</td>
</tr>
<tr>
<td>integer</td>
<td>整数</td>
</tr>
<tr>
<td>uri-refernce</td>
<td>URL</td>
</tr>
<tr>
<td>float</td>
<td>浮点数</td>
</tr>
</tbody>
</table>
<p>简单自定义类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;xsd:element name=&quot;&quot; type=&quot;自定义简单类型名&quot;&gt;</div><div class="line">&lt;xsd:simpleType name=&quot;自定义简单类型名称&quot;&gt;</div><div class="line">&lt;xsd:restriction base=&quot;现有类型名称&quot;&gt;</div><div class="line">&lt;!--内容--&gt;</div><div class="line">&lt;/xsd:restriction&gt;</div><div class="line">&lt;/xsd:simpleType&gt;</div></pre></td></tr></table></figure></p>
<table>
<thead>
<tr>
<th>base常用约束面</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>enumeration</td>
<td>定义可接受值的列表</td>
</tr>
<tr>
<td>length</td>
<td>允许字符或列表的精确数目</td>
</tr>
<tr>
<td>maxLength</td>
<td>允许字符或列表的最大数目</td>
</tr>
<tr>
<td>minLength</td>
<td>允许字符或列表的最小数目</td>
</tr>
<tr>
<td>pattern</td>
<td>可接受字符的精确序列</td>
</tr>
<tr>
<td>whiteSpace</td>
<td>空白字符的处理方式</td>
</tr>
<tr>
<td>totalDigits</td>
<td>定义所允许的阿拉伯数字的精确位数</td>
</tr>
<tr>
<td>fractionDigits</td>
<td>定义所允许的最大的小数位数</td>
</tr>
<tr>
<td>maxExclusive</td>
<td>定义数值的上限(小于)</td>
</tr>
<tr>
<td>maxInclusive</td>
<td>定义数值的上限(小于等于)</td>
</tr>
<tr>
<td>minExclusive</td>
<td>定义数值的下限(大于)</td>
</tr>
<tr>
<td>minInclusive</td>
<td>定义数值的下限(大于等于)</td>
</tr>
</tbody>
</table>
<p>复杂数据类型(complexType)</p>
<ul>
<li>简单内容元素(simpleContent)仅包含文本属性不包含子元素<br>声明：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;xsd:element name=&quot;&quot; type=&quot;&quot;&gt;</div><div class="line">&lt;xsd:complexType name=&quot;类型名&quot;&gt;</div><div class="line">	&lt;xsd:simpleContent&gt;</div><div class="line">		&lt;xsd:extension base=&quot;简单类型&quot;&gt;</div><div class="line">			&lt;xsd:attribute name=&quot;&quot; type=&quot;&quot;/&gt;		</div><div class="line">		&lt;/xsd:extension&gt;	</div><div class="line">	&lt;/xsd:simpleContent&gt;</div><div class="line">&lt;/xsd:complexType&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>属性声明格式<code>&lt;xsd:attribute name=&quot;&quot; type=&quot;&quot; use=&quot;&quot;/&gt;</code><br>use指定出现与否<code>optional</code>可出现可不出现，<code>required</code>必须出现,<code>prohibited</code>不能出现<br>default设定默认值，fixed指定固定值</p>
<ul>
<li>复杂内容元素complexContent包含子元素<br>声明：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;xsd:element name=&quot;&quot; type=&quot;&quot;&gt;</div><div class="line">&lt;xsd:complexType name=&quot;&quot;&gt;</div><div class="line">	&lt;xsd:complexContent&gt;</div><div class="line">		&lt;xsd:restriction base=&quot;xsd:andType&quot;&gt;</div><div class="line">			&lt;!--子元素声明--&gt;</div><div class="line">			&lt;!--属性声明--&gt;</div><div class="line">		&lt;/xsd:restriction&gt;</div><div class="line">	&lt;/xsd:complexContent&gt;</div><div class="line">&lt;/xsd:complexType&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>complexType通常包含多个子元素，使用<code>all</code>、<code>sequence</code>、<code>choice</code>、<code>group</code>四种结构指示元素顺序</p>
<ol>
<li><p>all：所有成员可以出现一次或者不出现，排序任意,位于顶层不能嵌套</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;all maxOccurs=&quot;0|1&quot; minOccurs=&quot;0|1&quot;&gt;</div><div class="line">	&lt;!--声明--&gt;</div><div class="line">&lt;/all&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>sequence:按顺序出现，默认出现1次，可由maxOccurs和minOccurs控制</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;xsd:sequence&gt;</div><div class="line">	&lt;!--声明--&gt;</div><div class="line">&lt;/xsd:sequence&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>choice:选择一个元素出现，能与sequence嵌套</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;xsd:choice minOccurs=&quot;&quot; maxOccurs=&quot;&quot;&gt;</div><div class="line">&lt;!--声明--&gt;</div><div class="line">&lt;/xsd:choice&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>group:归为一组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;xsd:group minOccurs=&quot;&quot; maxOccurs=&quot;&quot; name=&quot;&quot; ref=&quot;组名&quot;&gt;</div><div class="line">&lt;!--声明--&gt;</div><div class="line">&lt;/xsd:group&gt;</div></pre></td></tr></table></figure>
</li>
</ol>
<p></p><h2 id="4">命名空间</h2><p></p>
<p><xsd: schema="" targetnamespace="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns=""></xsd:></p>
<ul>
<li>targetNamespace目标命名空间，schema规定在其中有效</li>
<li>标准命名空间：<a href="http://www.w3.org/2001/XMLSchema" target="_blank" rel="external">http://www.w3.org/2001/XMLSchema</a> </li>
<li>默认命名空间：自定义文件的地址</li>
</ul>
<p>引用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#已定义目标命名空间</div><div class="line">&lt;根源素名 xmlns=&quot;www.studaholic.online/xml&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema&quot; </div><div class="line">xsi:schemaLocation=&quot;www.studaholic.online/xml/文档名.xsd&quot;</div><div class="line">/&gt;</div><div class="line">#未定义目标命名空间</div><div class="line">&lt;根源素名 xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema&quot; </div><div class="line">xsi:noNamespaceSchemaLocation=&quot;文档名.xsd&quot; 属性名=&quot;&quot;</div><div class="line">/&gt;</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[XML:DTD]]></title>
      <url>http://www.codingbalian.online/2016/12/20/XML-DTD/</url>
      <content type="html"><![CDATA[<p>XML文档类型定义DTD(Document Type Definition)要求XML文件遵守规定的语法。<br><a id="more"></a></p>
<h2 id="1">DTD作用</h2><br>1. 指定文档结构的规则<br>2. 验证文档有效性<br>3. 可以被共享<br>4. 可以在描述的文档中与外部的URL链接<br><br><h2 id="2">DTD结构</h2><br>1. <code>&lt;!DOCTYPE</code>开头<code>]&gt;</code>结尾<br>2. <code>&lt;!ELEMENT&gt;</code>声明元素<br>3. <code>&lt;!ATTLIST&gt;</code> 声明元素属性<br>4. <code>&lt;!ENTITY&gt;</code>声明实体，可以用来存储常用的文字区块，或将非XML的数据包括在文档中<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; standalone=&quot;yes&quot;?&gt;</div><div class="line">&lt;!--DTD定义--&gt;</div><div class="line">&lt;!DOCTYPE 公司[</div><div class="line">&lt;!--元素定义--&gt;</div><div class="line">&lt;!ELEMENT 公司 (雇员)+&gt;</div><div class="line">&lt;!ELEMENT 雇员 (姓名,雇佣日期,项目清单,说明)&gt;</div><div class="line">&lt;!ELEMENT 姓名 (#PCDATA)&gt;</div><div class="line">&lt;!ELEMENT 雇佣日期 (#PCDATA)&gt;</div><div class="line">&lt;!ELEMENT 项目清单 (项目)*&gt;</div><div class="line">&lt;!ELEMENT 项目 (产品,价格)&gt;</div><div class="line">&lt;!ELEMENT 产品 (#PCDATA)&gt;</div><div class="line">&lt;!ELEMENT 价格 (#PCDATA)&gt;</div><div class="line">&lt;!--属性定义--&gt;</div><div class="line">&lt;!ATTLIST 项目清单 数量 CDATA #REQUIRED&gt;</div><div class="line">&lt;!ATTLIST 雇员</div><div class="line">    部门 CDATA #IMPLIED</div><div class="line">    全职 CDATA #IMPLIED</div><div class="line">&gt;</div><div class="line">&lt;!ENTITY  note  &quot;这里是备注信息&quot;&gt;</div><div class="line">]&gt;</div><div class="line">&lt;!--内容定义--&gt;</div><div class="line">&lt;公司&gt;</div><div class="line">    &lt;雇员 部门=&quot;市场部&quot; 全职=&quot;是&quot;&gt;</div><div class="line">        &lt;姓名&gt;李东&lt;/姓名&gt;</div><div class="line">        &lt;雇佣日期&gt;2005-01-15&lt;/雇佣日期&gt;</div><div class="line">        &lt;项目清单 数量=&quot;2&quot;&gt;</div><div class="line">            &lt;项目&gt;</div><div class="line">                &lt;产品&gt;打印机&lt;/产品&gt;</div><div class="line">                &lt;价格&gt; $111.00=&quot;&quot;&gt;&lt;/价格&gt;</div><div class="line">            &lt;/项目&gt;</div><div class="line">            &lt;项目&gt;</div><div class="line">                &lt;产品&gt;笔记本&lt;/产品&gt;</div><div class="line">                &lt;价格&gt; $998.00&gt;&lt;/价格&gt;</div><div class="line">            &lt;/项目&gt;</div><div class="line">        &lt;/项目清单&gt;</div><div class="line">        &lt;说明&gt;这里是备注信息&lt;/说明&gt;</div><div class="line">    &lt;/雇员&gt;</div><div class="line">    &lt;雇员 部门=&quot;客服部&quot;&gt;</div><div class="line">        &lt;姓名&gt;王权&lt;/姓名&gt;</div><div class="line">        &lt;雇佣日期&gt;2005-10-2&lt;/雇佣日期&gt;</div><div class="line">        &lt;项目清单 数量=&quot;1&quot;&gt;</div><div class="line">            &lt;项目&gt;</div><div class="line">                &lt;产品&gt;扫描仪&lt;/产品&gt;</div><div class="line">                &lt;价格&gt; $200.00=&quot;&quot;&gt;&lt;/价格&gt;</div><div class="line">            &lt;/项目&gt;</div><div class="line">        &lt;/项目清单&gt;</div><div class="line">        &lt;说明&gt;这里是备注信息&lt;/说明&gt;</div><div class="line">    &lt;/雇员&gt;</div><div class="line"> &lt;/公司&gt;</div></pre></td></tr></table></figure><br><br>在IE中运行显示&lt;!DOCTYPE 公司 (View Source of full doctype……)&gt;说明是内部DTD<br><br><h2 id="3">DTD元素类型</h2><br>1. 空元素<code>&lt;!ELEMENT 元素 EMPTY&gt;</code>对应XML<code>&lt;元素/&gt;</code><br>2. ANY类型<code>&lt;!ELEMENT 元素 ANY&gt;</code>表明元素可以包含定义的其他任意内容或任意内容的组合<br>3. #PCDATA(可解析文本)，不能再包含子元素<br>4. 子元素<code>&lt;!ELEMENT 元素 (子元素列表)&gt;</code>包括序列与选择两种结构<code>&lt;!ELEMENT 元素 (元素1,元素2)&gt;</code>表示顺序，<code>&lt;!ELEMENT 元素 (元素1|元素2)&gt;</code>表示选择，至少选其一<br>5. 混合类型<code>&lt;!ELEMENT 元素 (#PCDATA|子元素1|子元素2)*&gt;</code><br><br><h2 id="4">元素限定符</h2>

<table>
<thead>
<tr>
<th>符号</th>
<th style="text-align:center">用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>()</td>
<td style="text-align:center">分组</td>
</tr>
<tr>
<td>&brvbar;</td>
<td style="text-align:center">选择</td>
</tr>
<tr>
<td>+</td>
<td style="text-align:center">最少出现一次</td>
</tr>
<tr>
<td>*</td>
<td style="text-align:center">允许出现任意多次</td>
</tr>
<tr>
<td>?</td>
<td style="text-align:center">出现0~1次</td>
</tr>
<tr>
<td>,</td>
<td style="text-align:center">必须按指定顺序出现</td>
</tr>
</tbody>
</table>
<p>**DTD属性</p>
<ul>
<li>设定元素属性与名称</li>
<li>设定属性数据类型</li>
<li>设定是否可选，是否属性固定，以及默认值</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;!ATTLIST ELEMENT_name</div><div class="line">    Attribute_name TYPE [add_declare]&gt;</div></pre></td></tr></table></figure>
<p>属性类型</p>
<table>
<thead>
<tr>
<th>类型名称</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>CDATA</td>
<td style="text-align:center">值为普通的字符</td>
</tr>
<tr>
<td>ID</td>
<td style="text-align:center">值在文档中是唯一的</td>
</tr>
<tr>
<td>IDREF</td>
<td style="text-align:center">值参考了文档中另一个ID属性</td>
</tr>
<tr>
<td>IDREFS</td>
<td style="text-align:center">值参考了用空格隔开的多个文档中的ID属性</td>
</tr>
<tr>
<td>ENTITY</td>
<td style="text-align:center">值是一个外部实体</td>
</tr>
<tr>
<td>ENTITIES</td>
<td style="text-align:center">值包含了多个外部实体，用空格隔开</td>
</tr>
<tr>
<td>NMTOKEN</td>
<td style="text-align:center">值只能由字母、数字、下划线、连字符、圆点、冒号等字符组成</td>
</tr>
<tr>
<td>NMTOKENS</td>
<td style="text-align:center">值由多个nmtoken组成，用空格隔开</td>
</tr>
<tr>
<td>NOTATION</td>
<td style="text-align:center">值是在DTD中声明过的注解名称</td>
</tr>
<tr>
<td>Enumerated</td>
<td style="text-align:center">列出能够赋予该属性的各种值的列表，只能从中选定一个属性值</td>
</tr>
</tbody>
</table>
<p>在DTD中声明一个NOTATION类型的属性时，必须首先声明一个具体的NOTATION用来指向应用软件所在的位置，声明的方式有两种:<br>一种是使用MIME类型，格式为：<br><code>&lt;!NOTATION 记号名 SYSTEM &quot;MIME类型&quot;&gt;</code><br>另一种是使用URL路径，指定一个处理程序的路径，格式为：<br><code>&lt;!NOTATION 记号名 SYSTEM  &quot;URL&quot;&gt;</code></p>
<p>属性的附加声明<br>added_declare是属性定义中的可选内容。附加声明指明了该属性是必要的还是可选的，是预设的固定属性值还是当属性值被省略时的默认值</p>
<table>
<thead>
<tr>
<th>附加声明</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>#REQUIRED</td>
<td>必须给出属性值</td>
</tr>
<tr>
<td>#IMPLIIED</td>
<td>可以不出现</td>
</tr>
<tr>
<td>#FIXED AttValue</td>
<td>固定值</td>
</tr>
<tr>
<td>Default_Value</td>
<td>默认</td>
</tr>
</tbody>
</table>
<h2 id="5">DTD引用</h2>

<p>内部DTD</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE 公司[</div><div class="line">	声明语句</div><div class="line">]&gt;</div></pre></td></tr></table></figure>
<p>外部DTD</p>
<p>引用私有DTD：<br><code>&lt;!DOCTYPE  RootElementName  SYSTEM  DTD_URL&gt;</code><br>引用公有DTD：<br><code>&lt;!DOCTYPE RootElementName PUBLIC DTD_name  DTD_URL&gt;</code></p>
<ul>
<li>RootElementName根源素</li>
<li>SYSTEM 私有</li>
<li>PUBLIC 公用</li>
<li>DTD_name DTD文件名</li>
<li>DTD_URL DTD文件路径</li>
</ul>
<h2 id="6">DTD实体</h2>

<p>普通实体<br>用来插入文本。<br>内部普通实体<br><code>&lt;!ENTITY Entity_Name Entity_Value&gt;</code><br>外部普通实体<br><code>&lt;!ENTITY Entity_Name SYSTEM Entity_URL&gt;</code><br>SYSTEM是定义外部实体的关键字<br>引用<code>&amp;Enitiy_Name;</code><br>参数实体<br>不仅可以包含文本，还可以包含元素类型声明、属性列表声明、一般实体声明、标签声明、处理指令或注释等，只能在DTD中引用，并且通常情况下只能在外部DTD文档中引用。<br>内部参数实体<br><code>&lt;!ENTITY % Entity_Name Entity_Value&gt;</code><br>外部参数实体<br><code>&lt;!ENTITY % Entity_Name SYSTEM Entity_URL&gt;</code><br>引用<code>&amp;Enitiy_Name;</code><br>不可解析实体<br>二进制文件，如图形、声音等非字符型数据，唯一可以出现不可解析实体的地方就是属性值且不能进行引用<br>链接是XML文档:<br><code>&lt;!ENTITY name SYSTEM &quot;URI&quot;&gt;</code><br>不是XML文档<br><code>&lt;!ENTITY name SYSTEM “URI”NDATA  type&gt;</code></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[XML：语法基础]]></title>
      <url>http://www.codingbalian.online/2016/12/20/XML/</url>
      <content type="html"><![CDATA[<p>XML语法基础的介绍实例<br><a id="more"></a></p>
<p></p><h2 id="1">XML声明</h2><br><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;GB2312&quot; standalone=&quot;no&quot;?&gt;</code><p></p>
<ul>
<li>version属性规定了XML文档的版本，默认为1.0</li>
<li>encoding属性表示XML文档使用的字符编码，默认为UTF-8</li>
<li>standalone属性定义是否可以在不读取其他文件的情况下处理改文档，默认为no，若没有引用其他文件可以设置为yes</li>
</ul>
<p></p><h2 id="2">XML注释</h2><br><code>&lt;!--注释--&gt;</code><p></p>
<ul>
<li>注释内不能包含<code>-</code>和<code>--</code>。</li>
<li>不能放在元素标记内。</li>
<li>注释不能嵌套。</li>
<li>元素开始结束标签不能被注释掉。</li>
</ul>
<p></p><h2 id="3">XML元素</h2><br><code>&lt;标记名&gt;内容&lt;/标记名&gt;</code><p></p>
<ul>
<li>标记名为元素名称。</li>
<li>名称不能以数字可标点开头。</li>
<li>不能以XML开头。</li>
<li>名称不能包含空格。</li>
<li>不要使用”:”</li>
<li>空元素:<code>&lt;title&gt;&lt;/title&gt;</code>或<code>&lt;title/&gt;</code></li>
<li>空元素也可以携带属性：<code>&lt;书籍 作者=&quot;作者&quot; /&gt;</code></li>
</ul>
<p></p><h2 id="4">XML属性</h2><br><code>&lt;标记名 属性1=&quot;属性&quot; 属性2=&quot;属性&quot;&gt;内容&lt;/标记名&gt;</code><br><code>&lt;空标记 属性=&quot;属性&quot;/&gt;</code><p></p>
<ul>
<li>CSS来显示XML的时候不会显示属性。</li>
<li>属性值中有<code>&#39;&#39;</code>时需要用<code>&quot;&quot;</code>括起来，反之亦然。</li>
<li>属性值不能包含<code>&lt;&gt;&amp;</code>等。</li>
</ul>
<p></p><h2 id="5">CDATA</h2><br>包括的内容都当做纯文本解析，为<code>&lt;&gt;&amp;</code>等符号设计。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;![CDATA[</div><div class="line">	内容</div><div class="line">]]&gt;</div></pre></td></tr></table></figure><p></p>
<ul>
<li>不能嵌套。</li>
<li><code>]]&gt;</code>前不能有空格。</li>
<li>必须在元素内容内。</li>
</ul>
<p></p><h2 id="6">XML命名空间</h2><br><code>&lt;标记名 xmlns: 标识符=&quot;URI&quot;&gt;</code> <p></p>
<ul>
<li>标识符唯一。</li>
<li>URI在Web上归属于URL或URN。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;GB2312&quot;?&gt;</div><div class="line">&lt;DocumentElement xmlns:books=&quot;http:www.aa.com&quot; xmlns:person=&quot;http:www.cc.com&quot;&gt;</div><div class="line">&lt;book&gt;</div><div class="line">&lt;books:NAME&gt;耶路撒冷三千年&lt;/books:NAME&gt;</div><div class="line">&lt;person:NAME&gt;贝里昂&lt;/person:NAME&gt;</div><div class="line">&lt;price&gt;20&lt;/price&gt;</div><div class="line">&lt;/book&gt;</div><div class="line">&lt;/DocumentElement&gt;</div></pre></td></tr></table></figure>
<ul>
<li>DocumentElement定义了book和person的标识符为命名空间，在文档元素前添加特定的命名空间可以加以区分。</li>
<li>也可在属性中使用命名空间。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;GB2312&quot;?&gt;</div><div class="line">&lt;DocumentElement xmlns:books=&quot;http:www.aa.com&quot; xmlns:person=&quot;http:www.cc.com&quot;&gt;</div><div class="line">&lt;book books:NAME&gt;耶路撒冷三千年</div><div class="line">&lt;person:NAME&gt;贝里昂&lt;/person:NAME&gt;</div><div class="line">&lt;price&gt;20&lt;/price&gt;</div><div class="line">&lt;/book&gt;</div><div class="line">&lt;/DocumentElement&gt;</div></pre></td></tr></table></figure>
<ul>
<li>默认命名空间<code>&lt;标记名 xmlns=&quot;URI&quot;&gt;</code> 指定后所有未标识命名空间的元素都归属于默认命名空间。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;GB2312&quot;?&gt;</div><div class="line">&lt;DocumentElement xmlns=&quot;http:www.aa.com&quot; xmlns:person=&quot;http:www.cc.com&quot;&gt;</div><div class="line">&lt;book&gt;</div><div class="line">&lt;NAME&gt;耶路撒冷三千年&lt;/NAME&gt;</div><div class="line">&lt;person:NAME&gt;贝里昂&lt;/person:NAME&gt;</div><div class="line">&lt;price&gt;20&lt;/price&gt;</div><div class="line">&lt;/book&gt;</div><div class="line">&lt;/DocumentElement&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
<p></p><h2 id="7">空白字符</h2><br><code>&lt;DocumentElement xml:space=&quot;preserve/default&quot;&gt;</code><p></p>
<ul>
<li>默认不处理无意空白字符，使用<code>xml:space=&quot;preserve</code>可以保留空白字符。</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Github教程]]></title>
      <url>http://www.codingbalian.online/2016/12/20/Github-Tutorial/</url>
      <content type="html"><![CDATA[<p>Github 部分功能使用教程<br><a id="more"></a><br>上传：<br>在GitHub上创建仓库<br>使用Git Bush进入本地仓库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">git init</div><div class="line">touch README</div><div class="line">git add .</div><div class="line">git commit -m &apos;first commit&apos;</div><div class="line">git remote add origin git@github.com:yourname/yourrepositoryname.git</div><div class="line">git push -u origin master</div></pre></td></tr></table></figure></p>
<p>上传至master分支<br>在本地新建分支： <code>git branch Branch</code><br>切换分支: <code>git checkout Branch</code><br>将新分支发布： <code>git push origin Branch</code><br>在本地删除分支： <code>git branch -d Branch</code><br>在github远程端删除分支： <code>git push origin :Branch</code><br>取回仓库并与本地合并<code>git pull origin</code><br>克隆仓库<code>git clone https://github.com/BalianCheng/BalianCheng.github.io.git</code></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Adaboost]]></title>
      <url>http://www.codingbalian.online/2016/12/20/Adaboost/</url>
      <content type="html"><![CDATA[<p>Adaboost是一种迭代算法，其核心思想是针对同一个训练集训练不同的分类器(弱分类器)，然后把这些弱分类器集合起来，构成一个更强的最终分类器（强分类器）。<br><a id="more"></a></p>
<h2 id="1">Adaboost过程</h2><br>1. 先通过对N个训练样本的学习得到第一个弱分类器；<br>2. 将分错的样本和其他的新数据一起构成一个新的N个的训练样本，通过对这个样本的学习得到第二个弱分类器 ；<br>3. 将1和2都分错了的样本加上其他的新样本构成另一个新的N个的训练样本，通过对这个样本的学习得到第三个弱分类器；<br>4. 最终经过提升的强分类器。即某个数据被分为哪一类要由各分类器权值决定。<br>训练数据中的每个样本，并赋予其一个权重，这些权重构成了向量D。一开始，这些权重都初始化成相等值。首先在训练数据上训练出一个弱分类器并计算该分类器的错误率，然后在同一数据集上再次训练弱分类器。在分类器的第二次训练当中，将会重新调整每个样本的权重，其中第一次分对的样本的权重将会降低，而第一次分错的样本的权重将会提高。为了从所有弱分类器中得到最终的分类结果，AdaBoost为每个分类器都分配了一个权重值alpha，这些alpha值是基于每个弱分类器的错误率进行计算的。<br>错误率ε的定义为<br>$$ε=\frac{未正确分类的样本数}{所有样本数}$$<br>alpha：<br>$$α=\frac{1}{2}ln\frac{1-ε}{ε}$$<br><img src="http://i1.piimg.com/567571/f46e6188192028b6.png" alt=""><br>AdaBoost算法的示意图。左边是数据集，其中直方图的不同宽度表示每个样例上的不同权重。在经过一个分类器之后，加权的预测结果会通过三角形中的alpha值进行加权。每个三角形中输出的加权结果在圆形中求和，从而得到最终的输出结果计算出alpha值之后，可以对权重向量D进行更新，以使得那些正确分类的样本的权重降低而错分样本的权重升高。<br>D的计算方法如下:<br>如果某个样本被正确分类，那么该样本的权重更改为：<br>$$D_i^{(t+1)}=\frac{D_i^{(t)}e^-α}{Sum(D)}$$<br>而如果某个样本被错分，那么该样本的权重更改为：<br>$$D_i^{(t+1)}=\frac{D_i^{(t)}e^α}{Sum(D)}$$<br>在计算出D之后，AdaBoost又开始进入下一轮迭代。AdaBoost算法会不断地重复训练和调整权重的过程，直到训练错误率为0或者弱分类器的数目达到用户的指定值为止。<br><br><h2 id="2">自适应数据加载函数</h2><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">def loadDataSet(filename):  </div><div class="line">    numFeat = len(open(filename).readline().split(&apos;\t&apos;))  </div><div class="line">    dataMat = []  </div><div class="line">    labelMat=[]  </div><div class="line">    fr = open(filename)  </div><div class="line">    for line in fr.readlines():  </div><div class="line">        lineArr= []  </div><div class="line">        curLine = line.strip(&apos;\n&apos;).split(&apos;\t&apos;)  </div><div class="line">        for i in range(numFeat - 1):  </div><div class="line">            lineArr.append(float(curLine[i]))  </div><div class="line">        dataMat.append(lineArr)  </div><div class="line">        labelMat.append(float(curLine[-1]))  </div><div class="line">    fr.close()  </div><div class="line">    return dataMat, labelMat</div></pre></td></tr></table></figure><br><br> * 并不指定每个文件中的特征数目，可以自动检测，并假定最后一个特征是类别标签<br><br><h2 id="3">单层决策树生成函数</h2>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">def stumpClassify(dataMatrix, dimen, threshVal, threshIneq):  </div><div class="line">    retArray = ones((shape(dataMatrix)[0],1))  </div><div class="line">    if threshIneq == &apos;lt&apos;:  </div><div class="line">        retArray[dataMatrix[:,dimen]&lt;threshVal] = -1.0  </div><div class="line">    else:  </div><div class="line">        retArray[dataMatrix[:,dimen]&lt;threshVal] = -1.0  </div><div class="line">    return retArray  </div><div class="line"></div><div class="line">def buildStump(dataArr, classLabels, D):  </div><div class="line">    dataMatrix = mat(dataArr); labelMat = mat(classLabels).T  </div><div class="line">    m,n = shape(dataMatrix)  </div><div class="line">    numSteps = 10.0; bestStump = &#123;&#125;; #定义一个空字典，用于存储给定权重向量D时所得到的最佳单层决策树的相关信息  </div><div class="line">	bestClassEst = mat(zeros((m,1)))  </div><div class="line">    minError = inf  #最小错误率初始化为无穷大</div><div class="line">    for i in range(n):  #在所有数据集的所有特征上遍历  </div><div class="line">        rangeMin = dataMatrix[:,i].min(); rangeMax = dataMatrix[:,i].max();  </div><div class="line">        stepSize = (rangeMax - rangeMin)/numSteps #通过计算特征的最小值和最大值来计算步长，numSteps越大，步长越小   </div><div class="line">        for j in range(-1, int(numSteps)+1):  #按分的步长总数进行循环</div><div class="line">            for inequal in [&apos;lt&apos;,&apos;gt&apos;]:  </div><div class="line">                threshVal = (rangeMin + float(j)*stepSize)  </div><div class="line">                predictedVals = stumpClassify(dataMatrix, i, threshVal, inequal)  </div><div class="line">                errArr = mat(ones((m,1)))   #构建错误数组  errArr，如果predict-edVals中的值不等于labelMat中的真正类别标签值，那么errArr的相应位置为1</div><div class="line">                errArr[predictedVals == labelMat] = 0  </div><div class="line">                weightedError = D.T * errArr           #这里的error是错误向量errArr和权重向量D的相应元素相乘得到的即加权错误率  </div><div class="line">                #print &quot;split: dim %d, thresh %.2f, thresh inequal: %s, the weighted error is %.3f&quot; %(i, threshVal, inequal, weightedError)  </div><div class="line">                if weightedError &lt; minError:  </div><div class="line">                    minError = weightedError  </div><div class="line">                    bestClassEst = predictedVals.copy()  </div><div class="line">                    bestStump[&apos;dim&apos;] = i  </div><div class="line">                    bestStump[&apos;thresh&apos;] = threshVal  </div><div class="line">                    bestStump[&apos;ineq&apos;] = inequal  </div><div class="line">    return bestStump, minError, bestClassEst #返回分类的最小错误率</div></pre></td></tr></table></figure>
<ul>
<li>stumpClassify()通过阈值比较进行分类，可以通过数组过滤实现，首先将返回的元素全部设置为1，不满足等式的元素设置为为-1。</li>
<li>buildStump()有三层循环构建了单层决策树，最外层循环为遍历特征，次外层循环为遍历的步长，最内层为是否大于或小于阀值。构建的最小错误率为加权错误率，这就是为什么增加分错样本的权重，因为分错样本的权重增加了，下次如果继续分错，加权错误率会很大，这就不满足算法最小化加权错误率了。此外，加权错误率在每次迭代过程中一定是逐次降低的。</li>
<li>单层决策树的生成函数是决策树的一个简化版本。它就是所谓的弱学习器，即弱分类算法。</li>
</ul>
<p></p><h2 id="4">基于单层决策树的adaboost训练过程</h2><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">def adaBoostTrainDS(dataArr, classLabels, numIt = 40):  </div><div class="line">    weakClassArr = []  #建立一个单层决策树数组</div><div class="line">    m = shape(dataArr)[0]  #得到数据点的数目</div><div class="line">    D = mat(ones((m,1))/m) #向量D非常重要，它包含了每个数据点的权重 </div><div class="line">    aggClassEst = mat(zeros((m,1)))#列向量aggClassEst，记录每个数据点的类别估计累计值  </div><div class="line">    for i in range(numIt):  </div><div class="line">        bestStump, error, classEst = buildStump(dataArr, classLabels, D)  #bestStump=字典,error=分类错误率,classEst=列向量，预测之后的分类列表</div><div class="line">       # print &quot;D:&quot;, D.T  </div><div class="line">        alpha = float(0.5 * log((1.0 - error)/max(error, 1e-16)))   #确保在没有错误时不会发生除零溢出  </div><div class="line">        bestStump[&apos;alpha&apos;] = alpha  </div><div class="line">        weakClassArr.append(bestStump)  </div><div class="line">        #print &quot;classEst:&quot;, classEst.T  </div><div class="line">        expon = multiply(-1 * alpha * mat(classLabels).T, classEst)    #乘法用于区分是否正确或者错误样本,样本被正确分类的话expon为负，错误分类的话为正,其中第一次分对的样本的权重将会降低，而第一次分错的样本的权重将会提高  </div><div class="line">        D = multiply(D, exp(expon))  #计算新权重向量D  </div><div class="line">        D = D/D.sum()            # 归一化用的  </div><div class="line">        aggClassEst += alpha * classEst    #累加变成强分类器  </div><div class="line">        aggErrors = multiply(sign(aggClassEst) != mat(classLabels).T, ones((m,1)))  </div><div class="line">        errorRate = aggErrors.sum()/m  </div><div class="line">        print &quot;total error: &quot;, errorRate, &quot;\n&quot;  </div><div class="line">        if errorRate == 0.0: break  </div><div class="line">    return weakClassArr, aggClassEst</div></pre></td></tr></table></figure><p></p>
<ul>
<li>对每次迭代：<br>利用buildStump()函数找到最佳的单层决策树<br>将最佳单层决策树加入到单层决策树数组<br>计算alpha<br>计算新的权重向量D<br>更新累计类别估计值<br>如果错误率等于0.0，则退出循环<ul>
<li>我们假定迭代次数设为9，如果算法在第三次迭代之后错误率为0，那么就会退出迭代过程，因此，此时就不需要执行所有的9次迭代过程。每次迭代的中间结果都会通过print语句进行输出。</li>
</ul>
</li>
</ul>
<p></p><h2 id="5">adaboost分类函数</h2><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">def adaClassify(datToClass, classifierArr):  </div><div class="line">    dataMatrix = mat(datToClass)  </div><div class="line">    m = shape(dataMatrix)[0]  </div><div class="line">    aggClassEst = mat(zeros((m,1)))  </div><div class="line">    for i in range(len(classifierArr)):  </div><div class="line">        classEst = stumpClassify(dataMatrix, classifierArr[i][&apos;dim&apos;], classifierArr[i][&apos;thresh&apos;], classifierArr[i][&apos;ineq&apos;])  </div><div class="line">        aggClassEst += classifierArr[i][&apos;alpha&apos;]*classEst  </div><div class="line">        print aggClassEst  </div><div class="line">    return sign(aggClassEst)</div></pre></td></tr></table></figure><p></p>
<ul>
<li>adaClassify()函数就是利用训练出的多个弱分类器进行分类的函数。该函数的输入是由一个或者多个待分类样例datToClass以及多个弱分类器组成的数组classifierArr。程序返回aggClassEst的符号，即如果aggClassEst大于0则返回+1，而如果小于0则返回-1。</li>
</ul>
<p></p><h2 id="6">画决策树的图</h2><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">def plot_Fig(xMat,yMat,weakClassArr):  </div><div class="line">    xMat = mat(xMat)  </div><div class="line">    fig = plt.figure()  </div><div class="line">    ax = fig.add_subplot(111)  </div><div class="line">    for i in range(len(yMat)):  </div><div class="line">        if yMat[i] == -1.0: #如果标签为-1，则将数据点标为蓝色方块  </div><div class="line">            ax.scatter(xMat[i,0],xMat[i,1],color=&apos;b&apos;,marker=&apos;s&apos;) #注意flatten的用法  </div><div class="line">        else:  #如果标签为1，则将数据点标为红色圆形  </div><div class="line">            ax.scatter(xMat[i,0],xMat[i,1],color=&apos;r&apos;,marker=&apos;o&apos;)  </div><div class="line">    for i in range(len(weakClassArr)): #根据弱分类器数组画出决策树图形  </div><div class="line">        if weakClassArr[i].get(&quot;dim&quot;) == 0:   </div><div class="line">            y = arange(0.0,3.0,0.1)  </div><div class="line">            x = weakClassArr[i].get(&quot;thresh&quot;) #得到阈值  </div><div class="line">            x = repeat(x,len(y))  </div><div class="line">            ax.plot(x,y)  </div><div class="line">        if weakClassArr[i].get(&quot;dim&quot;) == 1:  </div><div class="line">            x = arange(0.0,3.0,0.1)  </div><div class="line">            y = weakClassArr[i].get(&quot;thresh&quot;)  </div><div class="line">            y = repeat(y,len(x))  </div><div class="line">            ax.plot(x,y)   </div><div class="line">    plt.show()</div></pre></td></tr></table></figure><p></p>
<p></p><h2 id="7">ROC曲线</h2><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">def plotROC(predStrengths, classLabels):  </div><div class="line">    import matplotlib.pyplot as plt  </div><div class="line">    cur = (1.0,1.0) #cursor绘制光标的位置  </div><div class="line">    ySum = 0.0 #variable to calculate AUC；用于计算AUC的值  </div><div class="line">    numPosClas = sum(array(classLabels)==1.0) #计算正例的数目  </div><div class="line">    yStep = 1/float(numPosClas); #确定y坐标轴上的步长，因为当y为1时，对应的正例个数为numPosClas  </div><div class="line">    xStep = 1/float(len(classLabels)-numPosClas) #计算x坐标轴上的步长，因为当x为1时，对应的负例个数为总数减去numPosClas  </div><div class="line">    sortedIndicies = predStrengths.argsort()#get sorted index, it&apos;s reverse  </div><div class="line">    fig = plt.figure()  </div><div class="line">    fig.clf()  </div><div class="line">    ax = plt.subplot(111)  </div><div class="line">    #loop through all the values, drawing a line segment at each point  </div><div class="line">    for index in sortedIndicies.tolist()[0]: #利用tolist()转化为列表，  </div><div class="line">        if classLabels[index] == 1.0: #每得到一个标签为1.0的类，沿着y轴的方向下降一个步长，即不断降低真阳率（好好体会为什么这样做）  </div><div class="line">            delX = 0; delY = yStep;  </div><div class="line">        else:  </div><div class="line">            delX = xStep; delY = 0; #类似   </div><div class="line">            ySum += cur[1] #先对所有矩形的高度进行累加（当y值下降时不累加），最后再乘以xStep就是其总面积。  </div><div class="line">        #draw line from cur to (cur[0]-delX,cur[1]-delY)  </div><div class="line">        ax.plot([cur[0],cur[0]-delX],[cur[1],cur[1]-delY], c=&apos;b&apos;)  </div><div class="line">        cur = (cur[0]-delX,cur[1]-delY) #更新绘制光标的位置  </div><div class="line">    ax.plot([0,1],[0,1],&apos;b--&apos;)  </div><div class="line">    plt.xlabel(&apos;False positive rate&apos;); plt.ylabel(&apos;True positive rate&apos;)  </div><div class="line">    plt.title(&apos;ROC curve for AdaBoost horse colic detection system&apos;)  </div><div class="line">    ax.axis([0,1,0,1])  </div><div class="line">    print &quot;the Area Under the Curve is: &quot;,ySum*xStep  </div><div class="line">    plt.show()</div></pre></td></tr></table></figure><p></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[github pages + Hexo + 域名绑定]]></title>
      <url>http://www.codingbalian.online/2016/12/19/github-pages-Hexo/</url>
      <content type="html"><![CDATA[<p>本文从安装环境开始详细讲述如何使用github pages + Hexo搭建自己的静态博客，并且使用阿里云绑定域名。<br><a id="more"></a></p>
<p></p><h2 id="1">环境</h2><p></p>
<ol>
<li>安装Git<img src="http://oifuxc6w5.bkt.clouddn.com/git.png" alt=""></li>
<li>安装Node<img src="http://oifuxc6w5.bkt.clouddn.com/NODEJS.png" alt=""></li>
<li>验证安装<img src="http://oifuxc6w5.bkt.clouddn.com/cmd.png" alt=""></li>
</ol>
<p></p><h2 id="2">Github Pages</h2><br> 在GitHub创建一个格式为：yourusername.github.io的仓库即可。<br><img src="http://oifuxc6w5.bkt.clouddn.com/gitmaven.png" alt=""><p></p>
<p></p><h2 id="3">Hexo</h2><br>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。<br>建立一个blog文件夹用于存放博客文件,然后右键单击选择“Git Bash”。<br><code>npm install hexo-cli -g</code><br><code>hexo init blog</code><br><code>cd blog</code><br><code>npm install</code><br><code>hexo server</code><br>执行hexo server时，默认端口是4000,如果端口被占用更换即可。<br>如<code>hexo server -p 4001</code><br>访问<code>http://localhost:4000/</code><br><img src="http://oifuxc6w5.bkt.clouddn.com/hexo.png" alt=""><p></p>
<p></p><h2 id="4">更换主题</h2><br>exo-theme：<a href="https://hexo.io/themes/" target="_blank" rel="external">https://hexo.io/themes/</a><br>hexo-github-theme-list：<a href="https://github.com/hexojs/hexo/wiki/Themes" target="_blank" rel="external">https://github.com/hexojs/hexo/wiki/Themes</a><br><code>git clone</code>加上主题地址<br>_config.yml中将theme改成刚刚下载的主题<br>修改完成后<code>hexo generate</code>  <code>hexo server</code>重启服务器查看效果<br><img src="http://oifuxc6w5.bkt.clouddn.com/newtheme.png" alt=""><p></p>
<p></p><h2 id="5">部署代码到github</h2><br><code>ssh-keygen -t rsa -C &quot;你的邮箱地址&quot;</code>生成SSH秘钥<br>在<a href="https://github.com/settings/ssh" target="_blank" rel="external">https://github.com/settings/ssh</a> 添加id_rsa.pub中的秘钥<br>安装插件：<br><code>npm install hexo -server --save</code><br><code>npm install hexo-deployer-git --save</code><br>安装其他插件的格式为<code>npm install ... --save</code><br>编辑全局 hexo 的配置文件：<code>_config.yml</code><br>注意<code>:</code>后留一个空格<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">type: git</div><div class="line">repository: https://github.com/BalianCheng/BalianCheng.github.io.git</div><div class="line">branch: master</div></pre></td></tr></table></figure><p></p>
<p>编辑全局配置后需要重新部署：<br>清除掉已经生成的文件：<code>hexo clean</code><br>再生成静态文件：<code>hexo generate</code><br>预览：<code>hexo server</code><br>打开<code>localhost:4000</code>查看<br>部署：<code>hexo deploy</code><br>生成 40 4页面：<code>hexo new page 404</code><br>生成 about 页面：<code>hexo new page about</code><br>生成 tag 标签云页面：<code>hexo new page tags</code><br>安装RSS订阅：<code>npm install hexo-generator-feed --save</code>安装插件，自动生成atom.xml，提供订阅</p>
<p></p><h2 id="6">绑定域名</h2><br><code>ping yourname.github.io</code>获得IP地址并使用域名解析<br>进入GitHub项目,进入<code>Settings</code>,在<code>Custom domain</code>写入域名<br>在\blog\public下建立CNAME文件写入域名<br>将CNAME放入\blog\source\中避免重复操作<p></p>
]]></content>
    </entry>
    
  
  
</search>
